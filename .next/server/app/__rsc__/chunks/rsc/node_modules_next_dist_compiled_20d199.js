(self.TURBOPACK = self.TURBOPACK || []).push(["chunks/rsc/node_modules_next_dist_compiled_20d199.js", {

"[project-with-next]/node_modules/next/dist/compiled/react/react.shared-subset.js (ecmascript, rsc)": (function({ r: __turbopack_require__, x: __turbopack_external_require__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, c: __turbopack_cache__, l: __turbopack_load__, p: process, __dirname, m: module, e: exports }) { !function() {

'use strict';
if (process.env.NODE_ENV === 'production') {
    module.exports = __turbopack_require__("[project-with-next]/node_modules/next/dist/compiled/react/cjs/react.shared-subset.production.min.js (ecmascript, rsc)");
} else {
    module.exports = __turbopack_require__("[project-with-next]/node_modules/next/dist/compiled/react/cjs/react.shared-subset.development.js (ecmascript, rsc)");
}

}.call(this) }),
"[project-with-next]/node_modules/next/dist/compiled/react/cjs/react.shared-subset.production.min.js (ecmascript, rsc)": (function({ r: __turbopack_require__, x: __turbopack_external_require__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, c: __turbopack_cache__, l: __turbopack_load__, p: process, __dirname, m: module, e: exports }) { !function() {

'use strict';
var m = Object.assign, n = {
    current: null
};
function p() {
    return new Map;
}
if ("function" === typeof fetch) {
    var q = fetch;
    try {
        fetch = function(a, b) {
            var d = n.current;
            if (!d || b && b.signal && b.signal !== d.getCacheSignal()) return q(a, b);
            if ("string" !== typeof a || b) {
                var c = new Request(a, b);
                if ("GET" !== c.method && "HEAD" !== c.method || c.keepalive) return q(a, b);
                var e = JSON.stringify([
                    c.method,
                    Array.from(c.headers.entries()),
                    c.mode,
                    c.redirect,
                    c.credentials,
                    c.referrer,
                    c.referrerPolicy,
                    c.integrity
                ]);
                c = c.url;
            } else e = '["GET",[],null,"follow",null,null,null,null]', c = a;
            var f = d.getCacheForType(p);
            d = f.get(c);
            if (void 0 === d) a = q(a, b), f.set(c, [
                e,
                a
            ]);
            else {
                c = 0;
                for(f = d.length; c < f; c += 2){
                    var g = d[c + 1];
                    if (d[c] === e) return a = g, a.then(function(a) {
                        return a.clone();
                    });
                }
                a = q(a, b);
                d.push(e, a);
            }
            return a.then(function(a) {
                return a.clone();
            });
        }, m(fetch, q);
    } catch (a) {
        console.warn("React was unable to patch the fetch() function in this environment. Suspensey APIs might not work correctly as a result.");
    }
}
var r = Symbol.for("react.element"), t = Symbol.for("react.portal"), u = Symbol.for("react.fragment"), v = Symbol.for("react.strict_mode"), w = Symbol.for("react.profiler"), x = Symbol.for("react.provider"), y = Symbol.for("react.server_context"), z = Symbol.for("react.forward_ref"), A = Symbol.for("react.suspense"), B = Symbol.for("react.memo"), C = Symbol.for("react.lazy"), D = Symbol.for("react.default_value"), E = Symbol.iterator;
function aa(a) {
    if (null === a || "object" !== typeof a) return null;
    a = E && a[E] || a["@@iterator"];
    return "function" === typeof a ? a : null;
}
function F(a) {
    for(var b = "https://reactjs.org/docs/error-decoder.html?invariant=" + a, d = 1; d < arguments.length; d++)b += "&args[]=" + encodeURIComponent(arguments[d]);
    return "Minified React error #" + a + "; visit " + b + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
}
var G = {
    isMounted: function() {
        return !1;
    },
    enqueueForceUpdate: function() {},
    enqueueReplaceState: function() {},
    enqueueSetState: function() {}
}, H = {};
function I(a, b, d) {
    this.props = a;
    this.context = b;
    this.refs = H;
    this.updater = d || G;
}
I.prototype.isReactComponent = {};
I.prototype.setState = function(a, b) {
    if ("object" !== typeof a && "function" !== typeof a && null != a) throw Error(F(85));
    this.updater.enqueueSetState(this, a, b, "setState");
};
I.prototype.forceUpdate = function(a) {
    this.updater.enqueueForceUpdate(this, a, "forceUpdate");
};
function J() {}
J.prototype = I.prototype;
function K(a, b, d) {
    this.props = a;
    this.context = b;
    this.refs = H;
    this.updater = d || G;
}
var L = K.prototype = new J;
L.constructor = K;
m(L, I.prototype);
L.isPureReactComponent = !0;
var M = Array.isArray, N = Object.prototype.hasOwnProperty, O = {
    current: null
}, P = {
    key: !0,
    ref: !0,
    __self: !0,
    __source: !0
};
function ba(a, b) {
    return {
        $$typeof: r,
        type: a.type,
        key: b,
        ref: a.ref,
        props: a.props,
        _owner: a._owner
    };
}
function Q(a) {
    return "object" === typeof a && null !== a && a.$$typeof === r;
}
function escape(a) {
    var b = {
        "=": "=0",
        ":": "=2"
    };
    return "$" + a.replace(/[=:]/g, function(a) {
        return b[a];
    });
}
var R = /\/+/g;
function S(a, b) {
    return "object" === typeof a && null !== a && null != a.key ? escape("" + a.key) : b.toString(36);
}
function T(a, b, d, c, e) {
    var f = typeof a;
    if ("undefined" === f || "boolean" === f) a = null;
    var g = !1;
    if (null === a) g = !0;
    else switch(f){
        case "string":
        case "number":
            g = !0;
            break;
        case "object":
            switch(a.$$typeof){
                case r:
                case t:
                    g = !0;
            }
    }
    if (g) return g = a, e = e(g), a = "" === c ? "." + S(g, 0) : c, M(e) ? (d = "", null != a && (d = a.replace(R, "$&/") + "/"), T(e, b, d, "", function(a) {
        return a;
    })) : null != e && (Q(e) && (e = ba(e, d + (!e.key || g && g.key === e.key ? "" : ("" + e.key).replace(R, "$&/") + "/") + a)), b.push(e)), 1;
    g = 0;
    c = "" === c ? "." : c + ":";
    if (M(a)) for(var h = 0; h < a.length; h++){
        f = a[h];
        var k = c + S(f, h);
        g += T(f, b, d, k, e);
    }
    else if (k = aa(a), "function" === typeof k) for(a = k.call(a), h = 0; !(f = a.next()).done;)f = f.value, k = c + S(f, h++), g += T(f, b, d, k, e);
    else if ("object" === f) throw b = String(a), Error(F(31, "[object Object]" === b ? "object with keys {" + Object.keys(a).join(", ") + "}" : b));
    return g;
}
function U(a, b, d) {
    if (null == a) return a;
    var c = [], e = 0;
    T(a, c, "", "", function(a) {
        return b.call(d, a, e++);
    });
    return c;
}
function ca(a) {
    if (-1 === a._status) {
        var b = a._result;
        b = b();
        b.then(function(b) {
            if (0 === a._status || -1 === a._status) a._status = 1, a._result = b;
        }, function(b) {
            if (0 === a._status || -1 === a._status) a._status = 2, a._result = b;
        });
        -1 === a._status && (a._status = 0, a._result = b);
    }
    if (1 === a._status) return a._result.default;
    throw a._result;
}
function da() {
    return new WeakMap;
}
function V() {
    return {
        s: 0,
        v: void 0,
        o: null,
        p: null
    };
}
var W = {
    current: null
}, X = {
    transition: null
}, Y = {
    ReactCurrentDispatcher: W,
    ReactCurrentCache: n,
    ReactCurrentBatchConfig: X,
    ReactCurrentOwner: O,
    ContextRegistry: {}
}, Z = Y.ContextRegistry;
exports.Children = {
    map: U,
    forEach: function(a, b, d) {
        U(a, function() {
            b.apply(this, arguments);
        }, d);
    },
    count: function(a) {
        var b = 0;
        U(a, function() {
            b++;
        });
        return b;
    },
    toArray: function(a) {
        return U(a, function(a) {
            return a;
        }) || [];
    },
    only: function(a) {
        if (!Q(a)) throw Error(F(143));
        return a;
    }
};
exports.Fragment = u;
exports.Profiler = w;
exports.StrictMode = v;
exports.Suspense = A;
exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = Y;
exports.cache = function(a) {
    return function() {
        var b = n.current;
        if (!b) return a.apply(null, arguments);
        var d = b.getCacheForType(da);
        b = d.get(a);
        void 0 === b && (b = V(), d.set(a, b));
        d = 0;
        for(var c = arguments.length; d < c; d++){
            var e = arguments[d];
            if ("function" === typeof e || "object" === typeof e && null !== e) {
                var f = b.o;
                null === f && (b.o = f = new WeakMap);
                b = f.get(e);
                void 0 === b && (b = V(), f.set(e, b));
            } else f = b.p, null === f && (b.p = f = new Map), b = f.get(e), void 0 === b && (b = V(), f.set(e, b));
        }
        if (1 === b.s) return b.v;
        if (2 === b.s) throw b.v;
        try {
            var g = a.apply(null, arguments);
            d = b;
            d.s = 1;
            return d.v = g;
        } catch (h) {
            throw g = b, g.s = 2, g.v = h, h;
        }
    };
};
exports.cloneElement = function(a, b, d) {
    if (null === a || void 0 === a) throw Error(F(267, a));
    var c = m({}, a.props), e = a.key, f = a.ref, g = a._owner;
    if (null != b) {
        void 0 !== b.ref && (f = b.ref, g = O.current);
        void 0 !== b.key && (e = "" + b.key);
        if (a.type && a.type.defaultProps) var h = a.type.defaultProps;
        for(k in b)N.call(b, k) && !P.hasOwnProperty(k) && (c[k] = void 0 === b[k] && void 0 !== h ? h[k] : b[k]);
    }
    var k = arguments.length - 2;
    if (1 === k) c.children = d;
    else if (1 < k) {
        h = Array(k);
        for(var l = 0; l < k; l++)h[l] = arguments[l + 2];
        c.children = h;
    }
    return {
        $$typeof: r,
        type: a.type,
        key: e,
        ref: f,
        props: c,
        _owner: g
    };
};
exports.createElement = function(a, b, d) {
    var c, e = {}, f = null, g = null;
    if (null != b) for(c in void 0 !== b.ref && (g = b.ref), void 0 !== b.key && (f = "" + b.key), b)N.call(b, c) && !P.hasOwnProperty(c) && (e[c] = b[c]);
    var h = arguments.length - 2;
    if (1 === h) e.children = d;
    else if (1 < h) {
        for(var k = Array(h), l = 0; l < h; l++)k[l] = arguments[l + 2];
        e.children = k;
    }
    if (a && a.defaultProps) for(c in h = a.defaultProps, h)void 0 === e[c] && (e[c] = h[c]);
    return {
        $$typeof: r,
        type: a,
        key: f,
        ref: g,
        props: e,
        _owner: O.current
    };
};
exports.createRef = function() {
    return {
        current: null
    };
};
exports.createServerContext = function(a, b) {
    var d = !0;
    if (!Z[a]) {
        d = !1;
        var c = {
            $$typeof: y,
            _currentValue: b,
            _currentValue2: b,
            _defaultValue: b,
            _threadCount: 0,
            Provider: null,
            Consumer: null,
            _globalName: a
        };
        c.Provider = {
            $$typeof: x,
            _context: c
        };
        Z[a] = c;
    }
    c = Z[a];
    if (c._defaultValue === D) c._defaultValue = b, c._currentValue === D && (c._currentValue = b), c._currentValue2 === D && (c._currentValue2 = b);
    else if (d) throw Error(F(429, a));
    return c;
};
exports.forwardRef = function(a) {
    return {
        $$typeof: z,
        render: a
    };
};
exports.isValidElement = Q;
exports.lazy = function(a) {
    return {
        $$typeof: C,
        _payload: {
            _status: -1,
            _result: a
        },
        _init: ca
    };
};
exports.memo = function(a, b) {
    return {
        $$typeof: B,
        type: a,
        compare: void 0 === b ? null : b
    };
};
exports.startTransition = function(a) {
    var b = X.transition;
    X.transition = {};
    try {
        a();
    } finally{
        X.transition = b;
    }
};
exports.use = function(a) {
    return W.current.use(a);
};
exports.useCallback = function(a, b) {
    return W.current.useCallback(a, b);
};
exports.useContext = function(a) {
    return W.current.useContext(a);
};
exports.useDebugValue = function() {};
exports.useId = function() {
    return W.current.useId();
};
exports.useMemo = function(a, b) {
    return W.current.useMemo(a, b);
};
exports.version = "18.3.0-next-d925a8d0b-20221024";

}.call(this) }),
"[project-with-next]/node_modules/next/dist/compiled/react/cjs/react.shared-subset.development.js (ecmascript, rsc)": (function({ r: __turbopack_require__, x: __turbopack_external_require__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, c: __turbopack_cache__, l: __turbopack_load__, p: process, __dirname, m: module, e: exports }) { !function() {

'use strict';
if (process.env.NODE_ENV !== "production") {
    (function() {
        'use strict';
        var ReactCurrentDispatcher = {
            current: null
        };
        var ReactCurrentCache = {
            current: null
        };
        var ReactCurrentBatchConfig = {
            transition: null
        };
        var ReactCurrentActQueue = {
            current: null,
            isBatchingLegacy: false,
            didScheduleLegacyUpdate: false,
            didUsePromise: false
        };
        var ReactCurrentOwner = {
            current: null
        };
        var ReactDebugCurrentFrame = {};
        var currentExtraStackFrame = null;
        function setExtraStackFrame(stack) {
            {
                currentExtraStackFrame = stack;
            }
        }
        {
            ReactDebugCurrentFrame.setExtraStackFrame = function(stack) {
                {
                    currentExtraStackFrame = stack;
                }
            };
            ReactDebugCurrentFrame.getCurrentStack = null;
            ReactDebugCurrentFrame.getStackAddendum = function() {
                var stack = '';
                if (currentExtraStackFrame) {
                    stack += currentExtraStackFrame;
                }
                var impl = ReactDebugCurrentFrame.getCurrentStack;
                if (impl) {
                    stack += impl() || '';
                }
                return stack;
            };
        }
        var enableScopeAPI = false;
        var enableCacheElement = false;
        var enableTransitionTracing = false;
        var enableLegacyHidden = false;
        var enableDebugTracing = false;
        var ContextRegistry = {};
        var ReactSharedInternals = {
            ReactCurrentDispatcher: ReactCurrentDispatcher,
            ReactCurrentCache: ReactCurrentCache,
            ReactCurrentBatchConfig: ReactCurrentBatchConfig,
            ReactCurrentOwner: ReactCurrentOwner
        };
        {
            ReactSharedInternals.ReactDebugCurrentFrame = ReactDebugCurrentFrame;
            ReactSharedInternals.ReactCurrentActQueue = ReactCurrentActQueue;
        }
        {
            ReactSharedInternals.ContextRegistry = ContextRegistry;
        }
        function warn(format) {
            {
                {
                    for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
                        args[_key - 1] = arguments[_key];
                    }
                    printWarning('warn', format, args);
                }
            }
        }
        function error(format) {
            {
                {
                    for(var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++){
                        args[_key2 - 1] = arguments[_key2];
                    }
                    printWarning('error', format, args);
                }
            }
        }
        function printWarning(level, format, args) {
            {
                var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
                var stack = ReactDebugCurrentFrame.getStackAddendum();
                if (stack !== '') {
                    format += '%s';
                    args = args.concat([
                        stack
                    ]);
                }
                var argsWithFormat = args.map(function(item) {
                    return String(item);
                });
                argsWithFormat.unshift('Warning: ' + format);
                Function.prototype.apply.call(console[level], console, argsWithFormat);
            }
        }
        var assign = Object.assign;
        function createFetchCache() {
            return new Map();
        }
        var simpleCacheKey = '["GET",[],null,"follow",null,null,null,null]';
        function generateCacheKey(request) {
            return JSON.stringify([
                request.method,
                Array.from(request.headers.entries()),
                request.mode,
                request.redirect,
                request.credentials,
                request.referrer,
                request.referrerPolicy,
                request.integrity
            ]);
        }
        {
            if (typeof fetch === 'function') {
                var originalFetch = fetch;
                try {
                    fetch = function fetch(resource, options) {
                        var dispatcher = ReactCurrentCache.current;
                        if (!dispatcher) {
                            return originalFetch(resource, options);
                        }
                        if (options && options.signal && options.signal !== dispatcher.getCacheSignal()) {
                            return originalFetch(resource, options);
                        }
                        var url;
                        var cacheKey;
                        if (typeof resource === 'string' && !options) {
                            cacheKey = simpleCacheKey;
                            url = resource;
                        } else {
                            var request = new Request(resource, options);
                            if (request.method !== 'GET' && request.method !== 'HEAD' || request.keepalive) {
                                return originalFetch(resource, options);
                            }
                            cacheKey = generateCacheKey(request);
                            url = request.url;
                        }
                        var cache = dispatcher.getCacheForType(createFetchCache);
                        var cacheEntries = cache.get(url);
                        var match;
                        if (cacheEntries === undefined) {
                            match = originalFetch(resource, options);
                            cache.set(url, [
                                cacheKey,
                                match
                            ]);
                        } else {
                            for(var i = 0, l = cacheEntries.length; i < l; i += 2){
                                var key = cacheEntries[i];
                                var value = cacheEntries[i + 1];
                                if (key === cacheKey) {
                                    match = value;
                                    return match.then(function(response) {
                                        return response.clone();
                                    });
                                }
                            }
                            match = originalFetch(resource, options);
                            cacheEntries.push(cacheKey, match);
                        }
                        return match.then(function(response) {
                            return response.clone();
                        });
                    };
                    assign(fetch, originalFetch);
                } catch (error) {
                    warn('React was unable to patch the fetch() function in this environment. ' + 'Suspensey APIs might not work correctly as a result.');
                }
            }
        }
        var ReactVersion = '18.3.0-next-d925a8d0b-20221024';
        var REACT_ELEMENT_TYPE = Symbol.for('react.element');
        var REACT_PORTAL_TYPE = Symbol.for('react.portal');
        var REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');
        var REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode');
        var REACT_PROFILER_TYPE = Symbol.for('react.profiler');
        var REACT_PROVIDER_TYPE = Symbol.for('react.provider');
        var REACT_CONTEXT_TYPE = Symbol.for('react.context');
        var REACT_SERVER_CONTEXT_TYPE = Symbol.for('react.server_context');
        var REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');
        var REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');
        var REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');
        var REACT_MEMO_TYPE = Symbol.for('react.memo');
        var REACT_LAZY_TYPE = Symbol.for('react.lazy');
        var REACT_OFFSCREEN_TYPE = Symbol.for('react.offscreen');
        var REACT_CACHE_TYPE = Symbol.for('react.cache');
        var REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED = Symbol.for('react.default_value');
        var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
        var FAUX_ITERATOR_SYMBOL = '@@iterator';
        function getIteratorFn(maybeIterable) {
            if (maybeIterable === null || typeof maybeIterable !== 'object') {
                return null;
            }
            var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
            if (typeof maybeIterator === 'function') {
                return maybeIterator;
            }
            return null;
        }
        var didWarnStateUpdateForUnmountedComponent = {};
        function warnNoop(publicInstance, callerName) {
            {
                var _constructor = publicInstance.constructor;
                var componentName = _constructor && (_constructor.displayName || _constructor.name) || 'ReactClass';
                var warningKey = componentName + "." + callerName;
                if (didWarnStateUpdateForUnmountedComponent[warningKey]) {
                    return;
                }
                error("Can't call %s on a component that is not yet mounted. " + 'This is a no-op, but it might indicate a bug in your application. ' + 'Instead, assign to `this.state` directly or define a `state = {};` ' + 'class property with the desired state in the %s component.', callerName, componentName);
                didWarnStateUpdateForUnmountedComponent[warningKey] = true;
            }
        }
        var ReactNoopUpdateQueue = {
            isMounted: function(publicInstance) {
                return false;
            },
            enqueueForceUpdate: function(publicInstance, callback, callerName) {
                warnNoop(publicInstance, 'forceUpdate');
            },
            enqueueReplaceState: function(publicInstance, completeState, callback, callerName) {
                warnNoop(publicInstance, 'replaceState');
            },
            enqueueSetState: function(publicInstance, partialState, callback, callerName) {
                warnNoop(publicInstance, 'setState');
            }
        };
        var emptyObject = {};
        {
            Object.freeze(emptyObject);
        }
        function Component(props, context, updater) {
            this.props = props;
            this.context = context;
            this.refs = emptyObject;
            this.updater = updater || ReactNoopUpdateQueue;
        }
        Component.prototype.isReactComponent = {};
        Component.prototype.setState = function(partialState, callback) {
            if (typeof partialState !== 'object' && typeof partialState !== 'function' && partialState != null) {
                throw new Error('setState(...): takes an object of state variables to update or a ' + 'function which returns an object of state variables.');
            }
            this.updater.enqueueSetState(this, partialState, callback, 'setState');
        };
        Component.prototype.forceUpdate = function(callback) {
            this.updater.enqueueForceUpdate(this, callback, 'forceUpdate');
        };
        {
            var deprecatedAPIs = {
                isMounted: [
                    'isMounted',
                    'Instead, make sure to clean up subscriptions and pending requests in ' + 'componentWillUnmount to prevent memory leaks.'
                ],
                replaceState: [
                    'replaceState',
                    'Refactor your code to use setState instead (see ' + 'https://github.com/facebook/react/issues/3236).'
                ]
            };
            var defineDeprecationWarning = function(methodName, info) {
                Object.defineProperty(Component.prototype, methodName, {
                    get: function() {
                        warn('%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]);
                        return undefined;
                    }
                });
            };
            for(var fnName in deprecatedAPIs){
                if (deprecatedAPIs.hasOwnProperty(fnName)) {
                    defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
                }
            }
        }
        function ComponentDummy() {}
        ComponentDummy.prototype = Component.prototype;
        function PureComponent(props, context, updater) {
            this.props = props;
            this.context = context;
            this.refs = emptyObject;
            this.updater = updater || ReactNoopUpdateQueue;
        }
        var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();
        pureComponentPrototype.constructor = PureComponent;
        assign(pureComponentPrototype, Component.prototype);
        pureComponentPrototype.isPureReactComponent = true;
        function createRef() {
            var refObject = {
                current: null
            };
            {
                Object.seal(refObject);
            }
            return refObject;
        }
        var isArrayImpl = Array.isArray;
        function isArray(a) {
            return isArrayImpl(a);
        }
        function typeName(value) {
            {
                var hasToStringTag = typeof Symbol === 'function' && Symbol.toStringTag;
                var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || 'Object';
                return type;
            }
        }
        function willCoercionThrow(value) {
            {
                try {
                    testStringCoercion(value);
                    return false;
                } catch (e) {
                    return true;
                }
            }
        }
        function testStringCoercion(value) {
            return '' + value;
        }
        function checkKeyStringCoercion(value) {
            {
                if (willCoercionThrow(value)) {
                    error('The provided key is an unsupported type %s.' + ' This value must be coerced to a string before before using it here.', typeName(value));
                    return testStringCoercion(value);
                }
            }
        }
        function getWrappedName(outerType, innerType, wrapperName) {
            var displayName = outerType.displayName;
            if (displayName) {
                return displayName;
            }
            var functionName = innerType.displayName || innerType.name || '';
            return functionName !== '' ? wrapperName + "(" + functionName + ")" : wrapperName;
        }
        function getContextName(type) {
            return type.displayName || 'Context';
        }
        function getComponentNameFromType(type) {
            if (type == null) {
                return null;
            }
            {
                if (typeof type.tag === 'number') {
                    error('Received an unexpected object in getComponentNameFromType(). ' + 'This is likely a bug in React. Please file an issue.');
                }
            }
            if (typeof type === 'function') {
                return type.displayName || type.name || null;
            }
            if (typeof type === 'string') {
                return type;
            }
            switch(type){
                case REACT_FRAGMENT_TYPE:
                    return 'Fragment';
                case REACT_PORTAL_TYPE:
                    return 'Portal';
                case REACT_PROFILER_TYPE:
                    return 'Profiler';
                case REACT_STRICT_MODE_TYPE:
                    return 'StrictMode';
                case REACT_SUSPENSE_TYPE:
                    return 'Suspense';
                case REACT_SUSPENSE_LIST_TYPE:
                    return 'SuspenseList';
                case REACT_CACHE_TYPE:
                    {
                        return 'Cache';
                    }
            }
            if (typeof type === 'object') {
                switch(type.$$typeof){
                    case REACT_CONTEXT_TYPE:
                        var context = type;
                        return getContextName(context) + '.Consumer';
                    case REACT_PROVIDER_TYPE:
                        var provider = type;
                        return getContextName(provider._context) + '.Provider';
                    case REACT_FORWARD_REF_TYPE:
                        return getWrappedName(type, type.render, 'ForwardRef');
                    case REACT_MEMO_TYPE:
                        var outerName = type.displayName || null;
                        if (outerName !== null) {
                            return outerName;
                        }
                        return getComponentNameFromType(type.type) || 'Memo';
                    case REACT_LAZY_TYPE:
                        {
                            var lazyComponent = type;
                            var payload = lazyComponent._payload;
                            var init = lazyComponent._init;
                            try {
                                return getComponentNameFromType(init(payload));
                            } catch (x) {
                                return null;
                            }
                        }
                    case REACT_SERVER_CONTEXT_TYPE:
                        {
                            var context2 = type;
                            return (context2.displayName || context2._globalName) + '.Provider';
                        }
                }
            }
            return null;
        }
        var hasOwnProperty = Object.prototype.hasOwnProperty;
        var RESERVED_PROPS = {
            key: true,
            ref: true,
            __self: true,
            __source: true
        };
        var specialPropKeyWarningShown, specialPropRefWarningShown, didWarnAboutStringRefs;
        {
            didWarnAboutStringRefs = {};
        }
        function hasValidRef(config) {
            {
                if (hasOwnProperty.call(config, 'ref')) {
                    var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;
                    if (getter && getter.isReactWarning) {
                        return false;
                    }
                }
            }
            return config.ref !== undefined;
        }
        function hasValidKey(config) {
            {
                if (hasOwnProperty.call(config, 'key')) {
                    var getter = Object.getOwnPropertyDescriptor(config, 'key').get;
                    if (getter && getter.isReactWarning) {
                        return false;
                    }
                }
            }
            return config.key !== undefined;
        }
        function defineKeyPropWarningGetter(props, displayName) {
            var warnAboutAccessingKey = function() {
                {
                    if (!specialPropKeyWarningShown) {
                        specialPropKeyWarningShown = true;
                        error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);
                    }
                }
            };
            warnAboutAccessingKey.isReactWarning = true;
            Object.defineProperty(props, 'key', {
                get: warnAboutAccessingKey,
                configurable: true
            });
        }
        function defineRefPropWarningGetter(props, displayName) {
            var warnAboutAccessingRef = function() {
                {
                    if (!specialPropRefWarningShown) {
                        specialPropRefWarningShown = true;
                        error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);
                    }
                }
            };
            warnAboutAccessingRef.isReactWarning = true;
            Object.defineProperty(props, 'ref', {
                get: warnAboutAccessingRef,
                configurable: true
            });
        }
        function warnIfStringRefCannotBeAutoConverted(config) {
            {
                if (typeof config.ref === 'string' && ReactCurrentOwner.current && config.__self && ReactCurrentOwner.current.stateNode !== config.__self) {
                    var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);
                    if (!didWarnAboutStringRefs[componentName]) {
                        error('Component "%s" contains the string ref "%s". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', componentName, config.ref);
                        didWarnAboutStringRefs[componentName] = true;
                    }
                }
            }
        }
        var ReactElement = function(type, key, ref, self, source, owner, props) {
            var element = {
                $$typeof: REACT_ELEMENT_TYPE,
                type: type,
                key: key,
                ref: ref,
                props: props,
                _owner: owner
            };
            {
                element._store = {};
                Object.defineProperty(element._store, 'validated', {
                    configurable: false,
                    enumerable: false,
                    writable: true,
                    value: false
                });
                Object.defineProperty(element, '_self', {
                    configurable: false,
                    enumerable: false,
                    writable: false,
                    value: self
                });
                Object.defineProperty(element, '_source', {
                    configurable: false,
                    enumerable: false,
                    writable: false,
                    value: source
                });
                if (Object.freeze) {
                    Object.freeze(element.props);
                    Object.freeze(element);
                }
            }
            return element;
        };
        function createElement(type, config, children) {
            var propName;
            var props = {};
            var key = null;
            var ref = null;
            var self = null;
            var source = null;
            if (config != null) {
                if (hasValidRef(config)) {
                    ref = config.ref;
                    {
                        warnIfStringRefCannotBeAutoConverted(config);
                    }
                }
                if (hasValidKey(config)) {
                    {
                        checkKeyStringCoercion(config.key);
                    }
                    key = '' + config.key;
                }
                self = config.__self === undefined ? null : config.__self;
                source = config.__source === undefined ? null : config.__source;
                for(propName in config){
                    if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
                        props[propName] = config[propName];
                    }
                }
            }
            var childrenLength = arguments.length - 2;
            if (childrenLength === 1) {
                props.children = children;
            } else if (childrenLength > 1) {
                var childArray = Array(childrenLength);
                for(var i = 0; i < childrenLength; i++){
                    childArray[i] = arguments[i + 2];
                }
                {
                    if (Object.freeze) {
                        Object.freeze(childArray);
                    }
                }
                props.children = childArray;
            }
            if (type && type.defaultProps) {
                var defaultProps = type.defaultProps;
                for(propName in defaultProps){
                    if (props[propName] === undefined) {
                        props[propName] = defaultProps[propName];
                    }
                }
            }
            {
                if (key || ref) {
                    var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;
                    if (key) {
                        defineKeyPropWarningGetter(props, displayName);
                    }
                    if (ref) {
                        defineRefPropWarningGetter(props, displayName);
                    }
                }
            }
            return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
        }
        function cloneAndReplaceKey(oldElement, newKey) {
            var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);
            return newElement;
        }
        function cloneElement(element, config, children) {
            if (element === null || element === undefined) {
                throw new Error("React.cloneElement(...): The argument must be a React element, but you passed " + element + ".");
            }
            var propName;
            var props = assign({}, element.props);
            var key = element.key;
            var ref = element.ref;
            var self = element._self;
            var source = element._source;
            var owner = element._owner;
            if (config != null) {
                if (hasValidRef(config)) {
                    ref = config.ref;
                    owner = ReactCurrentOwner.current;
                }
                if (hasValidKey(config)) {
                    {
                        checkKeyStringCoercion(config.key);
                    }
                    key = '' + config.key;
                }
                var defaultProps;
                if (element.type && element.type.defaultProps) {
                    defaultProps = element.type.defaultProps;
                }
                for(propName in config){
                    if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
                        if (config[propName] === undefined && defaultProps !== undefined) {
                            props[propName] = defaultProps[propName];
                        } else {
                            props[propName] = config[propName];
                        }
                    }
                }
            }
            var childrenLength = arguments.length - 2;
            if (childrenLength === 1) {
                props.children = children;
            } else if (childrenLength > 1) {
                var childArray = Array(childrenLength);
                for(var i = 0; i < childrenLength; i++){
                    childArray[i] = arguments[i + 2];
                }
                props.children = childArray;
            }
            return ReactElement(element.type, key, ref, self, source, owner, props);
        }
        function isValidElement(object) {
            return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
        }
        var SEPARATOR = '.';
        var SUBSEPARATOR = ':';
        function escape(key) {
            var escapeRegex = /[=:]/g;
            var escaperLookup = {
                '=': '=0',
                ':': '=2'
            };
            var escapedString = key.replace(escapeRegex, function(match) {
                return escaperLookup[match];
            });
            return '$' + escapedString;
        }
        var didWarnAboutMaps = false;
        var userProvidedKeyEscapeRegex = /\/+/g;
        function escapeUserProvidedKey(text) {
            return text.replace(userProvidedKeyEscapeRegex, '$&/');
        }
        function getElementKey(element, index) {
            if (typeof element === 'object' && element !== null && element.key != null) {
                {
                    checkKeyStringCoercion(element.key);
                }
                return escape('' + element.key);
            }
            return index.toString(36);
        }
        function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
            var type = typeof children;
            if (type === 'undefined' || type === 'boolean') {
                children = null;
            }
            var invokeCallback = false;
            if (children === null) {
                invokeCallback = true;
            } else {
                switch(type){
                    case 'string':
                    case 'number':
                        invokeCallback = true;
                        break;
                    case 'object':
                        switch(children.$$typeof){
                            case REACT_ELEMENT_TYPE:
                            case REACT_PORTAL_TYPE:
                                invokeCallback = true;
                        }
                }
            }
            if (invokeCallback) {
                var _child = children;
                var mappedChild = callback(_child);
                var childKey = nameSoFar === '' ? SEPARATOR + getElementKey(_child, 0) : nameSoFar;
                if (isArray(mappedChild)) {
                    var escapedChildKey = '';
                    if (childKey != null) {
                        escapedChildKey = escapeUserProvidedKey(childKey) + '/';
                    }
                    mapIntoArray(mappedChild, array, escapedChildKey, '', function(c) {
                        return c;
                    });
                } else if (mappedChild != null) {
                    if (isValidElement(mappedChild)) {
                        {
                            if (mappedChild.key && (!_child || _child.key !== mappedChild.key)) {
                                checkKeyStringCoercion(mappedChild.key);
                            }
                        }
                        mappedChild = cloneAndReplaceKey(mappedChild, escapedPrefix + (mappedChild.key && (!_child || _child.key !== mappedChild.key) ? escapeUserProvidedKey('' + mappedChild.key) + '/' : '') + childKey);
                    }
                    array.push(mappedChild);
                }
                return 1;
            }
            var child;
            var nextName;
            var subtreeCount = 0;
            var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;
            if (isArray(children)) {
                for(var i = 0; i < children.length; i++){
                    child = children[i];
                    nextName = nextNamePrefix + getElementKey(child, i);
                    subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);
                }
            } else {
                var iteratorFn = getIteratorFn(children);
                if (typeof iteratorFn === 'function') {
                    var iterableChildren = children;
                    {
                        if (iteratorFn === iterableChildren.entries) {
                            if (!didWarnAboutMaps) {
                                warn('Using Maps as children is not supported. ' + 'Use an array of keyed ReactElements instead.');
                            }
                            didWarnAboutMaps = true;
                        }
                    }
                    var iterator = iteratorFn.call(iterableChildren);
                    var step;
                    var ii = 0;
                    while(!(step = iterator.next()).done){
                        child = step.value;
                        nextName = nextNamePrefix + getElementKey(child, ii++);
                        subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);
                    }
                } else if (type === 'object') {
                    var childrenString = String(children);
                    throw new Error("Objects are not valid as a React child (found: " + (childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString) + "). " + 'If you meant to render a collection of children, use an array ' + 'instead.');
                }
            }
            return subtreeCount;
        }
        function mapChildren(children, func, context) {
            if (children == null) {
                return children;
            }
            var result = [];
            var count = 0;
            mapIntoArray(children, result, '', '', function(child) {
                return func.call(context, child, count++);
            });
            return result;
        }
        function countChildren(children) {
            var n = 0;
            mapChildren(children, function() {
                n++;
            });
            return n;
        }
        function forEachChildren(children, forEachFunc, forEachContext) {
            mapChildren(children, function() {
                forEachFunc.apply(this, arguments);
            }, forEachContext);
        }
        function toArray(children) {
            return mapChildren(children, function(child) {
                return child;
            }) || [];
        }
        function onlyChild(children) {
            if (!isValidElement(children)) {
                throw new Error('React.Children.only expected to receive a single React element child.');
            }
            return children;
        }
        var Uninitialized = -1;
        var Pending = 0;
        var Resolved = 1;
        var Rejected = 2;
        function lazyInitializer(payload) {
            if (payload._status === Uninitialized) {
                var ctor = payload._result;
                var thenable = ctor();
                thenable.then(function(moduleObject) {
                    if (payload._status === Pending || payload._status === Uninitialized) {
                        var resolved = payload;
                        resolved._status = Resolved;
                        resolved._result = moduleObject;
                    }
                }, function(error) {
                    if (payload._status === Pending || payload._status === Uninitialized) {
                        var rejected = payload;
                        rejected._status = Rejected;
                        rejected._result = error;
                    }
                });
                if (payload._status === Uninitialized) {
                    var pending = payload;
                    pending._status = Pending;
                    pending._result = thenable;
                }
            }
            if (payload._status === Resolved) {
                var moduleObject = payload._result;
                {
                    if (moduleObject === undefined) {
                        error('lazy: Expected the result of a dynamic imp' + 'ort() call. ' + 'Instead received: %s\n\nYour code should look like: \n  ' + 'const MyComponent = lazy(() => imp' + "ort('./MyComponent'))\n\n" + 'Did you accidentally put curly braces around the import?', moduleObject);
                    }
                }
                {
                    if (!('default' in moduleObject)) {
                        error('lazy: Expected the result of a dynamic imp' + 'ort() call. ' + 'Instead received: %s\n\nYour code should look like: \n  ' + 'const MyComponent = lazy(() => imp' + "ort('./MyComponent'))", moduleObject);
                    }
                }
                return moduleObject.default;
            } else {
                throw payload._result;
            }
        }
        function lazy(ctor) {
            var payload = {
                _status: Uninitialized,
                _result: ctor
            };
            var lazyType = {
                $$typeof: REACT_LAZY_TYPE,
                _payload: payload,
                _init: lazyInitializer
            };
            {
                var defaultProps;
                var propTypes;
                Object.defineProperties(lazyType, {
                    defaultProps: {
                        configurable: true,
                        get: function() {
                            return defaultProps;
                        },
                        set: function(newDefaultProps) {
                            error('React.lazy(...): It is not supported to assign `defaultProps` to ' + 'a lazy component import. Either specify them where the component ' + 'is defined, or create a wrapping component around it.');
                            defaultProps = newDefaultProps;
                            Object.defineProperty(lazyType, 'defaultProps', {
                                enumerable: true
                            });
                        }
                    },
                    propTypes: {
                        configurable: true,
                        get: function() {
                            return propTypes;
                        },
                        set: function(newPropTypes) {
                            error('React.lazy(...): It is not supported to assign `propTypes` to ' + 'a lazy component import. Either specify them where the component ' + 'is defined, or create a wrapping component around it.');
                            propTypes = newPropTypes;
                            Object.defineProperty(lazyType, 'propTypes', {
                                enumerable: true
                            });
                        }
                    }
                });
            }
            return lazyType;
        }
        function forwardRef(render) {
            {
                if (render != null && render.$$typeof === REACT_MEMO_TYPE) {
                    error('forwardRef requires a render function but received a `memo` ' + 'component. Instead of forwardRef(memo(...)), use ' + 'memo(forwardRef(...)).');
                } else if (typeof render !== 'function') {
                    error('forwardRef requires a render function but was given %s.', render === null ? 'null' : typeof render);
                } else {
                    if (render.length !== 0 && render.length !== 2) {
                        error('forwardRef render functions accept exactly two parameters: props and ref. %s', render.length === 1 ? 'Did you forget to use the ref parameter?' : 'Any additional parameter will be undefined.');
                    }
                }
                if (render != null) {
                    if (render.defaultProps != null || render.propTypes != null) {
                        error('forwardRef render functions do not support propTypes or defaultProps. ' + 'Did you accidentally pass a React component?');
                    }
                }
            }
            var elementType = {
                $$typeof: REACT_FORWARD_REF_TYPE,
                render: render
            };
            {
                var ownName;
                Object.defineProperty(elementType, 'displayName', {
                    enumerable: false,
                    configurable: true,
                    get: function() {
                        return ownName;
                    },
                    set: function(name) {
                        ownName = name;
                        if (!render.name && !render.displayName) {
                            render.displayName = name;
                        }
                    }
                });
            }
            return elementType;
        }
        var REACT_MODULE_REFERENCE = Symbol.for('react.module.reference');
        function isValidElementType(type) {
            if (typeof type === 'string' || typeof type === 'function') {
                return true;
            }
            if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {
                return true;
            }
            if (typeof type === 'object' && type !== null) {
                if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== undefined) {
                    return true;
                }
            }
            return false;
        }
        function memo(type, compare) {
            {
                if (!isValidElementType(type)) {
                    error('memo: The first argument must be a component. Instead ' + 'received: %s', type === null ? 'null' : typeof type);
                }
            }
            var elementType = {
                $$typeof: REACT_MEMO_TYPE,
                type: type,
                compare: compare === undefined ? null : compare
            };
            {
                var ownName;
                Object.defineProperty(elementType, 'displayName', {
                    enumerable: false,
                    configurable: true,
                    get: function() {
                        return ownName;
                    },
                    set: function(name) {
                        ownName = name;
                        if (!type.name && !type.displayName) {
                            type.displayName = name;
                        }
                    }
                });
            }
            return elementType;
        }
        var UNTERMINATED = 0;
        var TERMINATED = 1;
        var ERRORED = 2;
        function createCacheRoot() {
            return new WeakMap();
        }
        function createCacheNode() {
            return {
                s: UNTERMINATED,
                v: undefined,
                o: null,
                p: null
            };
        }
        function cache(fn) {
            return function() {
                var dispatcher = ReactCurrentCache.current;
                if (!dispatcher) {
                    return fn.apply(null, arguments);
                }
                var fnMap = dispatcher.getCacheForType(createCacheRoot);
                var fnNode = fnMap.get(fn);
                var cacheNode;
                if (fnNode === undefined) {
                    cacheNode = createCacheNode();
                    fnMap.set(fn, cacheNode);
                } else {
                    cacheNode = fnNode;
                }
                for(var i = 0, l = arguments.length; i < l; i++){
                    var arg = arguments[i];
                    if (typeof arg === 'function' || typeof arg === 'object' && arg !== null) {
                        var objectCache = cacheNode.o;
                        if (objectCache === null) {
                            cacheNode.o = objectCache = new WeakMap();
                        }
                        var objectNode = objectCache.get(arg);
                        if (objectNode === undefined) {
                            cacheNode = createCacheNode();
                            objectCache.set(arg, cacheNode);
                        } else {
                            cacheNode = objectNode;
                        }
                    } else {
                        var primitiveCache = cacheNode.p;
                        if (primitiveCache === null) {
                            cacheNode.p = primitiveCache = new Map();
                        }
                        var primitiveNode = primitiveCache.get(arg);
                        if (primitiveNode === undefined) {
                            cacheNode = createCacheNode();
                            primitiveCache.set(arg, cacheNode);
                        } else {
                            cacheNode = primitiveNode;
                        }
                    }
                }
                if (cacheNode.s === TERMINATED) {
                    return cacheNode.v;
                }
                if (cacheNode.s === ERRORED) {
                    throw cacheNode.v;
                }
                try {
                    var result = fn.apply(null, arguments);
                    var terminatedNode = cacheNode;
                    terminatedNode.s = TERMINATED;
                    terminatedNode.v = result;
                    return result;
                } catch (error) {
                    var erroredNode = cacheNode;
                    erroredNode.s = ERRORED;
                    erroredNode.v = error;
                    throw error;
                }
            };
        }
        function resolveDispatcher() {
            var dispatcher = ReactCurrentDispatcher.current;
            {
                if (dispatcher === null) {
                    error('Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for' + ' one of the following reasons:\n' + '1. You might have mismatching versions of React and the renderer (such as React DOM)\n' + '2. You might be breaking the Rules of Hooks\n' + '3. You might have more than one copy of React in the same app\n' + 'See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.');
                }
            }
            return dispatcher;
        }
        function useContext(Context) {
            var dispatcher = resolveDispatcher();
            {
                if (Context._context !== undefined) {
                    var realContext = Context._context;
                    if (realContext.Consumer === Context) {
                        error('Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be ' + 'removed in a future major release. Did you mean to call useContext(Context) instead?');
                    } else if (realContext.Provider === Context) {
                        error('Calling useContext(Context.Provider) is not supported. ' + 'Did you mean to call useContext(Context) instead?');
                    }
                }
            }
            return dispatcher.useContext(Context);
        }
        function useCallback(callback, deps) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useCallback(callback, deps);
        }
        function useMemo(create, deps) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useMemo(create, deps);
        }
        function useDebugValue(value, formatterFn) {
            {
                var dispatcher = resolveDispatcher();
                return dispatcher.useDebugValue(value, formatterFn);
            }
        }
        function useId() {
            var dispatcher = resolveDispatcher();
            return dispatcher.useId();
        }
        function use(usable) {
            var dispatcher = resolveDispatcher();
            return dispatcher.use(usable);
        }
        var disabledDepth = 0;
        var prevLog;
        var prevInfo;
        var prevWarn;
        var prevError;
        var prevGroup;
        var prevGroupCollapsed;
        var prevGroupEnd;
        function disabledLog() {}
        disabledLog.__reactDisabledLog = true;
        function disableLogs() {
            {
                if (disabledDepth === 0) {
                    prevLog = console.log;
                    prevInfo = console.info;
                    prevWarn = console.warn;
                    prevError = console.error;
                    prevGroup = console.group;
                    prevGroupCollapsed = console.groupCollapsed;
                    prevGroupEnd = console.groupEnd;
                    var props = {
                        configurable: true,
                        enumerable: true,
                        value: disabledLog,
                        writable: true
                    };
                    Object.defineProperties(console, {
                        info: props,
                        log: props,
                        warn: props,
                        error: props,
                        group: props,
                        groupCollapsed: props,
                        groupEnd: props
                    });
                }
                disabledDepth++;
            }
        }
        function reenableLogs() {
            {
                disabledDepth--;
                if (disabledDepth === 0) {
                    var props = {
                        configurable: true,
                        enumerable: true,
                        writable: true
                    };
                    Object.defineProperties(console, {
                        log: assign({}, props, {
                            value: prevLog
                        }),
                        info: assign({}, props, {
                            value: prevInfo
                        }),
                        warn: assign({}, props, {
                            value: prevWarn
                        }),
                        error: assign({}, props, {
                            value: prevError
                        }),
                        group: assign({}, props, {
                            value: prevGroup
                        }),
                        groupCollapsed: assign({}, props, {
                            value: prevGroupCollapsed
                        }),
                        groupEnd: assign({}, props, {
                            value: prevGroupEnd
                        })
                    });
                }
                if (disabledDepth < 0) {
                    error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');
                }
            }
        }
        var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher;
        var prefix;
        function describeBuiltInComponentFrame(name, source, ownerFn) {
            {
                if (prefix === undefined) {
                    try {
                        throw Error();
                    } catch (x) {
                        var match = x.stack.trim().match(/\n( *(at )?)/);
                        prefix = match && match[1] || '';
                    }
                }
                return '\n' + prefix + name;
            }
        }
        var reentry = false;
        var componentFrameCache;
        {
            var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;
            componentFrameCache = new PossiblyWeakMap();
        }
        function describeNativeComponentFrame(fn, construct) {
            if (!fn || reentry) {
                return '';
            }
            {
                var frame = componentFrameCache.get(fn);
                if (frame !== undefined) {
                    return frame;
                }
            }
            var control;
            reentry = true;
            var previousPrepareStackTrace = Error.prepareStackTrace;
            Error.prepareStackTrace = undefined;
            var previousDispatcher;
            {
                previousDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = null;
                disableLogs();
            }
            try {
                if (construct) {
                    var Fake = function() {
                        throw Error();
                    };
                    Object.defineProperty(Fake.prototype, 'props', {
                        set: function() {
                            throw Error();
                        }
                    });
                    if (typeof Reflect === 'object' && Reflect.construct) {
                        try {
                            Reflect.construct(Fake, []);
                        } catch (x) {
                            control = x;
                        }
                        Reflect.construct(fn, [], Fake);
                    } else {
                        try {
                            Fake.call();
                        } catch (x) {
                            control = x;
                        }
                        fn.call(Fake.prototype);
                    }
                } else {
                    try {
                        throw Error();
                    } catch (x) {
                        control = x;
                    }
                    fn();
                }
            } catch (sample) {
                if (sample && control && typeof sample.stack === 'string') {
                    var sampleLines = sample.stack.split('\n');
                    var controlLines = control.stack.split('\n');
                    var s = sampleLines.length - 1;
                    var c = controlLines.length - 1;
                    while(s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]){
                        c--;
                    }
                    for(; s >= 1 && c >= 0; s--, c--){
                        if (sampleLines[s] !== controlLines[c]) {
                            if (s !== 1 || c !== 1) {
                                do {
                                    s--;
                                    c--;
                                    if (c < 0 || sampleLines[s] !== controlLines[c]) {
                                        var _frame = '\n' + sampleLines[s].replace(' at new ', ' at ');
                                        if (fn.displayName && _frame.includes('<anonymous>')) {
                                            _frame = _frame.replace('<anonymous>', fn.displayName);
                                        }
                                        {
                                            if (typeof fn === 'function') {
                                                componentFrameCache.set(fn, _frame);
                                            }
                                        }
                                        return _frame;
                                    }
                                }while (s >= 1 && c >= 0)
                            }
                            break;
                        }
                    }
                }
            } finally{
                reentry = false;
                {
                    ReactCurrentDispatcher$1.current = previousDispatcher;
                    reenableLogs();
                }
                Error.prepareStackTrace = previousPrepareStackTrace;
            }
            var name = fn ? fn.displayName || fn.name : '';
            var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';
            {
                if (typeof fn === 'function') {
                    componentFrameCache.set(fn, syntheticFrame);
                }
            }
            return syntheticFrame;
        }
        function describeFunctionComponentFrame(fn, source, ownerFn) {
            {
                return describeNativeComponentFrame(fn, false);
            }
        }
        function shouldConstruct(Component) {
            var prototype = Component.prototype;
            return !!(prototype && prototype.isReactComponent);
        }
        function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
            if (type == null) {
                return '';
            }
            if (typeof type === 'function') {
                {
                    return describeNativeComponentFrame(type, shouldConstruct(type));
                }
            }
            if (typeof type === 'string') {
                return describeBuiltInComponentFrame(type);
            }
            switch(type){
                case REACT_SUSPENSE_TYPE:
                    return describeBuiltInComponentFrame('Suspense');
                case REACT_SUSPENSE_LIST_TYPE:
                    return describeBuiltInComponentFrame('SuspenseList');
            }
            if (typeof type === 'object') {
                switch(type.$$typeof){
                    case REACT_FORWARD_REF_TYPE:
                        return describeFunctionComponentFrame(type.render);
                    case REACT_MEMO_TYPE:
                        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
                    case REACT_LAZY_TYPE:
                        {
                            var lazyComponent = type;
                            var payload = lazyComponent._payload;
                            var init = lazyComponent._init;
                            try {
                                return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
                            } catch (x) {}
                        }
                }
            }
            return '';
        }
        var loggedTypeFailures = {};
        var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
        function setCurrentlyValidatingElement(element) {
            {
                if (element) {
                    var owner = element._owner;
                    var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
                    ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
                } else {
                    ReactDebugCurrentFrame$1.setExtraStackFrame(null);
                }
            }
        }
        function checkPropTypes(typeSpecs, values, location, componentName, element) {
            {
                var has = Function.call.bind(hasOwnProperty);
                for(var typeSpecName in typeSpecs){
                    if (has(typeSpecs, typeSpecName)) {
                        var error$1 = void 0;
                        try {
                            if (typeof typeSpecs[typeSpecName] !== 'function') {
                                var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');
                                err.name = 'Invariant Violation';
                                throw err;
                            }
                            error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');
                        } catch (ex) {
                            error$1 = ex;
                        }
                        if (error$1 && !(error$1 instanceof Error)) {
                            setCurrentlyValidatingElement(element);
                            error('%s: type specification of %s' + ' `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error$1);
                            setCurrentlyValidatingElement(null);
                        }
                        if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                            loggedTypeFailures[error$1.message] = true;
                            setCurrentlyValidatingElement(element);
                            error('Failed %s type: %s', location, error$1.message);
                            setCurrentlyValidatingElement(null);
                        }
                    }
                }
            }
        }
        function setCurrentlyValidatingElement$1(element) {
            {
                if (element) {
                    var owner = element._owner;
                    var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
                    setExtraStackFrame(stack);
                } else {
                    setExtraStackFrame(null);
                }
            }
        }
        var propTypesMisspellWarningShown;
        {
            propTypesMisspellWarningShown = false;
        }
        function getDeclarationErrorAddendum() {
            if (ReactCurrentOwner.current) {
                var name = getComponentNameFromType(ReactCurrentOwner.current.type);
                if (name) {
                    return '\n\nCheck the render method of `' + name + '`.';
                }
            }
            return '';
        }
        function getSourceInfoErrorAddendum(source) {
            if (source !== undefined) {
                var fileName = source.fileName.replace(/^.*[\\\/]/, '');
                var lineNumber = source.lineNumber;
                return '\n\nCheck your code at ' + fileName + ':' + lineNumber + '.';
            }
            return '';
        }
        function getSourceInfoErrorAddendumForProps(elementProps) {
            if (elementProps !== null && elementProps !== undefined) {
                return getSourceInfoErrorAddendum(elementProps.__source);
            }
            return '';
        }
        var ownerHasKeyUseWarning = {};
        function getCurrentComponentErrorInfo(parentType) {
            var info = getDeclarationErrorAddendum();
            if (!info) {
                var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;
                if (parentName) {
                    info = "\n\nCheck the top-level render call using <" + parentName + ">.";
                }
            }
            return info;
        }
        function validateExplicitKey(element, parentType) {
            if (!element._store || element._store.validated || element.key != null) {
                return;
            }
            element._store.validated = true;
            var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
            if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
                return;
            }
            ownerHasKeyUseWarning[currentComponentErrorInfo] = true;
            var childOwner = '';
            if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
                childOwner = " It was passed a child from " + getComponentNameFromType(element._owner.type) + ".";
            }
            {
                setCurrentlyValidatingElement$1(element);
                error('Each child in a list should have a unique "key" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);
                setCurrentlyValidatingElement$1(null);
            }
        }
        function validateChildKeys(node, parentType) {
            if (typeof node !== 'object') {
                return;
            }
            if (isArray(node)) {
                for(var i = 0; i < node.length; i++){
                    var child = node[i];
                    if (isValidElement(child)) {
                        validateExplicitKey(child, parentType);
                    }
                }
            } else if (isValidElement(node)) {
                if (node._store) {
                    node._store.validated = true;
                }
            } else if (node) {
                var iteratorFn = getIteratorFn(node);
                if (typeof iteratorFn === 'function') {
                    if (iteratorFn !== node.entries) {
                        var iterator = iteratorFn.call(node);
                        var step;
                        while(!(step = iterator.next()).done){
                            if (isValidElement(step.value)) {
                                validateExplicitKey(step.value, parentType);
                            }
                        }
                    }
                }
            }
        }
        function validatePropTypes(element) {
            {
                var type = element.type;
                if (type === null || type === undefined || typeof type === 'string') {
                    return;
                }
                var propTypes;
                if (typeof type === 'function') {
                    propTypes = type.propTypes;
                } else if (typeof type === 'object' && (type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_MEMO_TYPE)) {
                    propTypes = type.propTypes;
                } else {
                    return;
                }
                if (propTypes) {
                    var name = getComponentNameFromType(type);
                    checkPropTypes(propTypes, element.props, 'prop', name, element);
                } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {
                    propTypesMisspellWarningShown = true;
                    var _name = getComponentNameFromType(type);
                    error('Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', _name || 'Unknown');
                }
                if (typeof type.getDefaultProps === 'function' && !type.getDefaultProps.isReactClassApproved) {
                    error('getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');
                }
            }
        }
        function validateFragmentProps(fragment) {
            {
                var keys = Object.keys(fragment.props);
                for(var i = 0; i < keys.length; i++){
                    var key = keys[i];
                    if (key !== 'children' && key !== 'key') {
                        setCurrentlyValidatingElement$1(fragment);
                        error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);
                        setCurrentlyValidatingElement$1(null);
                        break;
                    }
                }
                if (fragment.ref !== null) {
                    setCurrentlyValidatingElement$1(fragment);
                    error('Invalid attribute `ref` supplied to `React.Fragment`.');
                    setCurrentlyValidatingElement$1(null);
                }
            }
        }
        function createElementWithValidation(type, props, children) {
            var validType = isValidElementType(type);
            if (!validType) {
                var info = '';
                if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {
                    info += ' You likely forgot to export your component from the file ' + "it's defined in, or you might have mixed up default and named imports.";
                }
                var sourceInfo = getSourceInfoErrorAddendumForProps(props);
                if (sourceInfo) {
                    info += sourceInfo;
                } else {
                    info += getDeclarationErrorAddendum();
                }
                var typeString;
                if (type === null) {
                    typeString = 'null';
                } else if (isArray(type)) {
                    typeString = 'array';
                } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {
                    typeString = "<" + (getComponentNameFromType(type.type) || 'Unknown') + " />";
                    info = ' Did you accidentally export a JSX literal instead of a component?';
                } else {
                    typeString = typeof type;
                }
                {
                    error('React.createElement: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);
                }
            }
            var element = createElement.apply(this, arguments);
            if (element == null) {
                return element;
            }
            if (validType) {
                for(var i = 2; i < arguments.length; i++){
                    validateChildKeys(arguments[i], type);
                }
            }
            if (type === REACT_FRAGMENT_TYPE) {
                validateFragmentProps(element);
            } else {
                validatePropTypes(element);
            }
            return element;
        }
        function cloneElementWithValidation(element, props, children) {
            var newElement = cloneElement.apply(this, arguments);
            for(var i = 2; i < arguments.length; i++){
                validateChildKeys(arguments[i], newElement.type);
            }
            validatePropTypes(newElement);
            return newElement;
        }
        var ContextRegistry$1 = ReactSharedInternals.ContextRegistry;
        function createServerContext(globalName, defaultValue) {
            var wasDefined = true;
            if (!ContextRegistry$1[globalName]) {
                wasDefined = false;
                var _context = {
                    $$typeof: REACT_SERVER_CONTEXT_TYPE,
                    _currentValue: defaultValue,
                    _currentValue2: defaultValue,
                    _defaultValue: defaultValue,
                    _threadCount: 0,
                    Provider: null,
                    Consumer: null,
                    _globalName: globalName
                };
                _context.Provider = {
                    $$typeof: REACT_PROVIDER_TYPE,
                    _context: _context
                };
                {
                    var hasWarnedAboutUsingConsumer;
                    _context._currentRenderer = null;
                    _context._currentRenderer2 = null;
                    Object.defineProperties(_context, {
                        Consumer: {
                            get: function() {
                                if (!hasWarnedAboutUsingConsumer) {
                                    error('Consumer pattern is not supported by ReactServerContext');
                                    hasWarnedAboutUsingConsumer = true;
                                }
                                return null;
                            }
                        }
                    });
                }
                ContextRegistry$1[globalName] = _context;
            }
            var context = ContextRegistry$1[globalName];
            if (context._defaultValue === REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED) {
                context._defaultValue = defaultValue;
                if (context._currentValue === REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED) {
                    context._currentValue = defaultValue;
                }
                if (context._currentValue2 === REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED) {
                    context._currentValue2 = defaultValue;
                }
            } else if (wasDefined) {
                throw new Error("ServerContext: " + globalName + " already defined");
            }
            return context;
        }
        function startTransition(scope, options) {
            var prevTransition = ReactCurrentBatchConfig.transition;
            ReactCurrentBatchConfig.transition = {};
            var currentTransition = ReactCurrentBatchConfig.transition;
            {
                ReactCurrentBatchConfig.transition._updatedFibers = new Set();
            }
            try {
                scope();
            } finally{
                ReactCurrentBatchConfig.transition = prevTransition;
                {
                    if (prevTransition === null && currentTransition._updatedFibers) {
                        var updatedFibersCount = currentTransition._updatedFibers.size;
                        if (updatedFibersCount > 10) {
                            warn('Detected a large number of updates inside startTransition. ' + 'If this is due to a subscription please re-write it to use React provided hooks. ' + 'Otherwise concurrent mode guarantees are off the table.');
                        }
                        currentTransition._updatedFibers.clear();
                    }
                }
            }
        }
        var createElement$1 = createElementWithValidation;
        var cloneElement$1 = cloneElementWithValidation;
        var Children = {
            map: mapChildren,
            forEach: forEachChildren,
            count: countChildren,
            toArray: toArray,
            only: onlyChild
        };
        exports.Children = Children;
        exports.Fragment = REACT_FRAGMENT_TYPE;
        exports.Profiler = REACT_PROFILER_TYPE;
        exports.StrictMode = REACT_STRICT_MODE_TYPE;
        exports.Suspense = REACT_SUSPENSE_TYPE;
        exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactSharedInternals;
        exports.cache = cache;
        exports.cloneElement = cloneElement$1;
        exports.createElement = createElement$1;
        exports.createRef = createRef;
        exports.createServerContext = createServerContext;
        exports.forwardRef = forwardRef;
        exports.isValidElement = isValidElement;
        exports.lazy = lazy;
        exports.memo = memo;
        exports.startTransition = startTransition;
        exports.use = use;
        exports.useCallback = useCallback;
        exports.useContext = useContext;
        exports.useDebugValue = useDebugValue;
        exports.useId = useId;
        exports.useMemo = useMemo;
        exports.version = ReactVersion;
    })();
}

}.call(this) }),
"[project-with-next]/node_modules/next/dist/compiled/react/jsx-runtime.js (ecmascript, rsc)": (function({ r: __turbopack_require__, x: __turbopack_external_require__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, c: __turbopack_cache__, l: __turbopack_load__, p: process, __dirname, m: module, e: exports }) { !function() {

'use strict';
if (process.env.NODE_ENV === 'production') {
    module.exports = __turbopack_require__("[project-with-next]/node_modules/next/dist/compiled/react/cjs/react-jsx-runtime.production.min.js (ecmascript, rsc)");
} else {
    module.exports = __turbopack_require__("[project-with-next]/node_modules/next/dist/compiled/react/cjs/react-jsx-runtime.development.js (ecmascript, rsc)");
}

}.call(this) }),
"[project-with-next]/node_modules/next/dist/compiled/react/cjs/react-jsx-runtime.production.min.js (ecmascript, rsc)": (function({ r: __turbopack_require__, x: __turbopack_external_require__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, c: __turbopack_cache__, l: __turbopack_load__, p: process, __dirname, m: module, e: exports }) { !function() {

'use strict';
var f = __turbopack_require__("[project-with-next]/node_modules/next/dist/compiled/react/react.shared-subset.js (ecmascript, rsc)"), k = Symbol.for("react.element"), l = Symbol.for("react.fragment"), m = Object.prototype.hasOwnProperty, n = f.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, p = {
    key: !0,
    ref: !0,
    __self: !0,
    __source: !0
};
function q(c, a, g) {
    var b, d = {}, e = null, h = null;
    void 0 !== g && (e = "" + g);
    void 0 !== a.key && (e = "" + a.key);
    void 0 !== a.ref && (h = a.ref);
    for(b in a)m.call(a, b) && !p.hasOwnProperty(b) && (d[b] = a[b]);
    if (c && c.defaultProps) for(b in a = c.defaultProps, a)void 0 === d[b] && (d[b] = a[b]);
    return {
        $$typeof: k,
        type: c,
        key: e,
        ref: h,
        props: d,
        _owner: n.current
    };
}
exports.Fragment = l;
exports.jsx = q;
exports.jsxs = q;

}.call(this) }),
"[project-with-next]/node_modules/next/dist/compiled/react/cjs/react-jsx-runtime.development.js (ecmascript, rsc)": (function({ r: __turbopack_require__, x: __turbopack_external_require__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, c: __turbopack_cache__, l: __turbopack_load__, p: process, __dirname, m: module, e: exports }) { !function() {

'use strict';
if (process.env.NODE_ENV !== "production") {
    (function() {
        'use strict';
        var React = __turbopack_require__("[project-with-next]/node_modules/next/dist/compiled/react/react.shared-subset.js (ecmascript, rsc)");
        var REACT_ELEMENT_TYPE = Symbol.for('react.element');
        var REACT_PORTAL_TYPE = Symbol.for('react.portal');
        var REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');
        var REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode');
        var REACT_PROFILER_TYPE = Symbol.for('react.profiler');
        var REACT_PROVIDER_TYPE = Symbol.for('react.provider');
        var REACT_CONTEXT_TYPE = Symbol.for('react.context');
        var REACT_SERVER_CONTEXT_TYPE = Symbol.for('react.server_context');
        var REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');
        var REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');
        var REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');
        var REACT_MEMO_TYPE = Symbol.for('react.memo');
        var REACT_LAZY_TYPE = Symbol.for('react.lazy');
        var REACT_OFFSCREEN_TYPE = Symbol.for('react.offscreen');
        var REACT_CACHE_TYPE = Symbol.for('react.cache');
        var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
        var FAUX_ITERATOR_SYMBOL = '@@iterator';
        function getIteratorFn(maybeIterable) {
            if (maybeIterable === null || typeof maybeIterable !== 'object') {
                return null;
            }
            var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
            if (typeof maybeIterator === 'function') {
                return maybeIterator;
            }
            return null;
        }
        var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
        function error(format) {
            {
                {
                    for(var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++){
                        args[_key2 - 1] = arguments[_key2];
                    }
                    printWarning('error', format, args);
                }
            }
        }
        function printWarning(level, format, args) {
            {
                var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
                var stack = ReactDebugCurrentFrame.getStackAddendum();
                if (stack !== '') {
                    format += '%s';
                    args = args.concat([
                        stack
                    ]);
                }
                var argsWithFormat = args.map(function(item) {
                    return String(item);
                });
                argsWithFormat.unshift('Warning: ' + format);
                Function.prototype.apply.call(console[level], console, argsWithFormat);
            }
        }
        var enableScopeAPI = false;
        var enableCacheElement = false;
        var enableTransitionTracing = false;
        var enableLegacyHidden = false;
        var enableDebugTracing = false;
        var REACT_MODULE_REFERENCE = Symbol.for('react.module.reference');
        function isValidElementType(type) {
            if (typeof type === 'string' || typeof type === 'function') {
                return true;
            }
            if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {
                return true;
            }
            if (typeof type === 'object' && type !== null) {
                if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== undefined) {
                    return true;
                }
            }
            return false;
        }
        function getWrappedName(outerType, innerType, wrapperName) {
            var displayName = outerType.displayName;
            if (displayName) {
                return displayName;
            }
            var functionName = innerType.displayName || innerType.name || '';
            return functionName !== '' ? wrapperName + "(" + functionName + ")" : wrapperName;
        }
        function getContextName(type) {
            return type.displayName || 'Context';
        }
        function getComponentNameFromType(type) {
            if (type == null) {
                return null;
            }
            {
                if (typeof type.tag === 'number') {
                    error('Received an unexpected object in getComponentNameFromType(). ' + 'This is likely a bug in React. Please file an issue.');
                }
            }
            if (typeof type === 'function') {
                return type.displayName || type.name || null;
            }
            if (typeof type === 'string') {
                return type;
            }
            switch(type){
                case REACT_FRAGMENT_TYPE:
                    return 'Fragment';
                case REACT_PORTAL_TYPE:
                    return 'Portal';
                case REACT_PROFILER_TYPE:
                    return 'Profiler';
                case REACT_STRICT_MODE_TYPE:
                    return 'StrictMode';
                case REACT_SUSPENSE_TYPE:
                    return 'Suspense';
                case REACT_SUSPENSE_LIST_TYPE:
                    return 'SuspenseList';
                case REACT_CACHE_TYPE:
                    {
                        return 'Cache';
                    }
            }
            if (typeof type === 'object') {
                switch(type.$$typeof){
                    case REACT_CONTEXT_TYPE:
                        var context = type;
                        return getContextName(context) + '.Consumer';
                    case REACT_PROVIDER_TYPE:
                        var provider = type;
                        return getContextName(provider._context) + '.Provider';
                    case REACT_FORWARD_REF_TYPE:
                        return getWrappedName(type, type.render, 'ForwardRef');
                    case REACT_MEMO_TYPE:
                        var outerName = type.displayName || null;
                        if (outerName !== null) {
                            return outerName;
                        }
                        return getComponentNameFromType(type.type) || 'Memo';
                    case REACT_LAZY_TYPE:
                        {
                            var lazyComponent = type;
                            var payload = lazyComponent._payload;
                            var init = lazyComponent._init;
                            try {
                                return getComponentNameFromType(init(payload));
                            } catch (x) {
                                return null;
                            }
                        }
                    case REACT_SERVER_CONTEXT_TYPE:
                        {
                            var context2 = type;
                            return (context2.displayName || context2._globalName) + '.Provider';
                        }
                }
            }
            return null;
        }
        var assign = Object.assign;
        var disabledDepth = 0;
        var prevLog;
        var prevInfo;
        var prevWarn;
        var prevError;
        var prevGroup;
        var prevGroupCollapsed;
        var prevGroupEnd;
        function disabledLog() {}
        disabledLog.__reactDisabledLog = true;
        function disableLogs() {
            {
                if (disabledDepth === 0) {
                    prevLog = console.log;
                    prevInfo = console.info;
                    prevWarn = console.warn;
                    prevError = console.error;
                    prevGroup = console.group;
                    prevGroupCollapsed = console.groupCollapsed;
                    prevGroupEnd = console.groupEnd;
                    var props = {
                        configurable: true,
                        enumerable: true,
                        value: disabledLog,
                        writable: true
                    };
                    Object.defineProperties(console, {
                        info: props,
                        log: props,
                        warn: props,
                        error: props,
                        group: props,
                        groupCollapsed: props,
                        groupEnd: props
                    });
                }
                disabledDepth++;
            }
        }
        function reenableLogs() {
            {
                disabledDepth--;
                if (disabledDepth === 0) {
                    var props = {
                        configurable: true,
                        enumerable: true,
                        writable: true
                    };
                    Object.defineProperties(console, {
                        log: assign({}, props, {
                            value: prevLog
                        }),
                        info: assign({}, props, {
                            value: prevInfo
                        }),
                        warn: assign({}, props, {
                            value: prevWarn
                        }),
                        error: assign({}, props, {
                            value: prevError
                        }),
                        group: assign({}, props, {
                            value: prevGroup
                        }),
                        groupCollapsed: assign({}, props, {
                            value: prevGroupCollapsed
                        }),
                        groupEnd: assign({}, props, {
                            value: prevGroupEnd
                        })
                    });
                }
                if (disabledDepth < 0) {
                    error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');
                }
            }
        }
        var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
        var prefix;
        function describeBuiltInComponentFrame(name, source, ownerFn) {
            {
                if (prefix === undefined) {
                    try {
                        throw Error();
                    } catch (x) {
                        var match = x.stack.trim().match(/\n( *(at )?)/);
                        prefix = match && match[1] || '';
                    }
                }
                return '\n' + prefix + name;
            }
        }
        var reentry = false;
        var componentFrameCache;
        {
            var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;
            componentFrameCache = new PossiblyWeakMap();
        }
        function describeNativeComponentFrame(fn, construct) {
            if (!fn || reentry) {
                return '';
            }
            {
                var frame = componentFrameCache.get(fn);
                if (frame !== undefined) {
                    return frame;
                }
            }
            var control;
            reentry = true;
            var previousPrepareStackTrace = Error.prepareStackTrace;
            Error.prepareStackTrace = undefined;
            var previousDispatcher;
            {
                previousDispatcher = ReactCurrentDispatcher.current;
                ReactCurrentDispatcher.current = null;
                disableLogs();
            }
            try {
                if (construct) {
                    var Fake = function() {
                        throw Error();
                    };
                    Object.defineProperty(Fake.prototype, 'props', {
                        set: function() {
                            throw Error();
                        }
                    });
                    if (typeof Reflect === 'object' && Reflect.construct) {
                        try {
                            Reflect.construct(Fake, []);
                        } catch (x) {
                            control = x;
                        }
                        Reflect.construct(fn, [], Fake);
                    } else {
                        try {
                            Fake.call();
                        } catch (x) {
                            control = x;
                        }
                        fn.call(Fake.prototype);
                    }
                } else {
                    try {
                        throw Error();
                    } catch (x) {
                        control = x;
                    }
                    fn();
                }
            } catch (sample) {
                if (sample && control && typeof sample.stack === 'string') {
                    var sampleLines = sample.stack.split('\n');
                    var controlLines = control.stack.split('\n');
                    var s = sampleLines.length - 1;
                    var c = controlLines.length - 1;
                    while(s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]){
                        c--;
                    }
                    for(; s >= 1 && c >= 0; s--, c--){
                        if (sampleLines[s] !== controlLines[c]) {
                            if (s !== 1 || c !== 1) {
                                do {
                                    s--;
                                    c--;
                                    if (c < 0 || sampleLines[s] !== controlLines[c]) {
                                        var _frame = '\n' + sampleLines[s].replace(' at new ', ' at ');
                                        if (fn.displayName && _frame.includes('<anonymous>')) {
                                            _frame = _frame.replace('<anonymous>', fn.displayName);
                                        }
                                        {
                                            if (typeof fn === 'function') {
                                                componentFrameCache.set(fn, _frame);
                                            }
                                        }
                                        return _frame;
                                    }
                                }while (s >= 1 && c >= 0)
                            }
                            break;
                        }
                    }
                }
            } finally{
                reentry = false;
                {
                    ReactCurrentDispatcher.current = previousDispatcher;
                    reenableLogs();
                }
                Error.prepareStackTrace = previousPrepareStackTrace;
            }
            var name = fn ? fn.displayName || fn.name : '';
            var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';
            {
                if (typeof fn === 'function') {
                    componentFrameCache.set(fn, syntheticFrame);
                }
            }
            return syntheticFrame;
        }
        function describeFunctionComponentFrame(fn, source, ownerFn) {
            {
                return describeNativeComponentFrame(fn, false);
            }
        }
        function shouldConstruct(Component) {
            var prototype = Component.prototype;
            return !!(prototype && prototype.isReactComponent);
        }
        function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
            if (type == null) {
                return '';
            }
            if (typeof type === 'function') {
                {
                    return describeNativeComponentFrame(type, shouldConstruct(type));
                }
            }
            if (typeof type === 'string') {
                return describeBuiltInComponentFrame(type);
            }
            switch(type){
                case REACT_SUSPENSE_TYPE:
                    return describeBuiltInComponentFrame('Suspense');
                case REACT_SUSPENSE_LIST_TYPE:
                    return describeBuiltInComponentFrame('SuspenseList');
            }
            if (typeof type === 'object') {
                switch(type.$$typeof){
                    case REACT_FORWARD_REF_TYPE:
                        return describeFunctionComponentFrame(type.render);
                    case REACT_MEMO_TYPE:
                        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
                    case REACT_LAZY_TYPE:
                        {
                            var lazyComponent = type;
                            var payload = lazyComponent._payload;
                            var init = lazyComponent._init;
                            try {
                                return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
                            } catch (x) {}
                        }
                }
            }
            return '';
        }
        var hasOwnProperty = Object.prototype.hasOwnProperty;
        var loggedTypeFailures = {};
        var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
        function setCurrentlyValidatingElement(element) {
            {
                if (element) {
                    var owner = element._owner;
                    var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
                    ReactDebugCurrentFrame.setExtraStackFrame(stack);
                } else {
                    ReactDebugCurrentFrame.setExtraStackFrame(null);
                }
            }
        }
        function checkPropTypes(typeSpecs, values, location, componentName, element) {
            {
                var has = Function.call.bind(hasOwnProperty);
                for(var typeSpecName in typeSpecs){
                    if (has(typeSpecs, typeSpecName)) {
                        var error$1 = void 0;
                        try {
                            if (typeof typeSpecs[typeSpecName] !== 'function') {
                                var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');
                                err.name = 'Invariant Violation';
                                throw err;
                            }
                            error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');
                        } catch (ex) {
                            error$1 = ex;
                        }
                        if (error$1 && !(error$1 instanceof Error)) {
                            setCurrentlyValidatingElement(element);
                            error('%s: type specification of %s' + ' `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error$1);
                            setCurrentlyValidatingElement(null);
                        }
                        if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                            loggedTypeFailures[error$1.message] = true;
                            setCurrentlyValidatingElement(element);
                            error('Failed %s type: %s', location, error$1.message);
                            setCurrentlyValidatingElement(null);
                        }
                    }
                }
            }
        }
        var isArrayImpl = Array.isArray;
        function isArray(a) {
            return isArrayImpl(a);
        }
        function typeName(value) {
            {
                var hasToStringTag = typeof Symbol === 'function' && Symbol.toStringTag;
                var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || 'Object';
                return type;
            }
        }
        function willCoercionThrow(value) {
            {
                try {
                    testStringCoercion(value);
                    return false;
                } catch (e) {
                    return true;
                }
            }
        }
        function testStringCoercion(value) {
            return '' + value;
        }
        function checkKeyStringCoercion(value) {
            {
                if (willCoercionThrow(value)) {
                    error('The provided key is an unsupported type %s.' + ' This value must be coerced to a string before before using it here.', typeName(value));
                    return testStringCoercion(value);
                }
            }
        }
        var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;
        var RESERVED_PROPS = {
            key: true,
            ref: true,
            __self: true,
            __source: true
        };
        var specialPropKeyWarningShown;
        var specialPropRefWarningShown;
        var didWarnAboutStringRefs;
        {
            didWarnAboutStringRefs = {};
        }
        function hasValidRef(config) {
            {
                if (hasOwnProperty.call(config, 'ref')) {
                    var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;
                    if (getter && getter.isReactWarning) {
                        return false;
                    }
                }
            }
            return config.ref !== undefined;
        }
        function hasValidKey(config) {
            {
                if (hasOwnProperty.call(config, 'key')) {
                    var getter = Object.getOwnPropertyDescriptor(config, 'key').get;
                    if (getter && getter.isReactWarning) {
                        return false;
                    }
                }
            }
            return config.key !== undefined;
        }
        function warnIfStringRefCannotBeAutoConverted(config, self) {
            {
                if (typeof config.ref === 'string' && ReactCurrentOwner.current && self && ReactCurrentOwner.current.stateNode !== self) {
                    var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);
                    if (!didWarnAboutStringRefs[componentName]) {
                        error('Component "%s" contains the string ref "%s". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', getComponentNameFromType(ReactCurrentOwner.current.type), config.ref);
                        didWarnAboutStringRefs[componentName] = true;
                    }
                }
            }
        }
        function defineKeyPropWarningGetter(props, displayName) {
            {
                var warnAboutAccessingKey = function() {
                    if (!specialPropKeyWarningShown) {
                        specialPropKeyWarningShown = true;
                        error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);
                    }
                };
                warnAboutAccessingKey.isReactWarning = true;
                Object.defineProperty(props, 'key', {
                    get: warnAboutAccessingKey,
                    configurable: true
                });
            }
        }
        function defineRefPropWarningGetter(props, displayName) {
            {
                var warnAboutAccessingRef = function() {
                    if (!specialPropRefWarningShown) {
                        specialPropRefWarningShown = true;
                        error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);
                    }
                };
                warnAboutAccessingRef.isReactWarning = true;
                Object.defineProperty(props, 'ref', {
                    get: warnAboutAccessingRef,
                    configurable: true
                });
            }
        }
        var ReactElement = function(type, key, ref, self, source, owner, props) {
            var element = {
                $$typeof: REACT_ELEMENT_TYPE,
                type: type,
                key: key,
                ref: ref,
                props: props,
                _owner: owner
            };
            {
                element._store = {};
                Object.defineProperty(element._store, 'validated', {
                    configurable: false,
                    enumerable: false,
                    writable: true,
                    value: false
                });
                Object.defineProperty(element, '_self', {
                    configurable: false,
                    enumerable: false,
                    writable: false,
                    value: self
                });
                Object.defineProperty(element, '_source', {
                    configurable: false,
                    enumerable: false,
                    writable: false,
                    value: source
                });
                if (Object.freeze) {
                    Object.freeze(element.props);
                    Object.freeze(element);
                }
            }
            return element;
        };
        function jsxDEV(type, config, maybeKey, source, self) {
            {
                var propName;
                var props = {};
                var key = null;
                var ref = null;
                if (maybeKey !== undefined) {
                    {
                        checkKeyStringCoercion(maybeKey);
                    }
                    key = '' + maybeKey;
                }
                if (hasValidKey(config)) {
                    {
                        checkKeyStringCoercion(config.key);
                    }
                    key = '' + config.key;
                }
                if (hasValidRef(config)) {
                    ref = config.ref;
                    warnIfStringRefCannotBeAutoConverted(config, self);
                }
                for(propName in config){
                    if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
                        props[propName] = config[propName];
                    }
                }
                if (type && type.defaultProps) {
                    var defaultProps = type.defaultProps;
                    for(propName in defaultProps){
                        if (props[propName] === undefined) {
                            props[propName] = defaultProps[propName];
                        }
                    }
                }
                if (key || ref) {
                    var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;
                    if (key) {
                        defineKeyPropWarningGetter(props, displayName);
                    }
                    if (ref) {
                        defineRefPropWarningGetter(props, displayName);
                    }
                }
                return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
            }
        }
        var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;
        var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
        function setCurrentlyValidatingElement$1(element) {
            {
                if (element) {
                    var owner = element._owner;
                    var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
                    ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
                } else {
                    ReactDebugCurrentFrame$1.setExtraStackFrame(null);
                }
            }
        }
        var propTypesMisspellWarningShown;
        {
            propTypesMisspellWarningShown = false;
        }
        function isValidElement(object) {
            {
                return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
            }
        }
        function getDeclarationErrorAddendum() {
            {
                if (ReactCurrentOwner$1.current) {
                    var name = getComponentNameFromType(ReactCurrentOwner$1.current.type);
                    if (name) {
                        return '\n\nCheck the render method of `' + name + '`.';
                    }
                }
                return '';
            }
        }
        function getSourceInfoErrorAddendum(source) {
            {
                if (source !== undefined) {
                    var fileName = source.fileName.replace(/^.*[\\\/]/, '');
                    var lineNumber = source.lineNumber;
                    return '\n\nCheck your code at ' + fileName + ':' + lineNumber + '.';
                }
                return '';
            }
        }
        var ownerHasKeyUseWarning = {};
        function getCurrentComponentErrorInfo(parentType) {
            {
                var info = getDeclarationErrorAddendum();
                if (!info) {
                    var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;
                    if (parentName) {
                        info = "\n\nCheck the top-level render call using <" + parentName + ">.";
                    }
                }
                return info;
            }
        }
        function validateExplicitKey(element, parentType) {
            {
                if (!element._store || element._store.validated || element.key != null) {
                    return;
                }
                element._store.validated = true;
                var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
                if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
                    return;
                }
                ownerHasKeyUseWarning[currentComponentErrorInfo] = true;
                var childOwner = '';
                if (element && element._owner && element._owner !== ReactCurrentOwner$1.current) {
                    childOwner = " It was passed a child from " + getComponentNameFromType(element._owner.type) + ".";
                }
                setCurrentlyValidatingElement$1(element);
                error('Each child in a list should have a unique "key" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);
                setCurrentlyValidatingElement$1(null);
            }
        }
        function validateChildKeys(node, parentType) {
            {
                if (typeof node !== 'object') {
                    return;
                }
                if (isArray(node)) {
                    for(var i = 0; i < node.length; i++){
                        var child = node[i];
                        if (isValidElement(child)) {
                            validateExplicitKey(child, parentType);
                        }
                    }
                } else if (isValidElement(node)) {
                    if (node._store) {
                        node._store.validated = true;
                    }
                } else if (node) {
                    var iteratorFn = getIteratorFn(node);
                    if (typeof iteratorFn === 'function') {
                        if (iteratorFn !== node.entries) {
                            var iterator = iteratorFn.call(node);
                            var step;
                            while(!(step = iterator.next()).done){
                                if (isValidElement(step.value)) {
                                    validateExplicitKey(step.value, parentType);
                                }
                            }
                        }
                    }
                }
            }
        }
        function validatePropTypes(element) {
            {
                var type = element.type;
                if (type === null || type === undefined || typeof type === 'string') {
                    return;
                }
                var propTypes;
                if (typeof type === 'function') {
                    propTypes = type.propTypes;
                } else if (typeof type === 'object' && (type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_MEMO_TYPE)) {
                    propTypes = type.propTypes;
                } else {
                    return;
                }
                if (propTypes) {
                    var name = getComponentNameFromType(type);
                    checkPropTypes(propTypes, element.props, 'prop', name, element);
                } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {
                    propTypesMisspellWarningShown = true;
                    var _name = getComponentNameFromType(type);
                    error('Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', _name || 'Unknown');
                }
                if (typeof type.getDefaultProps === 'function' && !type.getDefaultProps.isReactClassApproved) {
                    error('getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');
                }
            }
        }
        function validateFragmentProps(fragment) {
            {
                var keys = Object.keys(fragment.props);
                for(var i = 0; i < keys.length; i++){
                    var key = keys[i];
                    if (key !== 'children' && key !== 'key') {
                        setCurrentlyValidatingElement$1(fragment);
                        error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);
                        setCurrentlyValidatingElement$1(null);
                        break;
                    }
                }
                if (fragment.ref !== null) {
                    setCurrentlyValidatingElement$1(fragment);
                    error('Invalid attribute `ref` supplied to `React.Fragment`.');
                    setCurrentlyValidatingElement$1(null);
                }
            }
        }
        function jsxWithValidation(type, props, key, isStaticChildren, source, self) {
            {
                var validType = isValidElementType(type);
                if (!validType) {
                    var info = '';
                    if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {
                        info += ' You likely forgot to export your component from the file ' + "it's defined in, or you might have mixed up default and named imports.";
                    }
                    var sourceInfo = getSourceInfoErrorAddendum(source);
                    if (sourceInfo) {
                        info += sourceInfo;
                    } else {
                        info += getDeclarationErrorAddendum();
                    }
                    var typeString;
                    if (type === null) {
                        typeString = 'null';
                    } else if (isArray(type)) {
                        typeString = 'array';
                    } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {
                        typeString = "<" + (getComponentNameFromType(type.type) || 'Unknown') + " />";
                        info = ' Did you accidentally export a JSX literal instead of a component?';
                    } else {
                        typeString = typeof type;
                    }
                    error('React.jsx: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);
                }
                var element = jsxDEV(type, props, key, source, self);
                if (element == null) {
                    return element;
                }
                if (validType) {
                    var children = props.children;
                    if (children !== undefined) {
                        if (isStaticChildren) {
                            if (isArray(children)) {
                                for(var i = 0; i < children.length; i++){
                                    validateChildKeys(children[i], type);
                                }
                                if (Object.freeze) {
                                    Object.freeze(children);
                                }
                            } else {
                                error('React.jsx: Static children should always be an array. ' + 'You are likely explicitly calling React.jsxs or React.jsxDEV. ' + 'Use the Babel transform instead.');
                            }
                        } else {
                            validateChildKeys(children, type);
                        }
                    }
                }
                if (type === REACT_FRAGMENT_TYPE) {
                    validateFragmentProps(element);
                } else {
                    validatePropTypes(element);
                }
                return element;
            }
        }
        function jsxWithValidationStatic(type, props, key) {
            {
                return jsxWithValidation(type, props, key, true);
            }
        }
        function jsxWithValidationDynamic(type, props, key) {
            {
                return jsxWithValidation(type, props, key, false);
            }
        }
        var jsx = jsxWithValidationDynamic;
        var jsxs = jsxWithValidationStatic;
        exports.Fragment = REACT_FRAGMENT_TYPE;
        exports.jsx = jsx;
        exports.jsxs = jsxs;
    })();
}

}.call(this) }),
"[project-with-next]/node_modules/next/dist/compiled/react-server-dom-webpack/server.browser.js (ecmascript, rsc)": (function({ r: __turbopack_require__, x: __turbopack_external_require__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, c: __turbopack_cache__, l: __turbopack_load__, p: process, __dirname, m: module, e: exports }) { !function() {

(()=>{
    "use strict";
    var __webpack_modules__ = {
        915: (__unused_webpack_module, exports, __nccwpck_require__)=>{
            if (process.env.NODE_ENV !== "production") {
                (function() {
                    'use strict';
                    var React = __nccwpck_require__(522);
                    var ReactDOM = __nccwpck_require__(255);
                    var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
                    function error(format) {
                        {
                            {
                                for(var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++){
                                    args[_key2 - 1] = arguments[_key2];
                                }
                                printWarning('error', format, args);
                            }
                        }
                    }
                    function printWarning(level, format, args) {
                        {
                            var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
                            var stack = ReactDebugCurrentFrame.getStackAddendum();
                            if (stack !== '') {
                                format += '%s';
                                args = args.concat([
                                    stack
                                ]);
                            }
                            var argsWithFormat = args.map(function(item) {
                                return String(item);
                            });
                            argsWithFormat.unshift('Warning: ' + format);
                            Function.prototype.apply.call(console[level], console, argsWithFormat);
                        }
                    }
                    function scheduleWork(callback) {
                        callback();
                    }
                    var supportsRequestStorage = typeof AsyncLocalStorage === 'function';
                    var requestStorage = supportsRequestStorage ? new AsyncLocalStorage() : null;
                    var VIEW_SIZE = 512;
                    var currentView = null;
                    var writtenBytes = 0;
                    function beginWriting(destination) {
                        currentView = new Uint8Array(VIEW_SIZE);
                        writtenBytes = 0;
                    }
                    function writeChunk(destination, chunk) {
                        if (chunk.length === 0) {
                            return;
                        }
                        if (chunk.length > VIEW_SIZE) {
                            if (writtenBytes > 0) {
                                destination.enqueue(new Uint8Array(currentView.buffer, 0, writtenBytes));
                                currentView = new Uint8Array(VIEW_SIZE);
                                writtenBytes = 0;
                            }
                            destination.enqueue(chunk);
                            return;
                        }
                        var bytesToWrite = chunk;
                        var allowableBytes = currentView.length - writtenBytes;
                        if (allowableBytes < bytesToWrite.length) {
                            if (allowableBytes === 0) {
                                destination.enqueue(currentView);
                            } else {
                                currentView.set(bytesToWrite.subarray(0, allowableBytes), writtenBytes);
                                destination.enqueue(currentView);
                                bytesToWrite = bytesToWrite.subarray(allowableBytes);
                            }
                            currentView = new Uint8Array(VIEW_SIZE);
                            writtenBytes = 0;
                        }
                        currentView.set(bytesToWrite, writtenBytes);
                        writtenBytes += bytesToWrite.length;
                    }
                    function writeChunkAndReturn(destination, chunk) {
                        writeChunk(destination, chunk);
                        return true;
                    }
                    function completeWriting(destination) {
                        if (currentView && writtenBytes > 0) {
                            destination.enqueue(new Uint8Array(currentView.buffer, 0, writtenBytes));
                            currentView = null;
                            writtenBytes = 0;
                        }
                    }
                    function close(destination) {
                        destination.close();
                    }
                    var textEncoder = new TextEncoder();
                    function stringToChunk(content) {
                        return textEncoder.encode(content);
                    }
                    function stringToPrecomputedChunk(content) {
                        return textEncoder.encode(content);
                    }
                    function closeWithError(destination, error) {
                        if (typeof destination.error === 'function') {
                            destination.error(error);
                        } else {
                            destination.close();
                        }
                    }
                    var stringify = JSON.stringify;
                    function serializeRowHeader(tag, id) {
                        return tag + id.toString(16) + ':';
                    }
                    function processErrorChunkProd(request, id, digest) {
                        {
                            throw new Error('processErrorChunkProd should never be called while in development mode. Use processErrorChunkDev instead. This is a bug in React.');
                        }
                        var errorInfo = {
                            digest: digest
                        };
                        var row = serializeRowHeader('E', id) + stringify(errorInfo) + '\n';
                    }
                    function processErrorChunkDev(request, id, digest, message, stack) {
                        var errorInfo = {
                            digest: digest,
                            message: message,
                            stack: stack
                        };
                        var row = serializeRowHeader('E', id) + stringify(errorInfo) + '\n';
                        return stringToChunk(row);
                    }
                    function processModelChunk(request, id, model) {
                        var json = stringify(model, request.toJSON);
                        var row = serializeRowHeader('J', id) + json + '\n';
                        return stringToChunk(row);
                    }
                    function processReferenceChunk(request, id, reference) {
                        var json = stringify(reference);
                        var row = serializeRowHeader('J', id) + json + '\n';
                        return stringToChunk(row);
                    }
                    function processModuleChunk(request, id, moduleMetaData) {
                        var json = stringify(moduleMetaData);
                        var row = serializeRowHeader('M', id) + json + '\n';
                        return stringToChunk(row);
                    }
                    function processProviderChunk(request, id, contextName) {
                        var row = serializeRowHeader('P', id) + contextName + '\n';
                        return stringToChunk(row);
                    }
                    function processSymbolChunk(request, id, name) {
                        var json = stringify(name);
                        var row = serializeRowHeader('S', id) + json + '\n';
                        return stringToChunk(row);
                    }
                    var MODULE_TAG = Symbol.for('react.module.reference');
                    function getModuleKey(reference) {
                        return reference.filepath + '#' + reference.name + (reference.async ? '#async' : '');
                    }
                    function isModuleReference(reference) {
                        return reference.$$typeof === MODULE_TAG;
                    }
                    function resolveModuleMetaData(config, moduleReference) {
                        var resolvedModuleData = config[moduleReference.filepath][moduleReference.name];
                        if (moduleReference.async) {
                            return {
                                id: resolvedModuleData.id,
                                chunks: resolvedModuleData.chunks,
                                name: resolvedModuleData.name,
                                async: true
                            };
                        } else {
                            return resolvedModuleData;
                        }
                    }
                    var REACT_ELEMENT_TYPE = Symbol.for('react.element');
                    var REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');
                    var REACT_PROVIDER_TYPE = Symbol.for('react.provider');
                    var REACT_SERVER_CONTEXT_TYPE = Symbol.for('react.server_context');
                    var REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');
                    var REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');
                    var REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');
                    var REACT_MEMO_TYPE = Symbol.for('react.memo');
                    var REACT_LAZY_TYPE = Symbol.for('react.lazy');
                    var REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED = Symbol.for('react.default_value');
                    var REACT_MEMO_CACHE_SENTINEL = Symbol.for('react.memo_cache_sentinel');
                    var RESERVED = 0;
                    var STRING = 1;
                    var BOOLEANISH_STRING = 2;
                    var BOOLEAN = 3;
                    var OVERLOADED_BOOLEAN = 4;
                    var NUMERIC = 5;
                    var POSITIVE_NUMERIC = 6;
                    function PropertyInfoRecord(name, type, mustUseProperty, attributeName, attributeNamespace, sanitizeURL, removeEmptyString) {
                        this.acceptsBooleans = type === BOOLEANISH_STRING || type === BOOLEAN || type === OVERLOADED_BOOLEAN;
                        this.attributeName = attributeName;
                        this.attributeNamespace = attributeNamespace;
                        this.mustUseProperty = mustUseProperty;
                        this.propertyName = name;
                        this.type = type;
                        this.sanitizeURL = sanitizeURL;
                        this.removeEmptyString = removeEmptyString;
                    }
                    var properties = {};
                    var reservedProps = [
                        'children',
                        'dangerouslySetInnerHTML',
                        'defaultValue',
                        'defaultChecked',
                        'innerHTML',
                        'suppressContentEditableWarning',
                        'suppressHydrationWarning',
                        'style'
                    ];
                    reservedProps.forEach(function(name) {
                        properties[name] = new PropertyInfoRecord(name, RESERVED, false, name, null, false, false);
                    });
                    [
                        [
                            'acceptCharset',
                            'accept-charset'
                        ],
                        [
                            'className',
                            'class'
                        ],
                        [
                            'htmlFor',
                            'for'
                        ],
                        [
                            'httpEquiv',
                            'http-equiv'
                        ]
                    ].forEach(function(_ref) {
                        var name = _ref[0], attributeName = _ref[1];
                        properties[name] = new PropertyInfoRecord(name, STRING, false, attributeName, null, false, false);
                    });
                    [
                        'contentEditable',
                        'draggable',
                        'spellCheck',
                        'value'
                    ].forEach(function(name) {
                        properties[name] = new PropertyInfoRecord(name, BOOLEANISH_STRING, false, name.toLowerCase(), null, false, false);
                    });
                    [
                        'autoReverse',
                        'externalResourcesRequired',
                        'focusable',
                        'preserveAlpha'
                    ].forEach(function(name) {
                        properties[name] = new PropertyInfoRecord(name, BOOLEANISH_STRING, false, name, null, false, false);
                    });
                    [
                        'allowFullScreen',
                        'async',
                        'autoFocus',
                        'autoPlay',
                        'controls',
                        'default',
                        'defer',
                        'disabled',
                        'disablePictureInPicture',
                        'disableRemotePlayback',
                        'formNoValidate',
                        'hidden',
                        'loop',
                        'noModule',
                        'noValidate',
                        'open',
                        'playsInline',
                        'readOnly',
                        'required',
                        'reversed',
                        'scoped',
                        'seamless',
                        'itemScope'
                    ].forEach(function(name) {
                        properties[name] = new PropertyInfoRecord(name, BOOLEAN, false, name.toLowerCase(), null, false, false);
                    });
                    [
                        'checked',
                        'multiple',
                        'muted',
                        'selected'
                    ].forEach(function(name) {
                        properties[name] = new PropertyInfoRecord(name, BOOLEAN, true, name, null, false, false);
                    });
                    [
                        'capture',
                        'download'
                    ].forEach(function(name) {
                        properties[name] = new PropertyInfoRecord(name, OVERLOADED_BOOLEAN, false, name, null, false, false);
                    });
                    [
                        'cols',
                        'rows',
                        'size',
                        'span'
                    ].forEach(function(name) {
                        properties[name] = new PropertyInfoRecord(name, POSITIVE_NUMERIC, false, name, null, false, false);
                    });
                    [
                        'rowSpan',
                        'start'
                    ].forEach(function(name) {
                        properties[name] = new PropertyInfoRecord(name, NUMERIC, false, name.toLowerCase(), null, false, false);
                    });
                    var CAMELIZE = /[\-\:]([a-z])/g;
                    var capitalize = function(token) {
                        return token[1].toUpperCase();
                    };
                    [
                        'accent-height',
                        'alignment-baseline',
                        'arabic-form',
                        'baseline-shift',
                        'cap-height',
                        'clip-path',
                        'clip-rule',
                        'color-interpolation',
                        'color-interpolation-filters',
                        'color-profile',
                        'color-rendering',
                        'dominant-baseline',
                        'enable-background',
                        'fill-opacity',
                        'fill-rule',
                        'flood-color',
                        'flood-opacity',
                        'font-family',
                        'font-size',
                        'font-size-adjust',
                        'font-stretch',
                        'font-style',
                        'font-variant',
                        'font-weight',
                        'glyph-name',
                        'glyph-orientation-horizontal',
                        'glyph-orientation-vertical',
                        'horiz-adv-x',
                        'horiz-origin-x',
                        'image-rendering',
                        'letter-spacing',
                        'lighting-color',
                        'marker-end',
                        'marker-mid',
                        'marker-start',
                        'overline-position',
                        'overline-thickness',
                        'paint-order',
                        'panose-1',
                        'pointer-events',
                        'rendering-intent',
                        'shape-rendering',
                        'stop-color',
                        'stop-opacity',
                        'strikethrough-position',
                        'strikethrough-thickness',
                        'stroke-dasharray',
                        'stroke-dashoffset',
                        'stroke-linecap',
                        'stroke-linejoin',
                        'stroke-miterlimit',
                        'stroke-opacity',
                        'stroke-width',
                        'text-anchor',
                        'text-decoration',
                        'text-rendering',
                        'underline-position',
                        'underline-thickness',
                        'unicode-bidi',
                        'unicode-range',
                        'units-per-em',
                        'v-alphabetic',
                        'v-hanging',
                        'v-ideographic',
                        'v-mathematical',
                        'vector-effect',
                        'vert-adv-y',
                        'vert-origin-x',
                        'vert-origin-y',
                        'word-spacing',
                        'writing-mode',
                        'xmlns:xlink',
                        'x-height'
                    ].forEach(function(attributeName) {
                        var name = attributeName.replace(CAMELIZE, capitalize);
                        properties[name] = new PropertyInfoRecord(name, STRING, false, attributeName, null, false, false);
                    });
                    [
                        'xlink:actuate',
                        'xlink:arcrole',
                        'xlink:role',
                        'xlink:show',
                        'xlink:title',
                        'xlink:type'
                    ].forEach(function(attributeName) {
                        var name = attributeName.replace(CAMELIZE, capitalize);
                        properties[name] = new PropertyInfoRecord(name, STRING, false, attributeName, 'http://www.w3.org/1999/xlink', false, false);
                    });
                    [
                        'xml:base',
                        'xml:lang',
                        'xml:space'
                    ].forEach(function(attributeName) {
                        var name = attributeName.replace(CAMELIZE, capitalize);
                        properties[name] = new PropertyInfoRecord(name, STRING, false, attributeName, 'http://www.w3.org/XML/1998/namespace', false, false);
                    });
                    [
                        'tabIndex',
                        'crossOrigin'
                    ].forEach(function(attributeName) {
                        properties[attributeName] = new PropertyInfoRecord(attributeName, STRING, false, attributeName.toLowerCase(), null, false, false);
                    });
                    var xlinkHref = 'xlinkHref';
                    properties[xlinkHref] = new PropertyInfoRecord('xlinkHref', STRING, false, 'xlink:href', 'http://www.w3.org/1999/xlink', true, false);
                    [
                        'src',
                        'href',
                        'action',
                        'formAction'
                    ].forEach(function(attributeName) {
                        properties[attributeName] = new PropertyInfoRecord(attributeName, STRING, false, attributeName.toLowerCase(), null, true, true);
                    });
                    var isUnitlessNumber = {
                        animationIterationCount: true,
                        aspectRatio: true,
                        borderImageOutset: true,
                        borderImageSlice: true,
                        borderImageWidth: true,
                        boxFlex: true,
                        boxFlexGroup: true,
                        boxOrdinalGroup: true,
                        columnCount: true,
                        columns: true,
                        flex: true,
                        flexGrow: true,
                        flexPositive: true,
                        flexShrink: true,
                        flexNegative: true,
                        flexOrder: true,
                        gridArea: true,
                        gridRow: true,
                        gridRowEnd: true,
                        gridRowSpan: true,
                        gridRowStart: true,
                        gridColumn: true,
                        gridColumnEnd: true,
                        gridColumnSpan: true,
                        gridColumnStart: true,
                        fontWeight: true,
                        lineClamp: true,
                        lineHeight: true,
                        opacity: true,
                        order: true,
                        orphans: true,
                        tabSize: true,
                        widows: true,
                        zIndex: true,
                        zoom: true,
                        fillOpacity: true,
                        floodOpacity: true,
                        stopOpacity: true,
                        strokeDasharray: true,
                        strokeDashoffset: true,
                        strokeMiterlimit: true,
                        strokeOpacity: true,
                        strokeWidth: true
                    };
                    function prefixKey(prefix, key) {
                        return prefix + key.charAt(0).toUpperCase() + key.substring(1);
                    }
                    var prefixes = [
                        'Webkit',
                        'ms',
                        'Moz',
                        'O'
                    ];
                    Object.keys(isUnitlessNumber).forEach(function(prop) {
                        prefixes.forEach(function(prefix) {
                            isUnitlessNumber[prefixKey(prefix, prop)] = isUnitlessNumber[prop];
                        });
                    });
                    var isArrayImpl = Array.isArray;
                    function isArray(a) {
                        return isArrayImpl(a);
                    }
                    var clientRenderBoundary = '$RX=function(b,c,d,e){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),b._reactRetry&&b._reactRetry())};';
                    var completeBoundary = '$RC=function(b,c,e){c=document.getElementById(c);c.parentNode.removeChild(c);var a=document.getElementById(b);if(a){b=a.previousSibling;if(e)b.data="$!",a.setAttribute("data-dgst",e);else{e=b.parentNode;a=b.nextSibling;var f=0;do{if(a&&8===a.nodeType){var d=a.data;if("/$"===d)if(0===f)break;else f--;else"$"!==d&&"$?"!==d&&"$!"!==d||f++}d=a.nextSibling;e.removeChild(a);a=d}while(a);for(;c.firstChild;)e.insertBefore(c.firstChild,a);b.data="$"}b._reactRetry&&b._reactRetry()}};';
                    var completeBoundaryWithStyles = '$RM=new Map;\n$RR=function(p,q,v){function r(l){this.s=l}for(var t=$RC,u=$RM,m=new Map,n=document,g,e,f=n.querySelectorAll("link[data-precedence],style[data-precedence]"),d=0;e=f[d++];)m.set(e.dataset.precedence,g=e);e=0;f=[];for(var c,h,b,a;c=v[e++];){var k=0;h=c[k++];if(b=u.get(h))"l"!==b.s&&f.push(b);else{a=n.createElement("link");a.href=h;a.rel="stylesheet";for(a.dataset.precedence=d=c[k++];b=c[k++];)a.setAttribute(b,c[k++]);b=a._p=new Promise(function(l,w){a.onload=l;a.onerror=w});b.then(r.bind(b,\n"l"),r.bind(b,"e"));u.set(h,b);f.push(b);c=m.get(d)||g;c===g&&(g=a);m.set(d,a);c?c.parentNode.insertBefore(a,c.nextSibling):(d=n.head,d.insertBefore(a,d.firstChild))}}Promise.all(f).then(t.bind(null,p,q,""),t.bind(null,p,q,"Resource failed to load"))};';
                    var completeSegment = '$RS=function(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)};';
                    var ReactDOMSharedInternals = ReactDOM.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
                    var ReactDOMCurrentDispatcher = ReactDOMSharedInternals.Dispatcher;
                    var startInlineScript = stringToPrecomputedChunk('<script>');
                    var endInlineScript = stringToPrecomputedChunk('</script>');
                    var startScriptSrc = stringToPrecomputedChunk('<script src="');
                    var startModuleSrc = stringToPrecomputedChunk('<script type="module" src="');
                    var scriptIntegirty = stringToPrecomputedChunk('" integrity="');
                    var endAsyncScript = stringToPrecomputedChunk('" async=""></script>');
                    var textSeparator = stringToPrecomputedChunk('<!-- -->');
                    var styleAttributeStart = stringToPrecomputedChunk(' style="');
                    var styleAssign = stringToPrecomputedChunk(':');
                    var styleSeparator = stringToPrecomputedChunk(';');
                    var attributeSeparator = stringToPrecomputedChunk(' ');
                    var attributeAssign = stringToPrecomputedChunk('="');
                    var attributeEnd = stringToPrecomputedChunk('"');
                    var attributeEmptyString = stringToPrecomputedChunk('=""');
                    var endOfStartTag = stringToPrecomputedChunk('>');
                    var endOfStartTagSelfClosing = stringToPrecomputedChunk('/>');
                    var selectedMarkerAttribute = stringToPrecomputedChunk(' selected=""');
                    var leadingNewline = stringToPrecomputedChunk('\n');
                    var DOCTYPE = stringToPrecomputedChunk('<!DOCTYPE html>');
                    var endTag1 = stringToPrecomputedChunk('</');
                    var endTag2 = stringToPrecomputedChunk('>');
                    var placeholder1 = stringToPrecomputedChunk('<template id="');
                    var placeholder2 = stringToPrecomputedChunk('"></template>');
                    var startCompletedSuspenseBoundary = stringToPrecomputedChunk('<!--$-->');
                    var startPendingSuspenseBoundary1 = stringToPrecomputedChunk('<!--$?--><template id="');
                    var startPendingSuspenseBoundary2 = stringToPrecomputedChunk('"></template>');
                    var startClientRenderedSuspenseBoundary = stringToPrecomputedChunk('<!--$!-->');
                    var endSuspenseBoundary = stringToPrecomputedChunk('<!--/$-->');
                    var clientRenderedSuspenseBoundaryError1 = stringToPrecomputedChunk('<template');
                    var clientRenderedSuspenseBoundaryErrorAttrInterstitial = stringToPrecomputedChunk('"');
                    var clientRenderedSuspenseBoundaryError1A = stringToPrecomputedChunk(' data-dgst="');
                    var clientRenderedSuspenseBoundaryError1B = stringToPrecomputedChunk(' data-msg="');
                    var clientRenderedSuspenseBoundaryError1C = stringToPrecomputedChunk(' data-stck="');
                    var clientRenderedSuspenseBoundaryError2 = stringToPrecomputedChunk('></template>');
                    var startSegmentHTML = stringToPrecomputedChunk('<div hidden id="');
                    var startSegmentHTML2 = stringToPrecomputedChunk('">');
                    var endSegmentHTML = stringToPrecomputedChunk('</div>');
                    var startSegmentSVG = stringToPrecomputedChunk('<svg aria-hidden="true" style="display:none" id="');
                    var startSegmentSVG2 = stringToPrecomputedChunk('">');
                    var endSegmentSVG = stringToPrecomputedChunk('</svg>');
                    var startSegmentMathML = stringToPrecomputedChunk('<math aria-hidden="true" style="display:none" id="');
                    var startSegmentMathML2 = stringToPrecomputedChunk('">');
                    var endSegmentMathML = stringToPrecomputedChunk('</math>');
                    var startSegmentTable = stringToPrecomputedChunk('<table hidden id="');
                    var startSegmentTable2 = stringToPrecomputedChunk('">');
                    var endSegmentTable = stringToPrecomputedChunk('</table>');
                    var startSegmentTableBody = stringToPrecomputedChunk('<table hidden><tbody id="');
                    var startSegmentTableBody2 = stringToPrecomputedChunk('">');
                    var endSegmentTableBody = stringToPrecomputedChunk('</tbody></table>');
                    var startSegmentTableRow = stringToPrecomputedChunk('<table hidden><tr id="');
                    var startSegmentTableRow2 = stringToPrecomputedChunk('">');
                    var endSegmentTableRow = stringToPrecomputedChunk('</tr></table>');
                    var startSegmentColGroup = stringToPrecomputedChunk('<table hidden><colgroup id="');
                    var startSegmentColGroup2 = stringToPrecomputedChunk('">');
                    var endSegmentColGroup = stringToPrecomputedChunk('</colgroup></table>');
                    var completeSegmentScript1Full = stringToPrecomputedChunk(completeSegment + ';$RS("');
                    var completeSegmentScript1Partial = stringToPrecomputedChunk('$RS("');
                    var completeSegmentScript2 = stringToPrecomputedChunk('","');
                    var completeSegmentScript3 = stringToPrecomputedChunk('")</script>');
                    var completeBoundaryScript1Full = stringToPrecomputedChunk(completeBoundary + ';$RC("');
                    var completeBoundaryScript1Partial = stringToPrecomputedChunk('$RC("');
                    var completeBoundaryWithStylesScript1FullBoth = stringToPrecomputedChunk(completeBoundary + ';' + completeBoundaryWithStyles + ';$RR("');
                    var completeBoundaryWithStylesScript1FullPartial = stringToPrecomputedChunk(completeBoundaryWithStyles + ';$RR("');
                    var completeBoundaryWithStylesScript1Partial = stringToPrecomputedChunk('$RR("');
                    var completeBoundaryScript2 = stringToPrecomputedChunk('","');
                    var completeBoundaryScript2a = stringToPrecomputedChunk('",');
                    var completeBoundaryScript3 = stringToPrecomputedChunk('"');
                    var completeBoundaryScript4 = stringToPrecomputedChunk(')</script>');
                    var clientRenderScript1Full = stringToPrecomputedChunk(clientRenderBoundary + ';$RX("');
                    var clientRenderScript1Partial = stringToPrecomputedChunk('$RX("');
                    var clientRenderScript1A = stringToPrecomputedChunk('"');
                    var clientRenderScript2 = stringToPrecomputedChunk(')</script>');
                    var clientRenderErrorScriptArgInterstitial = stringToPrecomputedChunk(',');
                    var precedencePlaceholderStart = stringToPrecomputedChunk('<style data-precedence="');
                    var precedencePlaceholderEnd = stringToPrecomputedChunk('"></style>');
                    var arrayFirstOpenBracket = stringToPrecomputedChunk('[');
                    var arraySubsequentOpenBracket = stringToPrecomputedChunk(',[');
                    var arrayInterstitial = stringToPrecomputedChunk(',');
                    var arrayCloseBracket = stringToPrecomputedChunk(']');
                    var rendererSigil;
                    {
                        rendererSigil = {};
                    }
                    var rootContextSnapshot = null;
                    var currentActiveSnapshot = null;
                    function popNode(prev) {
                        {
                            prev.context._currentValue = prev.parentValue;
                        }
                    }
                    function pushNode(next) {
                        {
                            next.context._currentValue = next.value;
                        }
                    }
                    function popToNearestCommonAncestor(prev, next) {
                        if (prev === next) ;
                        else {
                            popNode(prev);
                            var parentPrev = prev.parent;
                            var parentNext = next.parent;
                            if (parentPrev === null) {
                                if (parentNext !== null) {
                                    throw new Error('The stacks must reach the root at the same time. This is a bug in React.');
                                }
                            } else {
                                if (parentNext === null) {
                                    throw new Error('The stacks must reach the root at the same time. This is a bug in React.');
                                }
                                popToNearestCommonAncestor(parentPrev, parentNext);
                                pushNode(next);
                            }
                        }
                    }
                    function popAllPrevious(prev) {
                        popNode(prev);
                        var parentPrev = prev.parent;
                        if (parentPrev !== null) {
                            popAllPrevious(parentPrev);
                        }
                    }
                    function pushAllNext(next) {
                        var parentNext = next.parent;
                        if (parentNext !== null) {
                            pushAllNext(parentNext);
                        }
                        pushNode(next);
                    }
                    function popPreviousToCommonLevel(prev, next) {
                        popNode(prev);
                        var parentPrev = prev.parent;
                        if (parentPrev === null) {
                            throw new Error('The depth must equal at least at zero before reaching the root. This is a bug in React.');
                        }
                        if (parentPrev.depth === next.depth) {
                            popToNearestCommonAncestor(parentPrev, next);
                        } else {
                            popPreviousToCommonLevel(parentPrev, next);
                        }
                    }
                    function popNextToCommonLevel(prev, next) {
                        var parentNext = next.parent;
                        if (parentNext === null) {
                            throw new Error('The depth must equal at least at zero before reaching the root. This is a bug in React.');
                        }
                        if (prev.depth === parentNext.depth) {
                            popToNearestCommonAncestor(prev, parentNext);
                        } else {
                            popNextToCommonLevel(prev, parentNext);
                        }
                        pushNode(next);
                    }
                    function switchContext(newSnapshot) {
                        var prev = currentActiveSnapshot;
                        var next = newSnapshot;
                        if (prev !== next) {
                            if (prev === null) {
                                pushAllNext(next);
                            } else if (next === null) {
                                popAllPrevious(prev);
                            } else if (prev.depth === next.depth) {
                                popToNearestCommonAncestor(prev, next);
                            } else if (prev.depth > next.depth) {
                                popPreviousToCommonLevel(prev, next);
                            } else {
                                popNextToCommonLevel(prev, next);
                            }
                            currentActiveSnapshot = next;
                        }
                    }
                    function pushProvider(context, nextValue) {
                        var prevValue;
                        {
                            prevValue = context._currentValue;
                            context._currentValue = nextValue;
                            {
                                if (context._currentRenderer !== undefined && context._currentRenderer !== null && context._currentRenderer !== rendererSigil) {
                                    error('Detected multiple renderers concurrently rendering the ' + 'same context provider. This is currently unsupported.');
                                }
                                context._currentRenderer = rendererSigil;
                            }
                        }
                        var prevNode = currentActiveSnapshot;
                        var newNode = {
                            parent: prevNode,
                            depth: prevNode === null ? 0 : prevNode.depth + 1,
                            context: context,
                            parentValue: prevValue,
                            value: nextValue
                        };
                        currentActiveSnapshot = newNode;
                        return newNode;
                    }
                    function popProvider() {
                        var prevSnapshot = currentActiveSnapshot;
                        if (prevSnapshot === null) {
                            throw new Error('Tried to pop a Context at the root of the app. This is a bug in React.');
                        }
                        {
                            var value = prevSnapshot.parentValue;
                            if (value === REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED) {
                                prevSnapshot.context._currentValue = prevSnapshot.context._defaultValue;
                            } else {
                                prevSnapshot.context._currentValue = value;
                            }
                        }
                        return currentActiveSnapshot = prevSnapshot.parent;
                    }
                    function getActiveContext() {
                        return currentActiveSnapshot;
                    }
                    function readContext(context) {
                        var value = context._currentValue;
                        return value;
                    }
                    function createThenableState() {
                        return [];
                    }
                    function noop() {}
                    function trackUsedThenable(thenableState, thenable, index) {
                        var previous = thenableState[index];
                        if (previous === undefined) {
                            thenableState.push(thenable);
                        } else {
                            if (previous !== thenable) {
                                thenable.then(noop, noop);
                                thenable = previous;
                            }
                        }
                        switch(thenable.status){
                            case 'fulfilled':
                                {
                                    var fulfilledValue = thenable.value;
                                    return fulfilledValue;
                                }
                            case 'rejected':
                                {
                                    var rejectedError = thenable.reason;
                                    throw rejectedError;
                                }
                            default:
                                {
                                    if (typeof thenable.status === 'string') ;
                                    else {
                                        var pendingThenable = thenable;
                                        pendingThenable.status = 'pending';
                                        pendingThenable.then(function(fulfilledValue) {
                                            if (thenable.status === 'pending') {
                                                var fulfilledThenable = thenable;
                                                fulfilledThenable.status = 'fulfilled';
                                                fulfilledThenable.value = fulfilledValue;
                                            }
                                        }, function(error) {
                                            if (thenable.status === 'pending') {
                                                var rejectedThenable = thenable;
                                                rejectedThenable.status = 'rejected';
                                                rejectedThenable.reason = error;
                                            }
                                        });
                                    }
                                    throw thenable;
                                }
                        }
                    }
                    var currentRequest = null;
                    var thenableIndexCounter = 0;
                    var thenableState = null;
                    function prepareToUseHooksForRequest(request) {
                        currentRequest = request;
                    }
                    function resetHooksForRequest() {
                        currentRequest = null;
                    }
                    function prepareToUseHooksForComponent(prevThenableState) {
                        thenableIndexCounter = 0;
                        thenableState = prevThenableState;
                    }
                    function getThenableStateAfterSuspending() {
                        var state = thenableState;
                        thenableState = null;
                        return state;
                    }
                    function readContext$1(context) {
                        {
                            if (context.$$typeof !== REACT_SERVER_CONTEXT_TYPE) {
                                error('Only createServerContext is supported in Server Components.');
                            }
                            if (currentRequest === null) {
                                error('Context can only be read while React is rendering. ' + 'In classes, you can read it in the render method or getDerivedStateFromProps. ' + 'In function components, you can read it directly in the function body, but not ' + 'inside Hooks like useReducer() or useMemo().');
                            }
                        }
                        return readContext(context);
                    }
                    var HooksDispatcher = {
                        useMemo: function(nextCreate) {
                            return nextCreate();
                        },
                        useCallback: function(callback) {
                            return callback;
                        },
                        useDebugValue: function() {},
                        useDeferredValue: unsupportedHook,
                        useTransition: unsupportedHook,
                        readContext: readContext$1,
                        useContext: readContext$1,
                        useReducer: unsupportedHook,
                        useRef: unsupportedHook,
                        useState: unsupportedHook,
                        useInsertionEffect: unsupportedHook,
                        useLayoutEffect: unsupportedHook,
                        useImperativeHandle: unsupportedHook,
                        useEffect: unsupportedHook,
                        useId: useId,
                        useMutableSource: unsupportedHook,
                        useSyncExternalStore: unsupportedHook,
                        useCacheRefresh: function() {
                            return unsupportedRefresh;
                        },
                        useMemoCache: function(size) {
                            var data = new Array(size);
                            for(var i = 0; i < size; i++){
                                data[i] = REACT_MEMO_CACHE_SENTINEL;
                            }
                            return data;
                        },
                        use: use
                    };
                    function unsupportedHook() {
                        throw new Error('This Hook is not supported in Server Components.');
                    }
                    function unsupportedRefresh() {
                        throw new Error('Refreshing the cache is not supported in Server Components.');
                    }
                    function useId() {
                        if (currentRequest === null) {
                            throw new Error('useId can only be used while React is rendering');
                        }
                        var id = currentRequest.identifierCount++;
                        return ':' + currentRequest.identifierPrefix + 'S' + id.toString(32) + ':';
                    }
                    function use(usable) {
                        if (usable !== null && typeof usable === 'object') {
                            if (typeof usable.then === 'function') {
                                var thenable = usable;
                                var index = thenableIndexCounter;
                                thenableIndexCounter += 1;
                                if (thenableState === null) {
                                    thenableState = createThenableState();
                                }
                                return trackUsedThenable(thenableState, thenable, index);
                            } else if (usable.$$typeof === REACT_SERVER_CONTEXT_TYPE) {
                                var context = usable;
                                return readContext$1(context);
                            }
                        }
                        throw new Error('An unsupported type was passed to use(): ' + String(usable));
                    }
                    function createSignal() {
                        return new AbortController().signal;
                    }
                    function resolveCache() {
                        if (currentCache) return currentCache;
                        if (supportsRequestStorage) {
                            var cache = requestStorage.getStore();
                            if (cache) return cache;
                        }
                        return new Map();
                    }
                    var DefaultCacheDispatcher = {
                        getCacheSignal: function() {
                            var cache = resolveCache();
                            var entry = cache.get(createSignal);
                            if (entry === undefined) {
                                entry = createSignal();
                                cache.set(createSignal, entry);
                            }
                            return entry;
                        },
                        getCacheForType: function(resourceType) {
                            var cache = resolveCache();
                            var entry = cache.get(resourceType);
                            if (entry === undefined) {
                                entry = resourceType();
                                cache.set(resourceType, entry);
                            }
                            return entry;
                        }
                    };
                    var currentCache = null;
                    function setCurrentCache(cache) {
                        currentCache = cache;
                        return currentCache;
                    }
                    function getCurrentCache() {
                        return currentCache;
                    }
                    var ContextRegistry = ReactSharedInternals.ContextRegistry;
                    function getOrCreateServerContext(globalName) {
                        if (!ContextRegistry[globalName]) {
                            ContextRegistry[globalName] = React.createServerContext(globalName, REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED);
                        }
                        return ContextRegistry[globalName];
                    }
                    var PENDING = 0;
                    var COMPLETED = 1;
                    var ABORTED = 3;
                    var ERRORED = 4;
                    var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
                    var ReactCurrentCache = ReactSharedInternals.ReactCurrentCache;
                    function defaultErrorHandler(error) {
                        console['error'](error);
                    }
                    var OPEN = 0;
                    var CLOSING = 1;
                    var CLOSED = 2;
                    function createRequest(model, bundlerConfig, onError, context, identifierPrefix) {
                        if (ReactCurrentCache.current !== null && ReactCurrentCache.current !== DefaultCacheDispatcher) {
                            throw new Error('Currently React only supports one RSC renderer at a time.');
                        }
                        ReactCurrentCache.current = DefaultCacheDispatcher;
                        var abortSet = new Set();
                        var pingedTasks = [];
                        var request = {
                            status: OPEN,
                            fatalError: null,
                            destination: null,
                            bundlerConfig: bundlerConfig,
                            cache: new Map(),
                            nextChunkId: 0,
                            pendingChunks: 0,
                            abortableTasks: abortSet,
                            pingedTasks: pingedTasks,
                            completedModuleChunks: [],
                            completedJSONChunks: [],
                            completedErrorChunks: [],
                            writtenSymbols: new Map(),
                            writtenModules: new Map(),
                            writtenProviders: new Map(),
                            identifierPrefix: identifierPrefix || '',
                            identifierCount: 1,
                            onError: onError === undefined ? defaultErrorHandler : onError,
                            toJSON: function(key, value) {
                                return resolveModelToJSON(request, this, key, value);
                            }
                        };
                        request.pendingChunks++;
                        var rootContext = createRootContext(context);
                        var rootTask = createTask(request, model, rootContext, abortSet);
                        pingedTasks.push(rootTask);
                        return request;
                    }
                    function createRootContext(reqContext) {
                        return importServerContexts(reqContext);
                    }
                    var POP = {};
                    var jsxPropsParents = new WeakMap();
                    var jsxChildrenParents = new WeakMap();
                    function readThenable(thenable) {
                        if (thenable.status === 'fulfilled') {
                            return thenable.value;
                        } else if (thenable.status === 'rejected') {
                            throw thenable.reason;
                        }
                        throw thenable;
                    }
                    function createLazyWrapperAroundWakeable(wakeable) {
                        var thenable = wakeable;
                        switch(thenable.status){
                            case 'fulfilled':
                            case 'rejected':
                                break;
                            default:
                                {
                                    if (typeof thenable.status === 'string') {
                                        break;
                                    }
                                    var pendingThenable = thenable;
                                    pendingThenable.status = 'pending';
                                    pendingThenable.then(function(fulfilledValue) {
                                        if (thenable.status === 'pending') {
                                            var fulfilledThenable = thenable;
                                            fulfilledThenable.status = 'fulfilled';
                                            fulfilledThenable.value = fulfilledValue;
                                        }
                                    }, function(error) {
                                        if (thenable.status === 'pending') {
                                            var rejectedThenable = thenable;
                                            rejectedThenable.status = 'rejected';
                                            rejectedThenable.reason = error;
                                        }
                                    });
                                    break;
                                }
                        }
                        var lazyType = {
                            $$typeof: REACT_LAZY_TYPE,
                            _payload: thenable,
                            _init: readThenable
                        };
                        return lazyType;
                    }
                    function attemptResolveElement(type, key, ref, props, prevThenableState) {
                        if (ref !== null && ref !== undefined) {
                            throw new Error('Refs cannot be used in Server Components, nor passed to Client Components.');
                        }
                        {
                            jsxPropsParents.set(props, type);
                            if (typeof props.children === 'object') {
                                jsxChildrenParents.set(props.children, type);
                            }
                        }
                        if (typeof type === 'function') {
                            if (isModuleReference(type)) {
                                return [
                                    REACT_ELEMENT_TYPE,
                                    type,
                                    key,
                                    props
                                ];
                            }
                            prepareToUseHooksForComponent(prevThenableState);
                            var result = type(props);
                            if (typeof result === 'object' && result !== null && typeof result.then === 'function') {
                                return createLazyWrapperAroundWakeable(result);
                            }
                            return result;
                        } else if (typeof type === 'string') {
                            return [
                                REACT_ELEMENT_TYPE,
                                type,
                                key,
                                props
                            ];
                        } else if (typeof type === 'symbol') {
                            if (type === REACT_FRAGMENT_TYPE) {
                                return props.children;
                            }
                            return [
                                REACT_ELEMENT_TYPE,
                                type,
                                key,
                                props
                            ];
                        } else if (type != null && typeof type === 'object') {
                            if (isModuleReference(type)) {
                                return [
                                    REACT_ELEMENT_TYPE,
                                    type,
                                    key,
                                    props
                                ];
                            }
                            switch(type.$$typeof){
                                case REACT_LAZY_TYPE:
                                    {
                                        var payload = type._payload;
                                        var init = type._init;
                                        var wrappedType = init(payload);
                                        return attemptResolveElement(wrappedType, key, ref, props, prevThenableState);
                                    }
                                case REACT_FORWARD_REF_TYPE:
                                    {
                                        var render = type.render;
                                        prepareToUseHooksForComponent(prevThenableState);
                                        return render(props, undefined);
                                    }
                                case REACT_MEMO_TYPE:
                                    {
                                        return attemptResolveElement(type.type, key, ref, props, prevThenableState);
                                    }
                                case REACT_PROVIDER_TYPE:
                                    {
                                        pushProvider(type._context, props.value);
                                        {
                                            var extraKeys = Object.keys(props).filter(function(value) {
                                                if (value === 'children' || value === 'value') {
                                                    return false;
                                                }
                                                return true;
                                            });
                                            if (extraKeys.length !== 0) {
                                                error('ServerContext can only have a value prop and children. Found: %s', JSON.stringify(extraKeys));
                                            }
                                        }
                                        return [
                                            REACT_ELEMENT_TYPE,
                                            type,
                                            key,
                                            {
                                                value: props.value,
                                                children: props.children,
                                                __pop: POP
                                            }
                                        ];
                                    }
                            }
                        }
                        throw new Error("Unsupported Server Component type: " + describeValueForErrorMessage(type));
                    }
                    function pingTask(request, task) {
                        var pingedTasks = request.pingedTasks;
                        pingedTasks.push(task);
                        if (pingedTasks.length === 1) {
                            scheduleWork(function() {
                                return performWork(request);
                            });
                        }
                    }
                    function createTask(request, model, context, abortSet) {
                        var id = request.nextChunkId++;
                        var task = {
                            id: id,
                            status: PENDING,
                            model: model,
                            context: context,
                            ping: function() {
                                return pingTask(request, task);
                            },
                            thenableState: null
                        };
                        abortSet.add(task);
                        return task;
                    }
                    function serializeByValueID(id) {
                        return '$' + id.toString(16);
                    }
                    function serializeByRefID(id) {
                        return '@' + id.toString(16);
                    }
                    function serializeModuleReference(request, parent, key, moduleReference) {
                        var moduleKey = getModuleKey(moduleReference);
                        var writtenModules = request.writtenModules;
                        var existingId = writtenModules.get(moduleKey);
                        if (existingId !== undefined) {
                            if (parent[0] === REACT_ELEMENT_TYPE && key === '1') {
                                return serializeByRefID(existingId);
                            }
                            return serializeByValueID(existingId);
                        }
                        try {
                            var moduleMetaData = resolveModuleMetaData(request.bundlerConfig, moduleReference);
                            request.pendingChunks++;
                            var moduleId = request.nextChunkId++;
                            emitModuleChunk(request, moduleId, moduleMetaData);
                            writtenModules.set(moduleKey, moduleId);
                            if (parent[0] === REACT_ELEMENT_TYPE && key === '1') {
                                return serializeByRefID(moduleId);
                            }
                            return serializeByValueID(moduleId);
                        } catch (x) {
                            request.pendingChunks++;
                            var errorId = request.nextChunkId++;
                            var digest = logRecoverableError(request, x);
                            {
                                var _getErrorMessageAndSt = getErrorMessageAndStackDev(x), message = _getErrorMessageAndSt.message, stack = _getErrorMessageAndSt.stack;
                                emitErrorChunkDev(request, errorId, digest, message, stack);
                            }
                            return serializeByValueID(errorId);
                        }
                    }
                    function escapeStringValue(value) {
                        if (value[0] === '$' || value[0] === '@') {
                            return '$' + value;
                        } else {
                            return value;
                        }
                    }
                    function isObjectPrototype(object) {
                        if (!object) {
                            return false;
                        }
                        var ObjectPrototype = Object.prototype;
                        if (object === ObjectPrototype) {
                            return true;
                        }
                        if (Object.getPrototypeOf(object)) {
                            return false;
                        }
                        var names = Object.getOwnPropertyNames(object);
                        for(var i = 0; i < names.length; i++){
                            if (!(names[i] in ObjectPrototype)) {
                                return false;
                            }
                        }
                        return true;
                    }
                    function isSimpleObject(object) {
                        if (!isObjectPrototype(Object.getPrototypeOf(object))) {
                            return false;
                        }
                        var names = Object.getOwnPropertyNames(object);
                        for(var i = 0; i < names.length; i++){
                            var descriptor = Object.getOwnPropertyDescriptor(object, names[i]);
                            if (!descriptor) {
                                return false;
                            }
                            if (!descriptor.enumerable) {
                                if ((names[i] === 'key' || names[i] === 'ref') && typeof descriptor.get === 'function') {
                                    continue;
                                }
                                return false;
                            }
                        }
                        return true;
                    }
                    function objectName(object) {
                        var name = Object.prototype.toString.call(object);
                        return name.replace(/^\[object (.*)\]$/, function(m, p0) {
                            return p0;
                        });
                    }
                    function describeKeyForErrorMessage(key) {
                        var encodedKey = JSON.stringify(key);
                        return '"' + key + '"' === encodedKey ? key : encodedKey;
                    }
                    function describeValueForErrorMessage(value) {
                        switch(typeof value){
                            case 'string':
                                {
                                    return JSON.stringify(value.length <= 10 ? value : value.substr(0, 10) + '...');
                                }
                            case 'object':
                                {
                                    if (isArray(value)) {
                                        return '[...]';
                                    }
                                    var name = objectName(value);
                                    if (name === 'Object') {
                                        return '{...}';
                                    }
                                    return name;
                                }
                            case 'function':
                                return 'function';
                            default:
                                return String(value);
                        }
                    }
                    function describeElementType(type) {
                        if (typeof type === 'string') {
                            return type;
                        }
                        switch(type){
                            case REACT_SUSPENSE_TYPE:
                                return 'Suspense';
                            case REACT_SUSPENSE_LIST_TYPE:
                                return 'SuspenseList';
                        }
                        if (typeof type === 'object') {
                            switch(type.$$typeof){
                                case REACT_FORWARD_REF_TYPE:
                                    return describeElementType(type.render);
                                case REACT_MEMO_TYPE:
                                    return describeElementType(type.type);
                                case REACT_LAZY_TYPE:
                                    {
                                        var lazyComponent = type;
                                        var payload = lazyComponent._payload;
                                        var init = lazyComponent._init;
                                        try {
                                            return describeElementType(init(payload));
                                        } catch (x) {}
                                    }
                            }
                        }
                        return '';
                    }
                    function describeObjectForErrorMessage(objectOrArray, expandedName) {
                        var objKind = objectName(objectOrArray);
                        if (objKind !== 'Object' && objKind !== 'Array') {
                            return objKind;
                        }
                        var str = '';
                        var start = -1;
                        var length = 0;
                        if (isArray(objectOrArray)) {
                            if (jsxChildrenParents.has(objectOrArray)) {
                                var type = jsxChildrenParents.get(objectOrArray);
                                str = '<' + describeElementType(type) + '>';
                                var array = objectOrArray;
                                for(var i = 0; i < array.length; i++){
                                    var _value = array[i];
                                    var substr = void 0;
                                    if (typeof _value === 'string') {
                                        substr = _value;
                                    } else if (typeof _value === 'object' && _value !== null) {
                                        substr = '{' + describeObjectForErrorMessage(_value) + '}';
                                    } else {
                                        substr = '{' + describeValueForErrorMessage(_value) + '}';
                                    }
                                    if ('' + i === expandedName) {
                                        start = str.length;
                                        length = substr.length;
                                        str += substr;
                                    } else if (substr.length < 15 && str.length + substr.length < 40) {
                                        str += substr;
                                    } else {
                                        str += '{...}';
                                    }
                                }
                                str += '</' + describeElementType(type) + '>';
                            } else {
                                str = '[';
                                var _array = objectOrArray;
                                for(var _i = 0; _i < _array.length; _i++){
                                    if (_i > 0) {
                                        str += ', ';
                                    }
                                    var _value2 = _array[_i];
                                    var _substr = void 0;
                                    if (typeof _value2 === 'object' && _value2 !== null) {
                                        _substr = describeObjectForErrorMessage(_value2);
                                    } else {
                                        _substr = describeValueForErrorMessage(_value2);
                                    }
                                    if ('' + _i === expandedName) {
                                        start = str.length;
                                        length = _substr.length;
                                        str += _substr;
                                    } else if (_substr.length < 10 && str.length + _substr.length < 40) {
                                        str += _substr;
                                    } else {
                                        str += '...';
                                    }
                                }
                                str += ']';
                            }
                        } else {
                            if (objectOrArray.$$typeof === REACT_ELEMENT_TYPE) {
                                str = '<' + describeElementType(objectOrArray.type) + '/>';
                            } else if (jsxPropsParents.has(objectOrArray)) {
                                var _type = jsxPropsParents.get(objectOrArray);
                                str = '<' + (describeElementType(_type) || '...');
                                var object = objectOrArray;
                                var names = Object.keys(object);
                                for(var _i2 = 0; _i2 < names.length; _i2++){
                                    str += ' ';
                                    var name = names[_i2];
                                    str += describeKeyForErrorMessage(name) + '=';
                                    var _value3 = object[name];
                                    var _substr2 = void 0;
                                    if (name === expandedName && typeof _value3 === 'object' && _value3 !== null) {
                                        _substr2 = describeObjectForErrorMessage(_value3);
                                    } else {
                                        _substr2 = describeValueForErrorMessage(_value3);
                                    }
                                    if (typeof _value3 !== 'string') {
                                        _substr2 = '{' + _substr2 + '}';
                                    }
                                    if (name === expandedName) {
                                        start = str.length;
                                        length = _substr2.length;
                                        str += _substr2;
                                    } else if (_substr2.length < 10 && str.length + _substr2.length < 40) {
                                        str += _substr2;
                                    } else {
                                        str += '...';
                                    }
                                }
                                str += '>';
                            } else {
                                str = '{';
                                var _object = objectOrArray;
                                var _names = Object.keys(_object);
                                for(var _i3 = 0; _i3 < _names.length; _i3++){
                                    if (_i3 > 0) {
                                        str += ', ';
                                    }
                                    var _name = _names[_i3];
                                    str += describeKeyForErrorMessage(_name) + ': ';
                                    var _value4 = _object[_name];
                                    var _substr3 = void 0;
                                    if (typeof _value4 === 'object' && _value4 !== null) {
                                        _substr3 = describeObjectForErrorMessage(_value4);
                                    } else {
                                        _substr3 = describeValueForErrorMessage(_value4);
                                    }
                                    if (_name === expandedName) {
                                        start = str.length;
                                        length = _substr3.length;
                                        str += _substr3;
                                    } else if (_substr3.length < 10 && str.length + _substr3.length < 40) {
                                        str += _substr3;
                                    } else {
                                        str += '...';
                                    }
                                }
                                str += '}';
                            }
                        }
                        if (expandedName === undefined) {
                            return str;
                        }
                        if (start > -1 && length > 0) {
                            var highlight = ' '.repeat(start) + '^'.repeat(length);
                            return '\n  ' + str + '\n  ' + highlight;
                        }
                        return '\n  ' + str;
                    }
                    var insideContextProps = null;
                    var isInsideContextValue = false;
                    function resolveModelToJSON(request, parent, key, value) {
                        {
                            var originalValue = parent[key];
                            if (typeof originalValue === 'object' && originalValue !== value) {
                                if (objectName(originalValue) !== 'Object') {
                                    var jsxParentType = jsxChildrenParents.get(parent);
                                    if (typeof jsxParentType === 'string') {
                                        error('%s objects cannot be rendered as text children. Try formatting it using toString().%s', objectName(originalValue), describeObjectForErrorMessage(parent, key));
                                    } else {
                                        error('Only plain objects can be passed to Client Components from Server Components. ' + '%s objects are not supported.%s', objectName(originalValue), describeObjectForErrorMessage(parent, key));
                                    }
                                } else {
                                    error('Only plain objects can be passed to Client Components from Server Components. ' + 'Objects with toJSON methods are not supported. Convert it manually ' + 'to a simple value before passing it to props.%s', describeObjectForErrorMessage(parent, key));
                                }
                            }
                        }
                        switch(value){
                            case REACT_ELEMENT_TYPE:
                                return '$';
                        }
                        {
                            if (parent[0] === REACT_ELEMENT_TYPE && parent[1] && parent[1].$$typeof === REACT_PROVIDER_TYPE && key === '3') {
                                insideContextProps = value;
                            } else if (insideContextProps === parent && key === 'value') {
                                isInsideContextValue = true;
                            } else if (insideContextProps === parent && key === 'children') {
                                isInsideContextValue = false;
                            }
                        }
                        while(typeof value === 'object' && value !== null && (value.$$typeof === REACT_ELEMENT_TYPE || value.$$typeof === REACT_LAZY_TYPE)){
                            {
                                if (isInsideContextValue) {
                                    error('React elements are not allowed in ServerContext');
                                }
                            }
                            try {
                                switch(value.$$typeof){
                                    case REACT_ELEMENT_TYPE:
                                        {
                                            var element = value;
                                            value = attemptResolveElement(element.type, element.key, element.ref, element.props, null);
                                            break;
                                        }
                                    case REACT_LAZY_TYPE:
                                        {
                                            var payload = value._payload;
                                            var init = value._init;
                                            value = init(payload);
                                            break;
                                        }
                                }
                            } catch (x) {
                                if (typeof x === 'object' && x !== null && typeof x.then === 'function') {
                                    request.pendingChunks++;
                                    var newTask = createTask(request, value, getActiveContext(), request.abortableTasks);
                                    var ping = newTask.ping;
                                    x.then(ping, ping);
                                    newTask.thenableState = getThenableStateAfterSuspending();
                                    return serializeByRefID(newTask.id);
                                } else {
                                    request.pendingChunks++;
                                    var errorId = request.nextChunkId++;
                                    var digest = logRecoverableError(request, x);
                                    {
                                        var _getErrorMessageAndSt2 = getErrorMessageAndStackDev(x), message = _getErrorMessageAndSt2.message, stack = _getErrorMessageAndSt2.stack;
                                        emitErrorChunkDev(request, errorId, digest, message, stack);
                                    }
                                    return serializeByRefID(errorId);
                                }
                            }
                        }
                        if (value === null) {
                            return null;
                        }
                        if (typeof value === 'object') {
                            if (isModuleReference(value)) {
                                return serializeModuleReference(request, parent, key, value);
                            } else if (value.$$typeof === REACT_PROVIDER_TYPE) {
                                var providerKey = value._context._globalName;
                                var writtenProviders = request.writtenProviders;
                                var providerId = writtenProviders.get(key);
                                if (providerId === undefined) {
                                    request.pendingChunks++;
                                    providerId = request.nextChunkId++;
                                    writtenProviders.set(providerKey, providerId);
                                    emitProviderChunk(request, providerId, providerKey);
                                }
                                return serializeByValueID(providerId);
                            } else if (value === POP) {
                                popProvider();
                                {
                                    insideContextProps = null;
                                    isInsideContextValue = false;
                                }
                                return undefined;
                            }
                            {
                                if (value !== null && !isArray(value)) {
                                    if (objectName(value) !== 'Object') {
                                        error('Only plain objects can be passed to Client Components from Server Components. ' + '%s objects are not supported.%s', objectName(value), describeObjectForErrorMessage(parent, key));
                                    } else if (!isSimpleObject(value)) {
                                        error('Only plain objects can be passed to Client Components from Server Components. ' + 'Classes or other objects with methods are not supported.%s', describeObjectForErrorMessage(parent, key));
                                    } else if (Object.getOwnPropertySymbols) {
                                        var symbols = Object.getOwnPropertySymbols(value);
                                        if (symbols.length > 0) {
                                            error('Only plain objects can be passed to Client Components from Server Components. ' + 'Objects with symbol properties like %s are not supported.%s', symbols[0].description, describeObjectForErrorMessage(parent, key));
                                        }
                                    }
                                }
                            }
                            return value;
                        }
                        if (typeof value === 'string') {
                            return escapeStringValue(value);
                        }
                        if (typeof value === 'boolean' || typeof value === 'number' || typeof value === 'undefined') {
                            return value;
                        }
                        if (typeof value === 'function') {
                            if (isModuleReference(value)) {
                                return serializeModuleReference(request, parent, key, value);
                            }
                            if (/^on[A-Z]/.test(key)) {
                                throw new Error('Event handlers cannot be passed to Client Component props.' + describeObjectForErrorMessage(parent, key) + '\nIf you need interactivity, consider converting part of this to a Client Component.');
                            } else {
                                throw new Error('Functions cannot be passed directly to Client Components ' + "because they're not serializable." + describeObjectForErrorMessage(parent, key));
                            }
                        }
                        if (typeof value === 'symbol') {
                            var writtenSymbols = request.writtenSymbols;
                            var existingId = writtenSymbols.get(value);
                            if (existingId !== undefined) {
                                return serializeByValueID(existingId);
                            }
                            var name = value.description;
                            if (Symbol.for(name) !== value) {
                                throw new Error('Only global symbols received from Symbol.for(...) can be passed to Client Components. ' + ("The symbol Symbol.for(" + value.description + ") cannot be found among global symbols.") + describeObjectForErrorMessage(parent, key));
                            }
                            request.pendingChunks++;
                            var symbolId = request.nextChunkId++;
                            emitSymbolChunk(request, symbolId, name);
                            writtenSymbols.set(value, symbolId);
                            return serializeByValueID(symbolId);
                        }
                        if (typeof value === 'bigint') {
                            throw new Error("BigInt (" + value + ") is not yet supported in Client Component props." + describeObjectForErrorMessage(parent, key));
                        }
                        throw new Error("Type " + typeof value + " is not supported in Client Component props." + describeObjectForErrorMessage(parent, key));
                    }
                    function logRecoverableError(request, error) {
                        var onError = request.onError;
                        var errorDigest = onError(error);
                        if (errorDigest != null && typeof errorDigest !== 'string') {
                            throw new Error("onError returned something with a type other than \"string\". onError should return a string and may return null or undefined but must not return anything else. It received something of type \"" + typeof errorDigest + "\" instead");
                        }
                        return errorDigest || '';
                    }
                    function getErrorMessageAndStackDev(error) {
                        {
                            var message;
                            var stack = '';
                            try {
                                if (error instanceof Error) {
                                    message = String(error.message);
                                    stack = String(error.stack);
                                } else {
                                    message = 'Error: ' + error;
                                }
                            } catch (x) {
                                message = 'An error occurred but serializing the error message failed.';
                            }
                            return {
                                message: message,
                                stack: stack
                            };
                        }
                    }
                    function fatalError(request, error) {
                        if (request.destination !== null) {
                            request.status = CLOSED;
                            closeWithError(request.destination, error);
                        } else {
                            request.status = CLOSING;
                            request.fatalError = error;
                        }
                    }
                    function emitErrorChunkProd(request, id, digest) {
                        var processedChunk = processErrorChunkProd(request, id, digest);
                        request.completedErrorChunks.push(processedChunk);
                    }
                    function emitErrorChunkDev(request, id, digest, message, stack) {
                        var processedChunk = processErrorChunkDev(request, id, digest, message, stack);
                        request.completedErrorChunks.push(processedChunk);
                    }
                    function emitModuleChunk(request, id, moduleMetaData) {
                        var processedChunk = processModuleChunk(request, id, moduleMetaData);
                        request.completedModuleChunks.push(processedChunk);
                    }
                    function emitSymbolChunk(request, id, name) {
                        var processedChunk = processSymbolChunk(request, id, name);
                        request.completedModuleChunks.push(processedChunk);
                    }
                    function emitProviderChunk(request, id, contextName) {
                        var processedChunk = processProviderChunk(request, id, contextName);
                        request.completedJSONChunks.push(processedChunk);
                    }
                    function retryTask(request, task) {
                        if (task.status !== PENDING) {
                            return;
                        }
                        switchContext(task.context);
                        try {
                            var _value5 = task.model;
                            if (typeof _value5 === 'object' && _value5 !== null && _value5.$$typeof === REACT_ELEMENT_TYPE) {
                                var element = _value5;
                                var prevThenableState = task.thenableState;
                                task.model = _value5;
                                _value5 = attemptResolveElement(element.type, element.key, element.ref, element.props, prevThenableState);
                                task.thenableState = null;
                                while(typeof _value5 === 'object' && _value5 !== null && _value5.$$typeof === REACT_ELEMENT_TYPE){
                                    var nextElement = _value5;
                                    task.model = _value5;
                                    _value5 = attemptResolveElement(nextElement.type, nextElement.key, nextElement.ref, nextElement.props, null);
                                }
                            }
                            var processedChunk = processModelChunk(request, task.id, _value5);
                            request.completedJSONChunks.push(processedChunk);
                            request.abortableTasks.delete(task);
                            task.status = COMPLETED;
                        } catch (x) {
                            if (typeof x === 'object' && x !== null && typeof x.then === 'function') {
                                var ping = task.ping;
                                x.then(ping, ping);
                                task.thenableState = getThenableStateAfterSuspending();
                                return;
                            } else {
                                request.abortableTasks.delete(task);
                                task.status = ERRORED;
                                var digest = logRecoverableError(request, x);
                                {
                                    var _getErrorMessageAndSt3 = getErrorMessageAndStackDev(x), message = _getErrorMessageAndSt3.message, stack = _getErrorMessageAndSt3.stack;
                                    emitErrorChunkDev(request, task.id, digest, message, stack);
                                }
                            }
                        }
                    }
                    function performWork(request) {
                        var prevDispatcher = ReactCurrentDispatcher.current;
                        var prevCache = getCurrentCache();
                        ReactCurrentDispatcher.current = HooksDispatcher;
                        setCurrentCache(request.cache);
                        prepareToUseHooksForRequest(request);
                        try {
                            var pingedTasks = request.pingedTasks;
                            request.pingedTasks = [];
                            for(var i = 0; i < pingedTasks.length; i++){
                                var task = pingedTasks[i];
                                retryTask(request, task);
                            }
                            if (request.destination !== null) {
                                flushCompletedChunks(request, request.destination);
                            }
                        } catch (error) {
                            logRecoverableError(request, error);
                            fatalError(request, error);
                        } finally{
                            ReactCurrentDispatcher.current = prevDispatcher;
                            setCurrentCache(prevCache);
                            resetHooksForRequest();
                        }
                    }
                    function abortTask(task, request, errorId) {
                        task.status = ABORTED;
                        var ref = serializeByValueID(errorId);
                        var processedChunk = processReferenceChunk(request, task.id, ref);
                        request.completedErrorChunks.push(processedChunk);
                    }
                    function flushCompletedChunks(request, destination) {
                        beginWriting();
                        try {
                            var moduleChunks = request.completedModuleChunks;
                            var i = 0;
                            for(; i < moduleChunks.length; i++){
                                request.pendingChunks--;
                                var chunk = moduleChunks[i];
                                var keepWriting = writeChunkAndReturn(destination, chunk);
                                if (!keepWriting) {
                                    request.destination = null;
                                    i++;
                                    break;
                                }
                            }
                            moduleChunks.splice(0, i);
                            var jsonChunks = request.completedJSONChunks;
                            i = 0;
                            for(; i < jsonChunks.length; i++){
                                request.pendingChunks--;
                                var _chunk = jsonChunks[i];
                                var _keepWriting = writeChunkAndReturn(destination, _chunk);
                                if (!_keepWriting) {
                                    request.destination = null;
                                    i++;
                                    break;
                                }
                            }
                            jsonChunks.splice(0, i);
                            var errorChunks = request.completedErrorChunks;
                            i = 0;
                            for(; i < errorChunks.length; i++){
                                request.pendingChunks--;
                                var _chunk2 = errorChunks[i];
                                var _keepWriting2 = writeChunkAndReturn(destination, _chunk2);
                                if (!_keepWriting2) {
                                    request.destination = null;
                                    i++;
                                    break;
                                }
                            }
                            errorChunks.splice(0, i);
                        } finally{
                            completeWriting(destination);
                        }
                        if (request.pendingChunks === 0) {
                            close(destination);
                        }
                    }
                    function startWork(request) {
                        if (supportsRequestStorage) {
                            scheduleWork(function() {
                                return requestStorage.run(request.cache, performWork, request);
                            });
                        } else {
                            scheduleWork(function() {
                                return performWork(request);
                            });
                        }
                    }
                    function startFlowing(request, destination) {
                        if (request.status === CLOSING) {
                            request.status = CLOSED;
                            closeWithError(destination, request.fatalError);
                            return;
                        }
                        if (request.status === CLOSED) {
                            return;
                        }
                        if (request.destination !== null) {
                            return;
                        }
                        request.destination = destination;
                        try {
                            flushCompletedChunks(request, destination);
                        } catch (error) {
                            logRecoverableError(request, error);
                            fatalError(request, error);
                        }
                    }
                    function abort(request, reason) {
                        try {
                            var abortableTasks = request.abortableTasks;
                            if (abortableTasks.size > 0) {
                                var _error = reason === undefined ? new Error('The render was aborted by the server without a reason.') : reason;
                                var digest = logRecoverableError(request, _error);
                                request.pendingChunks++;
                                var errorId = request.nextChunkId++;
                                if (true) {
                                    var _getErrorMessageAndSt4 = getErrorMessageAndStackDev(_error), message = _getErrorMessageAndSt4.message, stack = _getErrorMessageAndSt4.stack;
                                    emitErrorChunkDev(request, errorId, digest, message, stack);
                                } else {}
                                abortableTasks.forEach(function(task) {
                                    return abortTask(task, request, errorId);
                                });
                                abortableTasks.clear();
                            }
                            if (request.destination !== null) {
                                flushCompletedChunks(request, request.destination);
                            }
                        } catch (error) {
                            logRecoverableError(request, error);
                            fatalError(request, error);
                        }
                    }
                    function importServerContexts(contexts) {
                        if (contexts) {
                            var prevContext = getActiveContext();
                            switchContext(rootContextSnapshot);
                            for(var i = 0; i < contexts.length; i++){
                                var _contexts$i = contexts[i], name = _contexts$i[0], _value6 = _contexts$i[1];
                                var context = getOrCreateServerContext(name);
                                pushProvider(context, _value6);
                            }
                            var importedContext = getActiveContext();
                            switchContext(prevContext);
                            return importedContext;
                        }
                        return rootContextSnapshot;
                    }
                    function renderToReadableStream(model, webpackMap, options) {
                        var request = createRequest(model, webpackMap, options ? options.onError : undefined, options ? options.context : undefined, options ? options.identifierPrefix : undefined);
                        if (options && options.signal) {
                            var signal = options.signal;
                            if (signal.aborted) {
                                abort(request, signal.reason);
                            } else {
                                var listener = function() {
                                    abort(request, signal.reason);
                                    signal.removeEventListener('abort', listener);
                                };
                                signal.addEventListener('abort', listener);
                            }
                        }
                        var stream = new ReadableStream({
                            type: 'bytes',
                            start: function(controller) {
                                startWork(request);
                            },
                            pull: function(controller) {
                                startFlowing(request, controller);
                            },
                            cancel: function(reason) {}
                        }, {
                            highWaterMark: 0
                        });
                        return stream;
                    }
                    exports.renderToReadableStream = renderToReadableStream;
                })();
            }
        },
        630: (__unused_webpack_module, exports, __nccwpck_require__)=>{
            var ba = __nccwpck_require__(522);
            var e = "function" === typeof AsyncLocalStorage, ca = e ? new AsyncLocalStorage : null, m = null, n = 0;
            function p(a, b) {
                if (0 !== b.length) if (512 < b.length) 0 < n && (a.enqueue(new Uint8Array(m.buffer, 0, n)), m = new Uint8Array(512), n = 0), a.enqueue(b);
                else {
                    var d = m.length - n;
                    d < b.length && (0 === d ? a.enqueue(m) : (m.set(b.subarray(0, d), n), a.enqueue(m), b = b.subarray(d)), m = new Uint8Array(512), n = 0);
                    m.set(b, n);
                    n += b.length;
                }
                return !0;
            }
            var q = new TextEncoder;
            function r(a) {
                return q.encode(a);
            }
            function da(a, b) {
                "function" === typeof a.error ? a.error(b) : a.close();
            }
            var t = JSON.stringify, v = Symbol.for("react.module.reference"), w = Symbol.for("react.element"), ea = Symbol.for("react.fragment"), fa = Symbol.for("react.provider"), ha = Symbol.for("react.server_context"), ia = Symbol.for("react.forward_ref"), ja = Symbol.for("react.suspense"), ka = Symbol.for("react.suspense_list"), la = Symbol.for("react.memo"), x = Symbol.for("react.lazy"), ma = Symbol.for("react.default_value"), na = Symbol.for("react.memo_cache_sentinel");
            function y(a, b, d, c, f, g, h) {
                this.acceptsBooleans = 2 === b || 3 === b || 4 === b;
                this.attributeName = c;
                this.attributeNamespace = f;
                this.mustUseProperty = d;
                this.propertyName = a;
                this.type = b;
                this.sanitizeURL = g;
                this.removeEmptyString = h;
            }
            "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a) {
                new y(a, 0, !1, a, null, !1, !1);
            });
            [
                [
                    "acceptCharset",
                    "accept-charset"
                ],
                [
                    "className",
                    "class"
                ],
                [
                    "htmlFor",
                    "for"
                ],
                [
                    "httpEquiv",
                    "http-equiv"
                ]
            ].forEach(function(a) {
                new y(a[0], 1, !1, a[1], null, !1, !1);
            });
            [
                "contentEditable",
                "draggable",
                "spellCheck",
                "value"
            ].forEach(function(a) {
                new y(a, 2, !1, a.toLowerCase(), null, !1, !1);
            });
            [
                "autoReverse",
                "externalResourcesRequired",
                "focusable",
                "preserveAlpha"
            ].forEach(function(a) {
                new y(a, 2, !1, a, null, !1, !1);
            });
            "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a) {
                new y(a, 3, !1, a.toLowerCase(), null, !1, !1);
            });
            [
                "checked",
                "multiple",
                "muted",
                "selected"
            ].forEach(function(a) {
                new y(a, 3, !0, a, null, !1, !1);
            });
            [
                "capture",
                "download"
            ].forEach(function(a) {
                new y(a, 4, !1, a, null, !1, !1);
            });
            [
                "cols",
                "rows",
                "size",
                "span"
            ].forEach(function(a) {
                new y(a, 6, !1, a, null, !1, !1);
            });
            [
                "rowSpan",
                "start"
            ].forEach(function(a) {
                new y(a, 5, !1, a.toLowerCase(), null, !1, !1);
            });
            var A = /[\-:]([a-z])/g;
            function B(a) {
                return a[1].toUpperCase();
            }
            "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a) {
                var b = a.replace(A, B);
                new y(b, 1, !1, a, null, !1, !1);
            });
            "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a) {
                var b = a.replace(A, B);
                new y(b, 1, !1, a, "http://www.w3.org/1999/xlink", !1, !1);
            });
            [
                "xml:base",
                "xml:lang",
                "xml:space"
            ].forEach(function(a) {
                var b = a.replace(A, B);
                new y(b, 1, !1, a, "http://www.w3.org/XML/1998/namespace", !1, !1);
            });
            [
                "tabIndex",
                "crossOrigin"
            ].forEach(function(a) {
                new y(a, 1, !1, a.toLowerCase(), null, !1, !1);
            });
            new y("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1);
            [
                "src",
                "href",
                "action",
                "formAction"
            ].forEach(function(a) {
                new y(a, 1, !1, a.toLowerCase(), null, !0, !0);
            });
            var C = {
                animationIterationCount: !0,
                aspectRatio: !0,
                borderImageOutset: !0,
                borderImageSlice: !0,
                borderImageWidth: !0,
                boxFlex: !0,
                boxFlexGroup: !0,
                boxOrdinalGroup: !0,
                columnCount: !0,
                columns: !0,
                flex: !0,
                flexGrow: !0,
                flexPositive: !0,
                flexShrink: !0,
                flexNegative: !0,
                flexOrder: !0,
                gridArea: !0,
                gridRow: !0,
                gridRowEnd: !0,
                gridRowSpan: !0,
                gridRowStart: !0,
                gridColumn: !0,
                gridColumnEnd: !0,
                gridColumnSpan: !0,
                gridColumnStart: !0,
                fontWeight: !0,
                lineClamp: !0,
                lineHeight: !0,
                opacity: !0,
                order: !0,
                orphans: !0,
                tabSize: !0,
                widows: !0,
                zIndex: !0,
                zoom: !0,
                fillOpacity: !0,
                floodOpacity: !0,
                stopOpacity: !0,
                strokeDasharray: !0,
                strokeDashoffset: !0,
                strokeMiterlimit: !0,
                strokeOpacity: !0,
                strokeWidth: !0
            }, oa = [
                "Webkit",
                "ms",
                "Moz",
                "O"
            ];
            Object.keys(C).forEach(function(a) {
                oa.forEach(function(b) {
                    b = b + a.charAt(0).toUpperCase() + a.substring(1);
                    C[b] = C[a];
                });
            });
            var pa = Array.isArray;
            r("<script>");
            r("\x3c/script>");
            r('<script src="');
            r('<script type="module" src="');
            r('" integrity="');
            r('" async="">\x3c/script>');
            r("\x3c!-- --\x3e");
            r(' style="');
            r(":");
            r(";");
            r(" ");
            r('="');
            r('"');
            r('=""');
            r(">");
            r("/>");
            r(' selected=""');
            r("\n");
            r("<!DOCTYPE html>");
            r("</");
            r(">");
            r('<template id="');
            r('"></template>');
            r("\x3c!--$--\x3e");
            r('\x3c!--$?--\x3e<template id="');
            r('"></template>');
            r("\x3c!--$!--\x3e");
            r("\x3c!--/$--\x3e");
            r("<template");
            r('"');
            r(' data-dgst="');
            r(' data-msg="');
            r(' data-stck="');
            r("></template>");
            r('<div hidden id="');
            r('">');
            r("</div>");
            r('<svg aria-hidden="true" style="display:none" id="');
            r('">');
            r("</svg>");
            r('<math aria-hidden="true" style="display:none" id="');
            r('">');
            r("</math>");
            r('<table hidden id="');
            r('">');
            r("</table>");
            r('<table hidden><tbody id="');
            r('">');
            r("</tbody></table>");
            r('<table hidden><tr id="');
            r('">');
            r("</tr></table>");
            r('<table hidden><colgroup id="');
            r('">');
            r("</colgroup></table>");
            r('$RS=function(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)};;$RS("');
            r('$RS("');
            r('","');
            r('")\x3c/script>');
            r('$RC=function(b,c,e){c=document.getElementById(c);c.parentNode.removeChild(c);var a=document.getElementById(b);if(a){b=a.previousSibling;if(e)b.data="$!",a.setAttribute("data-dgst",e);else{e=b.parentNode;a=b.nextSibling;var f=0;do{if(a&&8===a.nodeType){var d=a.data;if("/$"===d)if(0===f)break;else f--;else"$"!==d&&"$?"!==d&&"$!"!==d||f++}d=a.nextSibling;e.removeChild(a);a=d}while(a);for(;c.firstChild;)e.insertBefore(c.firstChild,a);b.data="$"}b._reactRetry&&b._reactRetry()}};;$RC("');
            r('$RC("');
            r('$RC=function(b,c,e){c=document.getElementById(c);c.parentNode.removeChild(c);var a=document.getElementById(b);if(a){b=a.previousSibling;if(e)b.data="$!",a.setAttribute("data-dgst",e);else{e=b.parentNode;a=b.nextSibling;var f=0;do{if(a&&8===a.nodeType){var d=a.data;if("/$"===d)if(0===f)break;else f--;else"$"!==d&&"$?"!==d&&"$!"!==d||f++}d=a.nextSibling;e.removeChild(a);a=d}while(a);for(;c.firstChild;)e.insertBefore(c.firstChild,a);b.data="$"}b._reactRetry&&b._reactRetry()}};;$RM=new Map;\n$RR=function(p,q,v){function r(l){this.s=l}for(var t=$RC,u=$RM,m=new Map,n=document,g,e,f=n.querySelectorAll("link[data-precedence],style[data-precedence]"),d=0;e=f[d++];)m.set(e.dataset.precedence,g=e);e=0;f=[];for(var c,h,b,a;c=v[e++];){var k=0;h=c[k++];if(b=u.get(h))"l"!==b.s&&f.push(b);else{a=n.createElement("link");a.href=h;a.rel="stylesheet";for(a.dataset.precedence=d=c[k++];b=c[k++];)a.setAttribute(b,c[k++]);b=a._p=new Promise(function(l,w){a.onload=l;a.onerror=w});b.then(r.bind(b,\n"l"),r.bind(b,"e"));u.set(h,b);f.push(b);c=m.get(d)||g;c===g&&(g=a);m.set(d,a);c?c.parentNode.insertBefore(a,c.nextSibling):(d=n.head,d.insertBefore(a,d.firstChild))}}Promise.all(f).then(t.bind(null,p,q,""),t.bind(null,p,q,"Resource failed to load"))};;$RR("');
            r('$RM=new Map;\n$RR=function(p,q,v){function r(l){this.s=l}for(var t=$RC,u=$RM,m=new Map,n=document,g,e,f=n.querySelectorAll("link[data-precedence],style[data-precedence]"),d=0;e=f[d++];)m.set(e.dataset.precedence,g=e);e=0;f=[];for(var c,h,b,a;c=v[e++];){var k=0;h=c[k++];if(b=u.get(h))"l"!==b.s&&f.push(b);else{a=n.createElement("link");a.href=h;a.rel="stylesheet";for(a.dataset.precedence=d=c[k++];b=c[k++];)a.setAttribute(b,c[k++]);b=a._p=new Promise(function(l,w){a.onload=l;a.onerror=w});b.then(r.bind(b,\n"l"),r.bind(b,"e"));u.set(h,b);f.push(b);c=m.get(d)||g;c===g&&(g=a);m.set(d,a);c?c.parentNode.insertBefore(a,c.nextSibling):(d=n.head,d.insertBefore(a,d.firstChild))}}Promise.all(f).then(t.bind(null,p,q,""),t.bind(null,p,q,"Resource failed to load"))};;$RR("');
            r('$RR("');
            r('","');
            r('",');
            r('"');
            r(")\x3c/script>");
            r('$RX=function(b,c,d,e){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),b._reactRetry&&b._reactRetry())};;$RX("');
            r('$RX("');
            r('"');
            r(")\x3c/script>");
            r(",");
            r('<style data-precedence="');
            r('"></style>');
            r("[");
            r(",[");
            r(",");
            r("]");
            var D = null;
            function E(a, b) {
                if (a !== b) {
                    a.context._currentValue = a.parentValue;
                    a = a.parent;
                    var d = b.parent;
                    if (null === a) {
                        if (null !== d) throw Error("The stacks must reach the root at the same time. This is a bug in React.");
                    } else {
                        if (null === d) throw Error("The stacks must reach the root at the same time. This is a bug in React.");
                        E(a, d);
                        b.context._currentValue = b.value;
                    }
                }
            }
            function qa(a) {
                a.context._currentValue = a.parentValue;
                a = a.parent;
                null !== a && qa(a);
            }
            function ra(a) {
                var b = a.parent;
                null !== b && ra(b);
                a.context._currentValue = a.value;
            }
            function sa(a, b) {
                a.context._currentValue = a.parentValue;
                a = a.parent;
                if (null === a) throw Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
                a.depth === b.depth ? E(a, b) : sa(a, b);
            }
            function ta(a, b) {
                var d = b.parent;
                if (null === d) throw Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
                a.depth === d.depth ? E(a, d) : ta(a, d);
                b.context._currentValue = b.value;
            }
            function F(a) {
                var b = D;
                b !== a && (null === b ? ra(a) : null === a ? qa(b) : b.depth === a.depth ? E(b, a) : b.depth > a.depth ? sa(b, a) : ta(b, a), D = a);
            }
            function ua(a, b) {
                var d = a._currentValue;
                a._currentValue = b;
                var c = D;
                return D = a = {
                    parent: c,
                    depth: null === c ? 0 : c.depth + 1,
                    context: a,
                    parentValue: d,
                    value: b
                };
            }
            function va() {}
            function wa(a, b, d) {
                d = a[d];
                void 0 === d ? a.push(b) : d !== b && (b.then(va, va), b = d);
                switch(b.status){
                    case "fulfilled":
                        return b.value;
                    case "rejected":
                        throw b.reason;
                    default:
                        throw "string" !== typeof b.status && (a = b, a.status = "pending", a.then(function(a) {
                            if ("pending" === b.status) {
                                var c = b;
                                c.status = "fulfilled";
                                c.value = a;
                            }
                        }, function(a) {
                            if ("pending" === b.status) {
                                var c = b;
                                c.status = "rejected";
                                c.reason = a;
                            }
                        })), b;
                }
            }
            var G = null, H = 0, I = null;
            function xa() {
                var a = I;
                I = null;
                return a;
            }
            function ya(a) {
                return a._currentValue;
            }
            var Da = {
                useMemo: function(a) {
                    return a();
                },
                useCallback: function(a) {
                    return a;
                },
                useDebugValue: function() {},
                useDeferredValue: J,
                useTransition: J,
                readContext: ya,
                useContext: ya,
                useReducer: J,
                useRef: J,
                useState: J,
                useInsertionEffect: J,
                useLayoutEffect: J,
                useImperativeHandle: J,
                useEffect: J,
                useId: za,
                useMutableSource: J,
                useSyncExternalStore: J,
                useCacheRefresh: function() {
                    return Ba;
                },
                useMemoCache: function(a) {
                    for(var b = Array(a), d = 0; d < a; d++)b[d] = na;
                    return b;
                },
                use: Ca
            };
            function J() {
                throw Error("This Hook is not supported in Server Components.");
            }
            function Ba() {
                throw Error("Refreshing the cache is not supported in Server Components.");
            }
            function za() {
                if (null === G) throw Error("useId can only be used while React is rendering");
                var a = G.identifierCount++;
                return ":" + G.identifierPrefix + "S" + a.toString(32) + ":";
            }
            function Ca(a) {
                if (null !== a && "object" === typeof a) {
                    if ("function" === typeof a.then) {
                        var b = H;
                        H += 1;
                        null === I && (I = []);
                        return wa(I, a, b);
                    }
                    if (a.$$typeof === ha) return a._currentValue;
                }
                throw Error("An unsupported type was passed to use(): " + String(a));
            }
            function K() {
                return (new AbortController).signal;
            }
            function Ea() {
                if (L) return L;
                if (e) {
                    var a = ca.getStore();
                    if (a) return a;
                }
                return new Map;
            }
            var Fa = {
                getCacheSignal: function() {
                    var a = Ea(), b = a.get(K);
                    void 0 === b && (b = K(), a.set(K, b));
                    return b;
                },
                getCacheForType: function(a) {
                    var b = Ea(), d = b.get(a);
                    void 0 === d && (d = a(), b.set(a, d));
                    return d;
                }
            }, L = null, M = ba.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, N = M.ContextRegistry, O = M.ReactCurrentDispatcher, P = M.ReactCurrentCache;
            function Ga(a) {
                console.error(a);
            }
            function Ha(a, b, d, c, f) {
                if (null !== P.current && P.current !== Fa) throw Error("Currently React only supports one RSC renderer at a time.");
                P.current = Fa;
                var g = new Set, h = [], k = {
                    status: 0,
                    fatalError: null,
                    destination: null,
                    bundlerConfig: b,
                    cache: new Map,
                    nextChunkId: 0,
                    pendingChunks: 0,
                    abortableTasks: g,
                    pingedTasks: h,
                    completedModuleChunks: [],
                    completedJSONChunks: [],
                    completedErrorChunks: [],
                    writtenSymbols: new Map,
                    writtenModules: new Map,
                    writtenProviders: new Map,
                    identifierPrefix: f || "",
                    identifierCount: 1,
                    onError: void 0 === d ? Ga : d,
                    toJSON: function(a, b) {
                        return Ia(k, this, a, b);
                    }
                };
                k.pendingChunks++;
                b = Ja(c);
                a = Ka(k, a, b, g);
                h.push(a);
                return k;
            }
            var La = {};
            function Ma(a) {
                if ("fulfilled" === a.status) return a.value;
                if ("rejected" === a.status) throw a.reason;
                throw a;
            }
            function Na(a) {
                switch(a.status){
                    case "fulfilled":
                    case "rejected":
                        break;
                    default:
                        "string" !== typeof a.status && (a.status = "pending", a.then(function(b) {
                            "pending" === a.status && (a.status = "fulfilled", a.value = b);
                        }, function(b) {
                            "pending" === a.status && (a.status = "rejected", a.reason = b);
                        }));
                }
                return {
                    $$typeof: x,
                    _payload: a,
                    _init: Ma
                };
            }
            function Q(a, b, d, c, f) {
                if (null !== d && void 0 !== d) throw Error("Refs cannot be used in Server Components, nor passed to Client Components.");
                if ("function" === typeof a) {
                    if (a.$$typeof === v) return [
                        w,
                        a,
                        b,
                        c
                    ];
                    H = 0;
                    I = f;
                    c = a(c);
                    return "object" === typeof c && null !== c && "function" === typeof c.then ? Na(c) : c;
                }
                if ("string" === typeof a) return [
                    w,
                    a,
                    b,
                    c
                ];
                if ("symbol" === typeof a) return a === ea ? c.children : [
                    w,
                    a,
                    b,
                    c
                ];
                if (null != a && "object" === typeof a) {
                    if (a.$$typeof === v) return [
                        w,
                        a,
                        b,
                        c
                    ];
                    switch(a.$$typeof){
                        case x:
                            var g = a._init;
                            a = g(a._payload);
                            return Q(a, b, d, c, f);
                        case ia:
                            return b = a.render, H = 0, I = f, b(c, void 0);
                        case la:
                            return Q(a.type, b, d, c, f);
                        case fa:
                            return ua(a._context, c.value), [
                                w,
                                a,
                                b,
                                {
                                    value: c.value,
                                    children: c.children,
                                    __pop: La
                                }
                            ];
                    }
                }
                throw Error("Unsupported Server Component type: " + R(a));
            }
            function Ka(a, b, d, c) {
                var f = {
                    id: a.nextChunkId++,
                    status: 0,
                    model: b,
                    context: d,
                    ping: function() {
                        var b = a.pingedTasks;
                        b.push(f);
                        1 === b.length && S(a);
                    },
                    thenableState: null
                };
                c.add(f);
                return f;
            }
            function Oa(a, b, d, c) {
                var f = c.filepath + "#" + c.name + (c.async ? "#async" : ""), g = a.writtenModules, h = g.get(f);
                if (void 0 !== h) return b[0] === w && "1" === d ? "@" + h.toString(16) : "$" + h.toString(16);
                try {
                    var k = a.bundlerConfig[c.filepath][c.name];
                    var l = c.async ? {
                        id: k.id,
                        chunks: k.chunks,
                        name: k.name,
                        async: !0
                    } : k;
                    a.pendingChunks++;
                    var z = a.nextChunkId++, X = t(l), Y = "M" + z.toString(16) + ":" + X + "\n";
                    var Z = q.encode(Y);
                    a.completedModuleChunks.push(Z);
                    g.set(f, z);
                    return b[0] === w && "1" === d ? "@" + z.toString(16) : "$" + z.toString(16);
                } catch (aa) {
                    return a.pendingChunks++, b = a.nextChunkId++, d = T(a, aa), U(a, b, d), "$" + b.toString(16);
                }
            }
            function Pa(a) {
                return Object.prototype.toString.call(a).replace(/^\[object (.*)\]$/, function(a, d) {
                    return d;
                });
            }
            function R(a) {
                switch(typeof a){
                    case "string":
                        return JSON.stringify(10 >= a.length ? a : a.substr(0, 10) + "...");
                    case "object":
                        if (pa(a)) return "[...]";
                        a = Pa(a);
                        return "Object" === a ? "{...}" : a;
                    case "function":
                        return "function";
                    default:
                        return String(a);
                }
            }
            function V(a) {
                if ("string" === typeof a) return a;
                switch(a){
                    case ja:
                        return "Suspense";
                    case ka:
                        return "SuspenseList";
                }
                if ("object" === typeof a) switch(a.$$typeof){
                    case ia:
                        return V(a.render);
                    case la:
                        return V(a.type);
                    case x:
                        var b = a._payload;
                        a = a._init;
                        try {
                            return V(a(b));
                        } catch (d) {}
                }
                return "";
            }
            function W(a, b) {
                var d = Pa(a);
                if ("Object" !== d && "Array" !== d) return d;
                d = -1;
                var c = 0;
                if (pa(a)) {
                    var f = "[";
                    for(var g = 0; g < a.length; g++){
                        0 < g && (f += ", ");
                        var h = a[g];
                        h = "object" === typeof h && null !== h ? W(h) : R(h);
                        "" + g === b ? (d = f.length, c = h.length, f += h) : f = 10 > h.length && 40 > f.length + h.length ? f + h : f + "...";
                    }
                    f += "]";
                } else if (a.$$typeof === w) f = "<" + V(a.type) + "/>";
                else {
                    f = "{";
                    g = Object.keys(a);
                    for(h = 0; h < g.length; h++){
                        0 < h && (f += ", ");
                        var k = g[h], l = JSON.stringify(k);
                        f += ('"' + k + '"' === l ? k : l) + ": ";
                        l = a[k];
                        l = "object" === typeof l && null !== l ? W(l) : R(l);
                        k === b ? (d = f.length, c = l.length, f += l) : f = 10 > l.length && 40 > f.length + l.length ? f + l : f + "...";
                    }
                    f += "}";
                }
                return void 0 === b ? f : -1 < d && 0 < c ? (a = " ".repeat(d) + "^".repeat(c), "\n  " + f + "\n  " + a) : "\n  " + f;
            }
            function Ia(a, b, d, c) {
                switch(c){
                    case w:
                        return "$";
                }
                for(; "object" === typeof c && null !== c && (c.$$typeof === w || c.$$typeof === x);)try {
                    switch(c.$$typeof){
                        case w:
                            var f = c;
                            c = Q(f.type, f.key, f.ref, f.props, null);
                            break;
                        case x:
                            var g = c._init;
                            c = g(c._payload);
                    }
                } catch (h) {
                    if ("object" === typeof h && null !== h && "function" === typeof h.then) return a.pendingChunks++, a = Ka(a, c, D, a.abortableTasks), c = a.ping, h.then(c, c), a.thenableState = xa(), "@" + a.id.toString(16);
                    a.pendingChunks++;
                    c = a.nextChunkId++;
                    d = T(a, h);
                    U(a, c, d);
                    return "@" + c.toString(16);
                }
                if (null === c) return null;
                if ("object" === typeof c) {
                    if (c.$$typeof === v) return Oa(a, b, d, c);
                    if (c.$$typeof === fa) return f = c._context._globalName, b = a.writtenProviders, c = b.get(d), void 0 === c && (a.pendingChunks++, c = a.nextChunkId++, b.set(f, c), d = "P" + c.toString(16) + ":" + f + "\n", d = q.encode(d), a.completedJSONChunks.push(d)), "$" + c.toString(16);
                    if (c === La) {
                        a = D;
                        if (null === a) throw Error("Tried to pop a Context at the root of the app. This is a bug in React.");
                        c = a.parentValue;
                        a.context._currentValue = c === ma ? a.context._defaultValue : c;
                        D = a.parent;
                        return;
                    }
                    return c;
                }
                if ("string" === typeof c) return a = "$" === c[0] || "@" === c[0] ? "$" + c : c, a;
                if ("boolean" === typeof c || "number" === typeof c || "undefined" === typeof c) return c;
                if ("function" === typeof c) {
                    if (c.$$typeof === v) return Oa(a, b, d, c);
                    if (/^on[A-Z]/.test(d)) throw Error("Event handlers cannot be passed to Client Component props." + W(b, d) + "\nIf you need interactivity, consider converting part of this to a Client Component.");
                    throw Error("Functions cannot be passed directly to Client Components because they're not serializable." + W(b, d));
                }
                if ("symbol" === typeof c) {
                    f = a.writtenSymbols;
                    g = f.get(c);
                    if (void 0 !== g) return "$" + g.toString(16);
                    g = c.description;
                    if (Symbol.for(g) !== c) throw Error("Only global symbols received from Symbol.for(...) can be passed to Client Components. The symbol Symbol.for(" + (c.description + ") cannot be found among global symbols.") + W(b, d));
                    a.pendingChunks++;
                    d = a.nextChunkId++;
                    b = t(g);
                    b = "S" + d.toString(16) + ":" + b + "\n";
                    b = q.encode(b);
                    a.completedModuleChunks.push(b);
                    f.set(c, d);
                    return "$" + d.toString(16);
                }
                if ("bigint" === typeof c) throw Error("BigInt (" + c + ") is not yet supported in Client Component props." + W(b, d));
                throw Error("Type " + typeof c + " is not supported in Client Component props." + W(b, d));
            }
            function T(a, b) {
                a = a.onError;
                b = a(b);
                if (null != b && "string" !== typeof b) throw Error('onError returned something with a type other than "string". onError should return a string and may return null or undefined but must not return anything else. It received something of type "' + typeof b + '" instead');
                return b || "";
            }
            function Qa(a, b) {
                null !== a.destination ? (a.status = 2, da(a.destination, b)) : (a.status = 1, a.fatalError = b);
            }
            function U(a, b, d) {
                d = {
                    digest: d
                };
                b = "E" + b.toString(16) + ":" + t(d) + "\n";
                b = q.encode(b);
                a.completedErrorChunks.push(b);
            }
            function S(a) {
                var b = O.current, d = L;
                O.current = Da;
                L = a.cache;
                G = a;
                try {
                    var c = a.pingedTasks;
                    a.pingedTasks = [];
                    for(var f = 0; f < c.length; f++){
                        var g = c[f];
                        var h = a;
                        if (0 === g.status) {
                            F(g.context);
                            try {
                                var k = g.model;
                                if ("object" === typeof k && null !== k && k.$$typeof === w) {
                                    var l = k, z = g.thenableState;
                                    g.model = k;
                                    k = Q(l.type, l.key, l.ref, l.props, z);
                                    for(g.thenableState = null; "object" === typeof k && null !== k && k.$$typeof === w;)l = k, g.model = k, k = Q(l.type, l.key, l.ref, l.props, null);
                                }
                                var X = g.id, Y = t(k, h.toJSON), Z = "J" + X.toString(16) + ":" + Y + "\n";
                                var aa = q.encode(Z);
                                h.completedJSONChunks.push(aa);
                                h.abortableTasks.delete(g);
                                g.status = 1;
                            } catch (u) {
                                if ("object" === typeof u && null !== u && "function" === typeof u.then) {
                                    var Aa = g.ping;
                                    u.then(Aa, Aa);
                                    g.thenableState = xa();
                                } else {
                                    h.abortableTasks.delete(g);
                                    g.status = 4;
                                    var Ta = T(h, u);
                                    U(h, g.id, Ta);
                                }
                            }
                        }
                    }
                    null !== a.destination && Ra(a, a.destination);
                } catch (u) {
                    T(a, u), Qa(a, u);
                } finally{
                    O.current = b, L = d, G = null;
                }
            }
            function Ra(a, b) {
                m = new Uint8Array(512);
                n = 0;
                try {
                    for(var d = a.completedModuleChunks, c = 0; c < d.length; c++)if (a.pendingChunks--, !p(b, d[c])) {
                        a.destination = null;
                        c++;
                        break;
                    }
                    d.splice(0, c);
                    var f = a.completedJSONChunks;
                    for(c = 0; c < f.length; c++)if (a.pendingChunks--, !p(b, f[c])) {
                        a.destination = null;
                        c++;
                        break;
                    }
                    f.splice(0, c);
                    var g = a.completedErrorChunks;
                    for(c = 0; c < g.length; c++)if (a.pendingChunks--, !p(b, g[c])) {
                        a.destination = null;
                        c++;
                        break;
                    }
                    g.splice(0, c);
                } finally{
                    m && 0 < n && (b.enqueue(new Uint8Array(m.buffer, 0, n)), m = null, n = 0);
                }
                0 === a.pendingChunks && b.close();
            }
            function Sa(a, b) {
                try {
                    var d = a.abortableTasks;
                    if (0 < d.size) {
                        var c = T(a, void 0 === b ? Error("The render was aborted by the server without a reason.") : b);
                        a.pendingChunks++;
                        var f = a.nextChunkId++;
                        U(a, f, c);
                        d.forEach(function(b) {
                            b.status = 3;
                            var c = "$" + f.toString(16);
                            b = b.id;
                            c = t(c);
                            c = "J" + b.toString(16) + ":" + c + "\n";
                            c = q.encode(c);
                            a.completedErrorChunks.push(c);
                        });
                        d.clear();
                    }
                    null !== a.destination && Ra(a, a.destination);
                } catch (g) {
                    T(a, g), Qa(a, g);
                }
            }
            function Ja(a) {
                if (a) {
                    var b = D;
                    F(null);
                    for(var d = 0; d < a.length; d++){
                        var c = a[d], f = c[0];
                        c = c[1];
                        N[f] || (N[f] = ba.createServerContext(f, ma));
                        ua(N[f], c);
                    }
                    a = D;
                    F(b);
                    return a;
                }
                return null;
            }
            exports.renderToReadableStream = function(a, b, d) {
                var c = Ha(a, b, d ? d.onError : void 0, d ? d.context : void 0, d ? d.identifierPrefix : void 0);
                if (d && d.signal) {
                    var f = d.signal;
                    if (f.aborted) Sa(c, f.reason);
                    else {
                        var g = function() {
                            Sa(c, f.reason);
                            f.removeEventListener("abort", g);
                        };
                        f.addEventListener("abort", g);
                    }
                }
                return new ReadableStream({
                    type: "bytes",
                    start: function() {
                        e ? ca.run(c.cache, S, c) : S(c);
                    },
                    pull: function(a) {
                        if (1 === c.status) c.status = 2, da(a, c.fatalError);
                        else if (2 !== c.status && null === c.destination) {
                            c.destination = a;
                            try {
                                Ra(c, a);
                            } catch (k) {
                                T(c, k), Qa(c, k);
                            }
                        }
                    },
                    cancel: function() {}
                }, {
                    highWaterMark: 0
                });
            };
        },
        793: (module, __unused_webpack_exports, __nccwpck_require__)=>{
            if (process.env.NODE_ENV === 'production') {
                module.exports = __nccwpck_require__(630);
            } else {
                module.exports = __nccwpck_require__(915);
            }
        },
        522: (module)=>{
            module.exports = __turbopack_require__("[project-with-next]/node_modules/next/dist/compiled/react/react.shared-subset.js (ecmascript, rsc)");
        },
        255: (module)=>{
            module.exports = __turbopack_require__("[project-with-next]/node_modules/next/dist/compiled/react-dom/server-rendering-stub.js (ecmascript, rsc)");
        }
    };
    var __webpack_module_cache__ = {};
    function __nccwpck_require__(moduleId) {
        var cachedModule = __webpack_module_cache__[moduleId];
        if (cachedModule !== undefined) {
            return cachedModule.exports;
        }
        var module = __webpack_module_cache__[moduleId] = {
            exports: {}
        };
        var threw = true;
        try {
            __webpack_modules__[moduleId](module, module.exports, __nccwpck_require__);
            threw = false;
        } finally{
            if (threw) delete __webpack_module_cache__[moduleId];
        }
        return module.exports;
    }
    if (typeof __nccwpck_require__ !== 'undefined') __nccwpck_require__.ab = __dirname + "/";
    var __webpack_exports__ = __nccwpck_require__(793);
    module.exports = __webpack_exports__;
})();

}.call(this) }),
}]);


//# sourceMappingURL=node_modules_next_dist_compiled_5836d8.js.4e8db86c1feb89d0.map