(self.TURBOPACK = self.TURBOPACK || []).push(["chunks/ssr/_1ca90b.js", {

"[project-with-next]/.env.js (ssr)": (({ r: __turbopack_require__, x: __turbopack_external_require__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, c: __turbopack_cache__, l: __turbopack_load__, p: process, __dirname }) => (() => {

const env = process.env;

env["=C:"] = "C:\\Users\\41763\\Documents\\GitHub\\next13";
env["ALLUSERSPROFILE"] = "C:\\ProgramData";
env["APPDATA"] = "C:\\Users\\41763\\AppData\\Roaming";
env["CHROME_CRASHPAD_PIPE_NAME"] = "\\\\.\\pipe\\crashpad_1816_NTRXFRVKBDLQOUYG";
env["COLOR"] = "1";
env["COLORTERM"] = "truecolor";
env["CommonProgramFiles"] = "C:\\Program Files\\Common Files";
env["CommonProgramFiles(x86)"] = "C:\\Program Files (x86)\\Common Files";
env["CommonProgramW6432"] = "C:\\Program Files\\Common Files";
env["COMPUTERNAME"] = "RICKHOMEPC";
env["ComSpec"] = "C:\\WINDOWS\\system32\\cmd.exe";
env["DriverData"] = "C:\\Windows\\System32\\Drivers\\DriverData";
env["EDITOR"] = "notepad.exe";
env["FPS_BROWSER_APP_PROFILE_STRING"] = "Internet Explorer";
env["FPS_BROWSER_USER_PROFILE_STRING"] = "Default";
env["GameFirst"] = "C:\\Program Files (x86)\\ASUS\\GameFirst\\";
env["GIT_ASKPASS"] = "c:\\Users\\41763\\AppData\\Local\\Programs\\Microsoft VS Code\\resources\\app\\extensions\\git\\dist\\askpass.sh";
env["HOME"] = "C:\\Users\\41763";
env["HOMEDRIVE"] = "C:";
env["HOMEPATH"] = "\\Users\\41763";
env["INIT_CWD"] = "C:\\Users\\41763\\Documents\\GitHub\\next13";
env["LANG"] = "en_US.UTF-8";
env["LOCALAPPDATA"] = "C:\\Users\\41763\\AppData\\Local";
env["LOGONSERVER"] = "\\\\RICKHOMEPC";
env["NEXT_RUNTIME"] = "nodejs";
env["NODE"] = "C:\\Program Files\\nodejs\\node.exe";
env["NODE_ENV"] = "development";
env["NODE_EXE"] = "C:\\Program Files\\nodejs\\\\node.exe";
env["NPM_CLI_JS"] = "C:\\Program Files\\nodejs\\\\node_modules\\npm\\bin\\npm-cli.js";
env["npm_command"] = "run-script";
env["npm_config_cache"] = "C:\\Users\\41763\\AppData\\Local\\npm-cache";
env["npm_config_globalconfig"] = "C:\\Users\\41763\\AppData\\Roaming\\npm\\etc\\npmrc";
env["npm_config_global_prefix"] = "C:\\Users\\41763\\AppData\\Roaming\\npm";
env["npm_config_init_module"] = "C:\\Users\\41763\\.npm-init.js";
env["npm_config_local_prefix"] = "C:\\Users\\41763\\Documents\\GitHub\\next13";
env["npm_config_metrics_registry"] = "https://registry.npmjs.org/";
env["npm_config_node_gyp"] = "C:\\Program Files\\nodejs\\node_modules\\npm\\node_modules\\node-gyp\\bin\\node-gyp.js";
env["npm_config_noproxy"] = "";
env["npm_config_prefix"] = "C:\\Users\\41763\\AppData\\Roaming\\npm";
env["npm_config_userconfig"] = "C:\\Users\\41763\\.npmrc";
env["npm_config_user_agent"] = "npm/8.19.2 node/v16.18.0 win32 x64 workspaces/false";
env["npm_execpath"] = "C:\\Program Files\\nodejs\\node_modules\\npm\\bin\\npm-cli.js";
env["npm_lifecycle_event"] = "dev";
env["npm_lifecycle_script"] = "next dev --turbo";
env["npm_node_execpath"] = "C:\\Program Files\\nodejs\\node.exe";
env["npm_package_json"] = "C:\\Users\\41763\\Documents\\GitHub\\next13\\package.json";
env["npm_package_name"] = "next13";
env["npm_package_version"] = "1.0.0";
env["NPM_PREFIX_NPM_CLI_JS"] = "C:\\Users\\41763\\AppData\\Roaming\\npm\\node_modules\\npm\\bin\\npm-cli.js";
env["NUMBER_OF_PROCESSORS"] = "12";
env["OneDrive"] = "C:\\Users\\41763\\OneDrive";
env["ORIGINAL_XDG_CURRENT_DESKTOP"] = "undefined";
env["OS"] = "Windows_NT";
env["Path"] = "C:\\Users\\41763\\Documents\\GitHub\\next13\\node_modules\\.bin;C:\\Users\\41763\\Documents\\GitHub\\node_modules\\.bin;C:\\Users\\41763\\Documents\\node_modules\\.bin;C:\\Users\\41763\\node_modules\\.bin;C:\\Users\\node_modules\\.bin;C:\\node_modules\\.bin;C:\\Program Files\\nodejs\\node_modules\\npm\\node_modules\\@npmcli\\run-script\\lib\\node-gyp-bin;C:\\Program Files (x86)\\Intel\\Intel(R) Management Engine Components\\iCLS\\;C:\\Program Files\\Intel\\Intel(R) Management Engine Components\\iCLS\\;C:\\Windows\\system32;C:\\Windows;C:\\Windows\\System32\\Wbem;C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\;C:\\Windows\\System32\\OpenSSH\\;C:\\Program Files (x86)\\NVIDIA Corporation\\PhysX\\Common;C:\\Program Files\\NVIDIA Corporation\\NVIDIA NGX;C:\\Program Files\\NVIDIA Corporation\\NVIDIA NvDLISR;C:\\Program Files (x86)\\Intel\\Intel(R) Management Engine Components\\DAL;C:\\Program Files\\Intel\\Intel(R) Management Engine Components\\DAL;C:\\Program Files\\Intel\\WiFi\\bin\\;C:\\Program Files\\Common Files\\Intel\\WirelessCommon\\;C:\\WINDOWS\\system32;C:\\WINDOWS;C:\\WINDOWS\\System32\\Wbem;C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\;C:\\WINDOWS\\System32\\OpenSSH\\;C:\\Program Files\\nodejs\\;C:\\Program Files\\Git\\cmd;C:\\Users\\41763\\AppData\\Local\\Microsoft\\WindowsApps;C:\\Users\\41763\\AppData\\Local\\Programs\\Microsoft VS Code\\bin;C:\\Users\\41763\\AppData\\Roaming\\npm;C:\\Users\\41763\\AppData\\Local\\GitHubDesktop\\bin";
env["PATHEXT"] = ".COM;.EXE;.BAT;.CMD;.VBS;.VBE;.JS;.JSE;.WSF;.WSH;.MSC;.CPL";
env["PROCESSOR_ARCHITECTURE"] = "AMD64";
env["PROCESSOR_IDENTIFIER"] = "Intel64 Family 6 Model 158 Stepping 10, GenuineIntel";
env["PROCESSOR_LEVEL"] = "6";
env["PROCESSOR_REVISION"] = "9e0a";
env["ProgramData"] = "C:\\ProgramData";
env["ProgramFiles"] = "C:\\Program Files";
env["ProgramFiles(x86)"] = "C:\\Program Files (x86)";
env["ProgramW6432"] = "C:\\Program Files";
env["PROMPT"] = "$P$G";
env["PSModulePath"] = "C:\\Users\\41763\\Documents\\WindowsPowerShell\\Modules;C:\\Program Files\\WindowsPowerShell\\Modules;C:\\WINDOWS\\system32\\WindowsPowerShell\\v1.0\\Modules";
env["PUBLIC"] = "C:\\Users\\Public";
env["SESSIONNAME"] = "Console";
env["SystemDrive"] = "C:";
env["SystemRoot"] = "C:\\WINDOWS";
env["TEMP"] = "C:\\Users\\41763\\AppData\\Local\\Temp";
env["TERM_PROGRAM"] = "vscode";
env["TERM_PROGRAM_VERSION"] = "1.72.2";
env["TMP"] = "C:\\Users\\41763\\AppData\\Local\\Temp";
env["USERDOMAIN"] = "RICKHOMEPC";
env["USERDOMAIN_ROAMINGPROFILE"] = "RICKHOMEPC";
env["USERNAME"] = "41763";
env["USERPROFILE"] = "C:\\Users\\41763";
env["VSCODE_GIT_ASKPASS_EXTRA_ARGS"] = "--ms-enable-electron-run-as-node";
env["VSCODE_GIT_ASKPASS_MAIN"] = "c:\\Users\\41763\\AppData\\Local\\Programs\\Microsoft VS Code\\resources\\app\\extensions\\git\\dist\\askpass-main.js";
env["VSCODE_GIT_ASKPASS_NODE"] = "C:\\Users\\41763\\AppData\\Local\\Programs\\Microsoft VS Code\\Code.exe";
env["VSCODE_GIT_IPC_HANDLE"] = "\\\\.\\pipe\\vscode-git-2fac851933-sock";
env["windir"] = "C:\\WINDOWS";
env["__NEXT_REACT_ROOT"] = "true";

})()),
"[project-with-next]/app/entry (ecmascript, ssr)": (({ r: __turbopack_require__, x: __turbopack_external_require__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, c: __turbopack_cache__, l: __turbopack_load__, p: process, __dirname }) => (() => {

__turbopack_esm__({
    "htmlEscapeJsonString": ()=>htmlEscapeJsonString
});
var __TURBOPACK__imported__module__$5b$project$2d$with$2d$next$5d2f5b$embedded_modules$5d2f40$vercel$2f$turbopack$2d$next$2f$internal$2f$ipc$2e$ts__ = __turbopack_import__("[project-with-next]/[embedded_modules]/@vercel/turbopack-next/internal/ipc.ts (ecmascript, ssr)");
var __TURBOPACK__imported__module__$5b$project$2d$with$2d$next$5d2f$app$2f$layout$2e$js$2f$layout$2d$entry$2e$tsx$2f$with$2d$client$2d$chunks$2e$js__ = __turbopack_import__("[project-with-next]/app/layout.js/layout-entry.tsx/with-client-chunks.js (rsc)");
var __TURBOPACK__imported__module__$5b$project$2d$with$2d$next$5d2f$app$2f$page$2e$tsx$2f$layout$2d$entry$2e$tsx$2f$with$2d$client$2d$chunks$2e$js__ = __turbopack_import__("[project-with-next]/app/page.tsx/layout-entry.tsx/with-client-chunks.js (rsc)");
var __TURBOPACK__imported__module__$5b$project$2d$with$2d$next$5d2f$app$2f$page$2e$tsx$2f$next$2d$app$2d$hydrate$2e$tsx$2f$client$2d$transition$2e$js__ = __turbopack_import__("[project-with-next]/app/page.tsx/next-app-hydrate.tsx/chunk_group_files.js (ssr)");
var __TURBOPACK__imported__module__$5b$project$2d$with$2d$next$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$node$2d$polyfill$2d$fetch$2e$js__ = __turbopack_import__("[project-with-next]/node_modules/next/dist/server/node-polyfill-fetch.js (ecmascript, ssr)");
var __TURBOPACK__imported__module__$5b$project$2d$with$2d$next$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$node$2d$polyfill$2d$web$2d$streams$2e$js__ = __turbopack_import__("[project-with-next]/node_modules/next/dist/server/node-polyfill-web-streams.js (ecmascript, ssr)");
var __TURBOPACK__imported__module__$5b$project$2d$with$2d$next$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$app$2d$render$2e$js__ = __turbopack_import__("[project-with-next]/node_modules/next/dist/server/app-render.js (ecmascript, ssr)");
var __TURBOPACK__external__stream__ = __turbopack_external_require__("stream");
var __TURBOPACK__imported__module__$5b$project$2d$with$2d$next$5d2f5b$embedded_modules$5d2f40$vercel$2f$turbopack$2d$next$2f$internal$2f$http$2e$ts__ = __turbopack_import__("[project-with-next]/[embedded_modules]/@vercel/turbopack-next/internal/http.ts (ecmascript, ssr)");
"__TURBOPACK__ecmascript__hoisting__location__";
;
"TURBOPACK { transition: next-layout-entry; chunking-type: parallel }";
;
"TURBOPACK { transition: next-layout-entry; chunking-type: parallel }";
;
"TURBOPACK { transition: next-client }";
;
const LAYOUT_INFO = [
    {
        segment: "",
        module: __TURBOPACK__imported__module__$5b$project$2d$with$2d$next$5d2f$app$2f$layout$2e$js$2f$layout$2d$entry$2e$tsx$2f$with$2d$client$2d$chunks$2e$js__["default"],
        chunks: __TURBOPACK__imported__module__$5b$project$2d$with$2d$next$5d2f$app$2f$layout$2e$js$2f$layout$2d$entry$2e$tsx$2f$with$2d$client$2d$chunks$2e$js__["chunks"]
    },
    {
        segment: "",
        module: __TURBOPACK__imported__module__$5b$project$2d$with$2d$next$5d2f$app$2f$page$2e$tsx$2f$layout$2d$entry$2e$tsx$2f$with$2d$client$2d$chunks$2e$js__["default"],
        chunks: __TURBOPACK__imported__module__$5b$project$2d$with$2d$next$5d2f$app$2f$page$2e$tsx$2f$layout$2d$entry$2e$tsx$2f$with$2d$client$2d$chunks$2e$js__["chunks"]
    }
];
;
;
;
;
;
globalThis.__next_require__ = (data)=>{
    const [, , ssr_id] = JSON.parse(data);
    return __turbopack_require__(ssr_id);
};
globalThis.__next_chunk_load__ = ()=>Promise.resolve();
process.env.__NEXT_NEW_LINK_BEHAVIOR = "true";
const ipc = __TURBOPACK__imported__module__$5b$project$2d$with$2d$next$5d2f5b$embedded_modules$5d2f40$vercel$2f$turbopack$2d$next$2f$internal$2f$ipc$2e$ts__["default"];
(async ()=>{
    while(true){
        const msg = await ipc.recv();
        let renderData;
        switch(msg.type){
            case "headers":
                {
                    renderData = msg.data;
                    break;
                }
            default:
                {
                    console.error("unexpected message type", msg.type);
                    process.exit(1);
                }
        }
        const html = await runOperation(renderData);
        if (html == null) {
            throw new Error("no html returned");
        }
        ipc.send({
            type: "result",
            result: html
        });
    }
})().catch((err)=>{
    ipc.sendError(err);
});
async function runOperation(renderData) {
    const pageItem = LAYOUT_INFO[LAYOUT_INFO.length - 1];
    const pageModule = pageItem.module;
    const Page = pageModule.default;
    let tree = [
        "",
        {},
        {
            page: ()=>Page,
            layoutOrPagePath: "page.js"
        }
    ];
    for(let i = LAYOUT_INFO.length - 2; i >= 0; i--){
        const info = LAYOUT_INFO[i];
        const mod = info.module;
        if (mod) {
            const Layout = mod.default;
            tree = [
                info.segment,
                {
                    children: tree
                },
                {
                    layout: ()=>Layout,
                    layoutOrPagePath: `layout${i}.js`
                }
            ];
        } else {
            tree = [
                info.segment,
                {
                    children: tree
                },
                {
                    layoutOrPagePath: `layout${i}.js`
                }
            ];
        }
    }
    const proxyMethodsForModule = (id, css)=>({
            get (target, name, receiver) {
                return {
                    id,
                    chunks: JSON.parse(id)[1],
                    name
                };
            }
        });
    const proxyMethods = (css)=>{
        return {
            get (target, name, receiver) {
                if (name === "__ssr_module_mapping__") {
                    return manifest;
                }
                if (name === "__client_css_manifest__") {
                    return {};
                }
                return new Proxy({}, proxyMethodsForModule(name, css));
            }
        };
    };
    const manifest = new Proxy({}, proxyMethods(false));
    const serverCSSManifest = {};
    serverCSSManifest.__entry_css__ = {};
    for(let i = 0; i < LAYOUT_INFO.length - 1; i++){
        const { chunks  } = LAYOUT_INFO[i];
        const cssChunks = (chunks || []).filter((path)=>path.endsWith(".css"));
        serverCSSManifest[`layout${i}.js`] = cssChunks.map((chunk)=>JSON.stringify([
                chunk,
                [
                    chunk
                ]
            ]));
    }
    serverCSSManifest.__entry_css__ = {
        page: pageItem.chunks.filter((path)=>path.endsWith(".css")).map((chunk)=>JSON.stringify([
                chunk,
                [
                    chunk
                ]
            ]))
    };
    serverCSSManifest["page.js"] = serverCSSManifest.__entry_css__.page;
    const req = {
        url: renderData.url,
        method: renderData.method,
        headers: renderData.headers
    };
    const res = new __TURBOPACK__imported__module__$5b$project$2d$with$2d$next$5d2f5b$embedded_modules$5d2f40$vercel$2f$turbopack$2d$next$2f$internal$2f$http$2e$ts__["ServerResponseShim"](req);
    const renderOpt = {
        params: renderData.params,
        supportsDynamicHTML: true,
        dev: true,
        buildManifest: {
            polyfillFiles: [],
            rootMainFiles: LAYOUT_INFO.flatMap(({ chunks  })=>chunks || []).concat(__TURBOPACK__imported__module__$5b$project$2d$with$2d$next$5d2f$app$2f$page$2e$tsx$2f$next$2d$app$2d$hydrate$2e$tsx$2f$client$2d$transition$2e$js__["default"]).filter((path)=>!path.endsWith(".css")),
            devFiles: [],
            ampDevFiles: [],
            lowPriorityFiles: [],
            pages: {
                "/_app": []
            },
            ampFirstPages: []
        },
        ComponentMod: {
            ...pageModule,
            default: undefined,
            tree,
            pages: [
                "page.js"
            ]
        },
        serverComponentManifest: manifest,
        serverCSSManifest,
        runtime: "nodejs",
        serverComponents: true,
        assetPrefix: "",
        pageConfig: pageModule.config,
        reactLoadableManifest: {}
    };
    const result = await __TURBOPACK__imported__module__$5b$project$2d$with$2d$next$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$app$2d$render$2e$js__["renderToHTMLOrFlight"](req, res, renderData.path, {
        ...renderData.query,
        ...renderData.params
    }, renderOpt);
    if (!result) throw new Error("rendering was not successful");
    let body;
    if (result.isDynamic()) {
        const stream = new __TURBOPACK__external__stream__["PassThrough"]();
        result.pipe(stream);
        const chunks = [];
        for await (const chunk of stream){
            chunks.push(chunk);
        }
        body = Buffer.concat(chunks).toString();
    } else {
        body = result.toUnchunkedString();
    }
    return {
        contentType: result.contentType(),
        body
    };
}
const ESCAPE_LOOKUP = {
    "&": "\\u0026",
    ">": "\\u003e",
    "<": "\\u003c",
    "\u2028": "\\u2028",
    "\u2029": "\\u2029"
};
const ESCAPE_REGEX = /[&><\u2028\u2029]/g;
function htmlEscapeJsonString(str) {
    return str.replace(ESCAPE_REGEX, (match)=>ESCAPE_LOOKUP[match]);
}

})()),
"[project-with-next]/app/page.tsx/next-app-hydrate.tsx/chunk_group_files.js (ssr)": (({ r: __turbopack_require__, x: __turbopack_external_require__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, c: __turbopack_cache__, l: __turbopack_load__, p: process, __dirname }) => (() => {

__turbopack_export_value__([
  "static/chunks/_32e8f3.js",
  "static/chunks/[embedded_modules]_@vercel_turbopack-next_c270ad.js",
  "static/chunks/[embedded_modules]_@vercel_turbopack-next_compiled_96ad4e.js",
  "static/chunks/_125dda.js",
  "static/chunks/node_modules_next_dist_compiled_a03b71.js",
  "static/chunks/_7c13f5.js",
  "static/chunks/node_modules_6eb606.js",
  "static/chunks/node_modules_next_dist_compiled_react-refresh_runtime.js"
]);

})()),
"[project-with-next]/[embedded_modules]/@vercel/turbopack-next/internal/http.ts (ecmascript, ssr)": (({ r: __turbopack_require__, x: __turbopack_external_require__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, c: __turbopack_cache__, l: __turbopack_load__, p: process, __dirname }) => (() => {

__turbopack_esm__({
    "ServerResponseShim": ()=>ServerResponseShim
});
class ServerResponseShim {
    headersSent = false;
    #headers = new Map();
    constructor(req){
        this.req = req;
    }
    setHeader(name, value) {
        this.#headers.set(name.toLowerCase(), value);
        return this;
    }
    getHeader(name) {
        return this.#headers.get(name.toLowerCase());
    }
    getHeaderNames() {
        return Array.from(this.#headers.keys());
    }
    getHeaders() {
        return Object.fromEntries(this.#headers);
    }
    hasHeader(name) {
        return this.#headers.has(name.toLowerCase());
    }
    removeHeader(name) {
        this.#headers.delete(name.toLowerCase());
    }
    get statusCode() {
        throw new Error("statusCode is not implemented");
    }
    set statusCode(code) {
        throw new Error("set statusCode is not implemented");
    }
    get statusMessage() {
        throw new Error("statusMessage is not implemented");
    }
    set statusMessage(message) {
        throw new Error("set statusMessage is not implemented");
    }
    get socket() {
        throw new Error("socket is not implemented");
    }
    get sendDate() {
        throw new Error("sendDate is not implemented");
    }
    flushHeaders() {
        throw new Error("flushHeaders is not implemented");
    }
    end() {
        throw new Error("end is not implemented");
    }
    cork() {
        throw new Error("cork is not implemented");
    }
    uncork() {
        throw new Error("uncork is not implemented");
    }
    addTrailers() {
        throw new Error("addTrailers is not implemented");
    }
    setTimeout(_msecs, _callback) {
        throw new Error("setTimeout is not implemented");
    }
    get writableEnded() {
        throw new Error("writableEnded is not implemented");
    }
    get writableFinished() {
        throw new Error("writableFinished is not implemented");
    }
    write(_chunk, _encoding, _callback) {
        throw new Error("write is not implemented");
    }
    writeContinue() {
        throw new Error("writeContinue is not implemented");
    }
    writeHead(_statusCode, _statusMessage, _headers) {
        throw new Error("writeHead is not implemented");
    }
    writeProcessing() {
        throw new Error("writeProcessing is not implemented");
    }
}

})()),
"[project-with-next]/[embedded_modules]/@vercel/turbopack-next/internal/ipc.ts (ecmascript, ssr)": (({ r: __turbopack_require__, x: __turbopack_external_require__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, c: __turbopack_cache__, l: __turbopack_load__, p: process, __dirname }) => (() => {

__turbopack_esm__({
    "default": ()=>__TURBOPACK__default__export__
});
var __TURBOPACK__external__node$3a$net__ = __turbopack_external_require__("node:net");
var __TURBOPACK__imported__module__$5b$project$2d$with$2d$next$5d2f5b$embedded_modules$5d2f40$vercel$2f$turbopack$2d$next$2f$internal$2f$error$2e$ts__ = __turbopack_import__("[project-with-next]/[embedded_modules]/@vercel/turbopack-next/internal/error.ts (ecmascript, ssr)");
"__TURBOPACK__ecmascript__hoisting__location__";
;
;
function createIpc(port) {
    const socket = __TURBOPACK__external__node$3a$net__["default"].createConnection(port, "127.0.0.1");
    const packetQueue = [];
    const recvPromiseResolveQueue = [];
    function pushPacket(packet) {
        const recvPromiseResolve = recvPromiseResolveQueue.shift();
        if (recvPromiseResolve != null) {
            recvPromiseResolve(JSON.parse(packet.toString("utf8")));
        } else {
            packetQueue.push(packet);
        }
    }
    let state = {
        type: "waiting"
    };
    let buffer = Buffer.alloc(0);
    socket.once("connect", ()=>{
        socket.on("data", (chunk)=>{
            buffer = Buffer.concat([
                buffer,
                chunk
            ]);
            loop: while(true){
                switch(state.type){
                    case "waiting":
                        {
                            if (buffer.length >= 4) {
                                const length = buffer.readUInt32BE(0);
                                buffer = buffer.subarray(4);
                                state = {
                                    type: "packet",
                                    length
                                };
                            } else {
                                break loop;
                            }
                            break;
                        }
                    case "packet":
                        {
                            if (buffer.length >= state.length) {
                                const packet = buffer.subarray(0, state.length);
                                buffer = buffer.subarray(state.length);
                                state = {
                                    type: "waiting"
                                };
                                pushPacket(packet);
                            } else {
                                break loop;
                            }
                            break;
                        }
                }
            }
        });
    });
    function send(message) {
        const packet = Buffer.from(JSON.stringify(message), "utf8");
        const length = Buffer.alloc(4);
        length.writeUInt32BE(packet.length);
        socket.write(length);
        return new Promise((resolve, reject)=>{
            socket.write(packet, (err)=>{
                if (err != null) {
                    reject(err);
                } else {
                    resolve();
                }
            });
        });
    }
    return {
        async recv () {
            const packet = packetQueue.shift();
            if (packet != null) {
                return JSON.parse(packet.toString("utf8"));
            }
            const result = await new Promise((resolve)=>{
                recvPromiseResolveQueue.push((result)=>{
                    resolve(result);
                });
            });
            return result;
        },
        send (message) {
            return send(message);
        },
        async sendError (error) {
            await send({
                type: "error",
                ...__TURBOPACK__imported__module__$5b$project$2d$with$2d$next$5d2f5b$embedded_modules$5d2f40$vercel$2f$turbopack$2d$next$2f$internal$2f$error$2e$ts__["structuredError"](error)
            });
            process.exit(1);
        }
    };
}
const PORT = process.argv[2];
const IPC = createIpc(parseInt(PORT, 10));
process.on("uncaughtException", (err)=>{
    IPC.sendError(err);
});
const __TURBOPACK__default__export__ = IPC;

})()),
"[project-with-next]/[embedded_modules]/@vercel/turbopack-next/internal/error.ts (ecmascript, ssr)": (({ r: __turbopack_require__, x: __turbopack_external_require__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, c: __turbopack_cache__, l: __turbopack_load__, p: process, __dirname }) => (() => {

__turbopack_esm__({
    "structuredError": ()=>structuredError
});
var __TURBOPACK__imported__module__$5b$project$2d$with$2d$next$5d2f5b$embedded_modules$5d2f40$vercel$2f$turbopack$2d$next$2f$compiled$2f$stacktrace$2d$parser$2f$index$2e$js__ = __turbopack_import__("[project-with-next]/[embedded_modules]/@vercel/turbopack-next/compiled/stacktrace-parser/index.js (ecmascript, ssr)");
"__TURBOPACK__ecmascript__hoisting__location__";
;
function structuredError(e) {
    return {
        name: e.name,
        message: e.message,
        stack: __TURBOPACK__imported__module__$5b$project$2d$with$2d$next$5d2f5b$embedded_modules$5d2f40$vercel$2f$turbopack$2d$next$2f$compiled$2f$stacktrace$2d$parser$2f$index$2e$js__["parse"](e.stack)
    };
}

})()),
"[project-with-next]/node_modules/next/dist/server/app-render.js (ecmascript, ssr)": (function({ r: __turbopack_require__, x: __turbopack_external_require__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, c: __turbopack_cache__, l: __turbopack_load__, p: process, __dirname, m: module, e: exports }) { !function() {

"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.renderToHTMLOrFlight = renderToHTMLOrFlight;
var _react = _interopRequireWildcard(__turbopack_require__("[project-with-next]/node_modules/next/dist/compiled/react/index.js (ecmascript, ssr)"));
var _error = __turbopack_require__("[project-with-next]/node_modules/next/dist/client/components/error.js (ecmascript, ssr)");
var _serverBrowser = _interopRequireDefault(__turbopack_require__("[project-with-next]/node_modules/next/dist/compiled/react-dom/server.browser.js (ecmascript, ssr)"));
var _renderResult = _interopRequireDefault(__turbopack_require__("[project-with-next]/node_modules/next/dist/server/render-result.js (ecmascript, ssr)"));
var _nodeWebStreamsHelper = __turbopack_require__("[project-with-next]/node_modules/next/dist/server/node-web-streams-helper.js (ecmascript, ssr)");
var _htmlescape = __turbopack_require__("[project-with-next]/node_modules/next/dist/server/htmlescape.js (ecmascript, ssr)");
var _utils = __turbopack_require__("[project-with-next]/node_modules/next/dist/server/utils.js (ecmascript, ssr)");
var _matchSegments = __turbopack_require__("[project-with-next]/node_modules/next/dist/client/components/match-segments.js (ecmascript, ssr)");
var _serverInsertedHtml = __turbopack_require__("[project-with-next]/node_modules/next/dist/shared/lib/server-inserted-html.js (ecmascript, ssr)");
var _internalUtils = __turbopack_require__("[project-with-next]/node_modules/next/dist/server/internal-utils.js (ecmascript, ssr)");
var _redirect = __turbopack_require__("[project-with-next]/node_modules/next/dist/client/components/redirect.js (ecmascript, ssr)");
var _cookies = __turbopack_require__("[project-with-next]/node_modules/next/dist/server/web/spec-extension/cookies.js (ecmascript, ssr)");
var _hooksServerContext = __turbopack_require__("[project-with-next]/node_modules/next/dist/client/components/hooks-server-context.js (ecmascript, ssr)");
var _notFound = __turbopack_require__("[project-with-next]/node_modules/next/dist/client/components/not-found.js (ecmascript, ssr)");
var _headManagerContext = __turbopack_require__("[project-with-next]/node_modules/next/dist/shared/lib/head-manager-context.js (ecmascript, ssr)");
var _stream = __turbopack_external_require__("stream");
var _stringHash = _interopRequireDefault(__turbopack_require__("[project-with-next]/node_modules/next/dist/compiled/string-hash/index.js (ecmascript, ssr)"));
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function _getRequireWildcardCache() {
    if (typeof WeakMap !== "function") return null;
    var cache = new WeakMap();
    _getRequireWildcardCache = function() {
        return cache;
    };
    return cache;
}
function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache();
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
const INTERNAL_HEADERS_INSTANCE = Symbol("internal for headers readonly");
function readonlyHeadersError() {
    return new Error("ReadonlyHeaders cannot be modified");
}
class ReadonlyHeaders {
    constructor(headers){
        const headersInstance = new Headers(headers);
        this[INTERNAL_HEADERS_INSTANCE] = headersInstance;
        this.entries = headersInstance.entries.bind(headersInstance);
        this.forEach = headersInstance.forEach.bind(headersInstance);
        this.get = headersInstance.get.bind(headersInstance);
        this.has = headersInstance.has.bind(headersInstance);
        this.keys = headersInstance.keys.bind(headersInstance);
        this.values = headersInstance.values.bind(headersInstance);
    }
    [Symbol.iterator]() {
        return this[INTERNAL_HEADERS_INSTANCE][Symbol.iterator]();
    }
    append() {
        throw readonlyHeadersError();
    }
    delete() {
        throw readonlyHeadersError();
    }
    set() {
        throw readonlyHeadersError();
    }
}
const INTERNAL_COOKIES_INSTANCE = Symbol("internal for cookies readonly");
function readonlyCookiesError() {
    return new Error("ReadonlyCookies cannot be modified");
}
class ReadonlyNextCookies {
    constructor(request){
        const cookiesInstance = new _cookies.NextCookies(request);
        this[INTERNAL_COOKIES_INSTANCE] = cookiesInstance;
        this.entries = cookiesInstance.entries.bind(cookiesInstance);
        this.forEach = cookiesInstance.forEach.bind(cookiesInstance);
        this.get = cookiesInstance.get.bind(cookiesInstance);
        this.getWithOptions = cookiesInstance.getWithOptions.bind(cookiesInstance);
        this.has = cookiesInstance.has.bind(cookiesInstance);
        this.keys = cookiesInstance.keys.bind(cookiesInstance);
        this.values = cookiesInstance.values.bind(cookiesInstance);
    }
    [Symbol.iterator]() {
        return this[INTERNAL_COOKIES_INSTANCE][Symbol.iterator]();
    }
    clear() {
        throw readonlyCookiesError();
    }
    delete() {
        throw readonlyCookiesError();
    }
    set() {
        throw readonlyCookiesError();
    }
}
class FlightRenderResult extends _renderResult.default {
    constructor(response){
        super(response, {
            contentType: "application/octet-stream"
        });
    }
}
function interopDefault(mod) {
    return mod.default || mod;
}
function createErrorHandler(_source, capturedErrors, allCapturedErrors) {
    return (err)=>{
        var ref;
        if (allCapturedErrors) allCapturedErrors.push(err);
        if (err.digest === _hooksServerContext.DYNAMIC_ERROR_CODE || err.digest === _notFound.NOT_FOUND_ERROR_CODE || ((ref = err.digest) == null ? void 0 : ref.startsWith(_redirect.REDIRECT_ERROR_CODE))) {
            return err.digest;
        }
        console.error(err);
        capturedErrors.push(err);
        return (0, _stringHash).default(err.message + err.stack + (err.digest || "")).toString();
    };
}
let isFetchPatched = false;
function patchFetch(ComponentMod) {
    if (isFetchPatched) return;
    isFetchPatched = true;
    const { DynamicServerError  } = ComponentMod.serverHooks;
    const staticGenerationAsyncStorage = ComponentMod.staticGenerationAsyncStorage;
    const originFetch = globalThis.fetch;
    globalThis.fetch = async (input, init)=>{
        const staticGenerationStore = "getStore" in staticGenerationAsyncStorage ? staticGenerationAsyncStorage.getStore() : staticGenerationAsyncStorage;
        const { isStaticGeneration , fetchRevalidate , pathname  } = staticGenerationStore || {};
        if (staticGenerationStore && isStaticGeneration) {
            if (init && typeof init === "object") {
                if (init.cache === "no-store") {
                    staticGenerationStore.fetchRevalidate = 0;
                    throw new DynamicServerError(`no-store fetch ${input}${pathname ? ` ${pathname}` : ""}`);
                }
                const hasNextConfig = "next" in init;
                const next = init.next || {};
                if (typeof next.revalidate === "number" && (typeof fetchRevalidate === "undefined" || next.revalidate < fetchRevalidate)) {
                    staticGenerationStore.fetchRevalidate = next.revalidate;
                    if (next.revalidate === 0) {
                        throw new DynamicServerError(`revalidate: ${next.revalidate} fetch ${input}${pathname ? ` ${pathname}` : ""}`);
                    }
                }
                if (hasNextConfig) delete init.next;
            }
        }
        return originFetch(input, init);
    };
}
function useFlightResponse(writable, req, serverComponentManifest, rscChunks, flightResponseRef, nonce) {
    if (flightResponseRef.current !== null) {
        return flightResponseRef.current;
    }
    const { createFromReadableStream  } = __turbopack_require__("[project-with-next]/node_modules/next/dist/compiled/react-server-dom-webpack/client.js (ecmascript, ssr)");
    const [renderStream, forwardStream] = (0, _nodeWebStreamsHelper).readableStreamTee(req);
    const res = createFromReadableStream(renderStream, {
        moduleMap: process.env.NEXT_RUNTIME === "edge" ? serverComponentManifest.__edge_ssr_module_mapping__ : serverComponentManifest.__ssr_module_mapping__
    });
    flightResponseRef.current = res;
    let bootstrapped = false;
    const forwardReader = forwardStream.getReader();
    const writer = writable.getWriter();
    const startScriptTag = nonce ? `<script nonce=${JSON.stringify(nonce)}>` : "<script>";
    function read() {
        forwardReader.read().then(({ done , value  })=>{
            if (value) {
                rscChunks.push(value);
            }
            if (!bootstrapped) {
                bootstrapped = true;
                writer.write((0, _nodeWebStreamsHelper).encodeText(`${startScriptTag}(self.__next_f=self.__next_f||[]).push(${(0, _htmlescape).htmlEscapeJsonString(JSON.stringify([
                    0
                ]))})</script>`));
            }
            if (done) {
                flightResponseRef.current = null;
                writer.close();
            } else {
                const responsePartial = (0, _nodeWebStreamsHelper).decodeText(value);
                const scripts = `${startScriptTag}self.__next_f.push(${(0, _htmlescape).htmlEscapeJsonString(JSON.stringify([
                    1,
                    responsePartial
                ]))})</script>`;
                writer.write((0, _nodeWebStreamsHelper).encodeText(scripts));
                read();
            }
        });
    }
    read();
    return res;
}
function createServerComponentRenderer(ComponentToRender, ComponentMod, { transformStream , serverComponentManifest , serverContexts , rscChunks  }, serverComponentsErrorHandler, nonce) {
    if (ComponentMod.__next_app_webpack_require__) {
        globalThis.__next_require__ = ComponentMod.__next_app_webpack_require__;
        globalThis.__next_chunk_load__ = ()=>Promise.resolve();
    }
    let RSCStream;
    const createRSCStream = ()=>{
        if (!RSCStream) {
            RSCStream = ComponentMod.renderToReadableStream(_react.default.createElement(ComponentToRender, null), serverComponentManifest, {
                context: serverContexts,
                onError: serverComponentsErrorHandler
            });
        }
        return RSCStream;
    };
    const flightResponseRef = {
        current: null
    };
    const writable = transformStream.writable;
    return function ServerComponentWrapper() {
        const reqStream = createRSCStream();
        const response = useFlightResponse(writable, reqStream, serverComponentManifest, rscChunks, flightResponseRef, nonce);
        return (0, _react).use(response);
    };
}
function getShortDynamicParamType(type) {
    switch(type){
        case "catchall":
            return "c";
        case "optional-catchall":
            return "oc";
        case "dynamic":
            return "d";
        default:
            throw new Error("Unknown dynamic param type");
    }
}
function getSegmentParam(segment) {
    if (segment.startsWith("[[...") && segment.endsWith("]]")) {
        return {
            type: "optional-catchall",
            param: segment.slice(5, -2)
        };
    }
    if (segment.startsWith("[...") && segment.endsWith("]")) {
        return {
            type: "catchall",
            param: segment.slice(4, -1)
        };
    }
    if (segment.startsWith("[") && segment.endsWith("]")) {
        return {
            type: "dynamic",
            param: segment.slice(1, -1)
        };
    }
    return null;
}
function getCssInlinedLinkTags(serverComponentManifest, serverCSSManifest, filePath, serverCSSForEntries) {
    var ref;
    const layoutOrPageCss = serverCSSManifest[filePath] || ((ref = serverComponentManifest.__client_css_manifest__) == null ? void 0 : ref[filePath]);
    if (!layoutOrPageCss) {
        return [];
    }
    const chunks = new Set();
    for (const css of layoutOrPageCss){
        if (serverCSSForEntries.includes(css) || !/\.module\.css/.test(css)) {
            const mod = serverComponentManifest[css];
            if (mod) {
                for (const chunk of mod.default.chunks){
                    chunks.add(chunk);
                }
            }
        }
    }
    return [
        ...chunks
    ];
}
function getServerCSSForEntries(serverCSSManifest, entries) {
    const css = [];
    for (const entry of entries){
        const entryName = entry.replace(/\.[^.]+$/, "");
        if (serverCSSManifest.__entry_css__ && serverCSSManifest.__entry_css__[entryName]) {
            css.push(...serverCSSManifest.__entry_css__[entryName]);
        }
    }
    return css;
}
function getPreloadedFontFilesInlineLinkTags(serverComponentManifest, serverCSSManifest, fontLoaderManifest, serverCSSForEntries, filePath) {
    var ref;
    if (!fontLoaderManifest || !filePath) {
        return [];
    }
    const layoutOrPageCss = serverCSSManifest[filePath] || ((ref = serverComponentManifest.__client_css_manifest__) == null ? void 0 : ref[filePath]);
    if (!layoutOrPageCss) {
        return [];
    }
    const fontFiles = new Set();
    for (const css of layoutOrPageCss){
        if (serverCSSForEntries.includes(css)) {
            const preloadedFontFiles = fontLoaderManifest.app[css];
            if (preloadedFontFiles) {
                for (const fontFile of preloadedFontFiles){
                    fontFiles.add(fontFile);
                }
            }
        }
    }
    return [
        ...fontFiles
    ];
}
function getScriptNonceFromHeader(cspHeaderValue) {
    var ref;
    const directives = cspHeaderValue.split(";").map((directive)=>directive.trim());
    const directive1 = directives.find((dir)=>dir.startsWith("script-src")) || directives.find((dir)=>dir.startsWith("default-src"));
    if (!directive1) {
        return;
    }
    const nonce = (ref = directive1.split(" ").slice(1).map((source)=>source.trim()).find((source)=>source.startsWith("'nonce-") && source.length > 8 && source.endsWith("'"))) == null ? void 0 : ref.slice(7, -1);
    if (!nonce) {
        return;
    }
    if (_htmlescape.ESCAPE_REGEX.test(nonce)) {
        throw new Error("Nonce value from Content-Security-Policy contained HTML escape characters.\nLearn more: https://nextjs.org/docs/messages/nonce-contained-invalid-characters");
    }
    return nonce;
}
const FLIGHT_PARAMETERS = [
    "__rsc__",
    "__next_router_state_tree__",
    "__next_router_prefetch__"
];
function headersWithoutFlight(headers) {
    const newHeaders = {
        ...headers
    };
    for (const param of FLIGHT_PARAMETERS){
        delete newHeaders[param];
    }
    return newHeaders;
}
async function renderToString(element) {
    if (!_utils.shouldUseReactRoot) return _serverBrowser.default.renderToString(element);
    const renderStream = await _serverBrowser.default.renderToReadableStream(element);
    await renderStream.allReady;
    return (0, _nodeWebStreamsHelper).streamToString(renderStream);
}
async function renderToHTMLOrFlight(req, res, pathname, query, renderOpts) {
    const isStaticGeneration = renderOpts.supportsDynamicHTML !== true && !renderOpts.isBot;
    const isFlight = req.headers.__rsc__ !== undefined;
    const capturedErrors = [];
    const allCapturedErrors = [];
    const serverComponentsErrorHandler = createErrorHandler("serverComponentsRenderer", capturedErrors);
    const flightDataRendererErrorHandler = createErrorHandler("flightDataRenderer", capturedErrors);
    const htmlRendererErrorHandler = createErrorHandler("htmlRenderer", capturedErrors, allCapturedErrors);
    const { buildManifest , subresourceIntegrityManifest , serverComponentManifest , serverCSSManifest ={} , ComponentMod , dev , fontLoaderManifest , supportsDynamicHTML  } = renderOpts;
    if (process.env.NODE_ENV === "production") {
        patchFetch(ComponentMod);
    }
    const generateStaticHTML = supportsDynamicHTML !== true;
    const staticGenerationAsyncStorage = ComponentMod.staticGenerationAsyncStorage;
    const requestAsyncStorage = ComponentMod.requestAsyncStorage;
    if (staticGenerationAsyncStorage && !("getStore" in staticGenerationAsyncStorage) && staticGenerationAsyncStorage.inUse) {
        throw new Error(`Invariant: A separate worker must be used for each render when AsyncLocalStorage is not available`);
    }
    const wrappedRender = async ()=>{
        const staticGenerationStore = "getStore" in staticGenerationAsyncStorage ? staticGenerationAsyncStorage.getStore() : staticGenerationAsyncStorage;
        query = Object.assign({}, query);
        const isPrefetch = req.headers.__next_router_prefetch__ !== undefined;
        let providedFlightRouterState = isFlight ? req.headers.__next_router_state_tree__ ? JSON.parse(req.headers.__next_router_state_tree__) : undefined : undefined;
        const loaderTree = ComponentMod.tree;
        (0, _internalUtils).stripInternalQueries(query);
        const LayoutRouter = ComponentMod.LayoutRouter;
        const RenderFromTemplateContext = ComponentMod.RenderFromTemplateContext;
        const serverContexts = [
            [
                "WORKAROUND",
                null
            ]
        ];
        const pathParams = renderOpts.params;
        const getDynamicParamFromSegment = (segment)=>{
            const segmentParam = getSegmentParam(segment);
            if (!segmentParam) {
                return null;
            }
            const key = segmentParam.param;
            const value = pathParams[key];
            if (!value) {
                if (segmentParam.type === "optional-catchall") {
                    const type = getShortDynamicParamType(segmentParam.type);
                    return {
                        param: key,
                        value: null,
                        type: type,
                        treeSegment: [
                            key,
                            "",
                            type
                        ]
                    };
                }
                return null;
            }
            const type = getShortDynamicParamType(segmentParam.type);
            return {
                param: key,
                value: value,
                treeSegment: [
                    key,
                    Array.isArray(value) ? value.join("/") : value,
                    type
                ],
                type: type
            };
        };
        async function resolveHead([segment, parallelRoutes, { head  }], parentParams) {
            const segmentParam = getDynamicParamFromSegment(segment);
            const currentParams = segmentParam && segmentParam.value !== null ? {
                ...parentParams,
                [segmentParam.param]: segmentParam.value
            } : parentParams;
            for(const key in parallelRoutes){
                const childTree = parallelRoutes[key];
                const returnedHead = await resolveHead(childTree, currentParams);
                if (returnedHead) {
                    return returnedHead;
                }
            }
            if (head) {
                const Head = await interopDefault(head());
                return _react.default.createElement(Head, {
                    params: currentParams
                });
            }
            return null;
        }
        const createFlightRouterStateFromLoaderTree = ([segment, parallelRoutes, { layout  }], rootLayoutIncluded = false)=>{
            const dynamicParam = getDynamicParamFromSegment(segment);
            const segmentTree = [
                dynamicParam ? dynamicParam.treeSegment : segment,
                {}
            ];
            if (!rootLayoutIncluded && typeof layout !== "undefined") {
                rootLayoutIncluded = true;
                segmentTree[4] = true;
            }
            segmentTree[1] = Object.keys(parallelRoutes).reduce((existingValue, currentValue)=>{
                existingValue[currentValue] = createFlightRouterStateFromLoaderTree(parallelRoutes[currentValue], rootLayoutIncluded);
                return existingValue;
            }, {});
            return segmentTree;
        };
        let defaultRevalidate = false;
        const serverCSSForEntries = getServerCSSForEntries(serverCSSManifest, ComponentMod.pages);
        const assetPrefix = renderOpts.assetPrefix || "";
        const createComponentTree = async ({ createSegmentPath , loaderTree: [segment, parallelRoutes, { layoutOrPagePath , layout , template , error , loading , page , "not-found": notFound  }] , parentParams , firstItem , rootLayoutIncluded  })=>{
            const stylesheets = layoutOrPagePath ? getCssInlinedLinkTags(serverComponentManifest, serverCSSManifest, layoutOrPagePath, serverCSSForEntries) : [];
            const preloadedFontFiles = getPreloadedFontFilesInlineLinkTags(serverComponentManifest, serverCSSManifest, fontLoaderManifest, serverCSSForEntries, layoutOrPagePath);
            const Template = template ? await interopDefault(template()) : _react.default.Fragment;
            const ErrorComponent = error ? await interopDefault(error()) : undefined;
            const Loading = loading ? await interopDefault(loading()) : undefined;
            const isLayout = typeof layout !== "undefined";
            const isPage = typeof page !== "undefined";
            const layoutOrPageMod = isLayout ? await layout() : isPage ? await page() : undefined;
            const rootLayoutAtThisLevel = isLayout && !rootLayoutIncluded;
            const rootLayoutIncludedAtThisLevelOrAbove = rootLayoutIncluded || rootLayoutAtThisLevel;
            const NotFound = notFound ? await interopDefault(notFound()) : rootLayoutAtThisLevel ? _error.NotFound : undefined;
            if (typeof (layoutOrPageMod == null ? void 0 : layoutOrPageMod.revalidate) !== "undefined") {
                defaultRevalidate = layoutOrPageMod.revalidate;
                if (isStaticGeneration && defaultRevalidate === 0) {
                    const { DynamicServerError  } = ComponentMod.serverHooks;
                    throw new DynamicServerError(`revalidate: 0 configured ${segment}`);
                }
            }
            if (typeof (layoutOrPageMod == null ? void 0 : layoutOrPageMod.getServerSideProps) === "function") {
                throw new Error(`getServerSideProps is not supported in app/, detected in ${segment}`);
            }
            if (typeof (layoutOrPageMod == null ? void 0 : layoutOrPageMod.getStaticProps) === "function") {
                throw new Error(`getStaticProps is not supported in app/, detected in ${segment}`);
            }
            const Component = layoutOrPageMod ? interopDefault(layoutOrPageMod) : undefined;
            if (dev) {
                const { isValidElementType  } = __turbopack_require__("[project-with-next]/node_modules/next/dist/compiled/react-is/index.js (ecmascript, ssr)");
                if ((isPage || typeof Component !== "undefined") && !isValidElementType(Component)) {
                    throw new Error(`The default export is not a React Component in page: "${pathname}"`);
                }
                if (typeof ErrorComponent !== "undefined" && !isValidElementType(ErrorComponent)) {
                    throw new Error(`The default export of error is not a React Component in page: ${segment}`);
                }
                if (typeof Loading !== "undefined" && !isValidElementType(Loading)) {
                    throw new Error(`The default export of loading is not a React Component in ${segment}`);
                }
                if (typeof NotFound !== "undefined" && !isValidElementType(NotFound)) {
                    throw new Error(`The default export of notFound is not a React Component in ${segment}`);
                }
            }
            const segmentParam = getDynamicParamFromSegment(segment);
            const currentParams = segmentParam && segmentParam.value !== null ? {
                ...parentParams,
                [segmentParam.param]: segmentParam.value
            } : parentParams;
            const actualSegment = segmentParam ? segmentParam.treeSegment : segment;
            const parallelRouteMap = await Promise.all(Object.keys(parallelRoutes).map(async (parallelRouteKey)=>{
                const currentSegmentPath = firstItem ? [
                    parallelRouteKey
                ] : [
                    actualSegment,
                    parallelRouteKey
                ];
                const childSegment = parallelRoutes[parallelRouteKey][0];
                const childSegmentParam = getDynamicParamFromSegment(childSegment);
                if (isPrefetch && Loading) {
                    const childProp = {
                        current: null,
                        segment: childSegmentParam ? childSegmentParam.treeSegment : childSegment
                    };
                    return [
                        parallelRouteKey,
                        _react.default.createElement(LayoutRouter, {
                            parallelRouterKey: parallelRouteKey,
                            segmentPath: createSegmentPath(currentSegmentPath),
                            loading: Loading ? _react.default.createElement(Loading, null) : undefined,
                            hasLoading: Boolean(Loading),
                            error: ErrorComponent,
                            template: _react.default.createElement(Template, null, _react.default.createElement(RenderFromTemplateContext, null)),
                            notFound: NotFound ? _react.default.createElement(NotFound, null) : undefined,
                            childProp: childProp,
                            rootLayoutIncluded: rootLayoutIncludedAtThisLevelOrAbove
                        })
                    ];
                }
                const { Component: ChildComponent  } = await createComponentTree({
                    createSegmentPath: (child)=>{
                        return createSegmentPath([
                            ...currentSegmentPath,
                            ...child
                        ]);
                    },
                    loaderTree: parallelRoutes[parallelRouteKey],
                    parentParams: currentParams,
                    rootLayoutIncluded: rootLayoutIncludedAtThisLevelOrAbove
                });
                const childProp = {
                    current: _react.default.createElement(ChildComponent, null),
                    segment: childSegmentParam ? childSegmentParam.treeSegment : childSegment
                };
                const segmentPath = createSegmentPath(currentSegmentPath);
                return [
                    parallelRouteKey,
                    _react.default.createElement(LayoutRouter, {
                        parallelRouterKey: parallelRouteKey,
                        segmentPath: segmentPath,
                        error: ErrorComponent,
                        loading: Loading ? _react.default.createElement(Loading, null) : undefined,
                        hasLoading: Boolean(Loading),
                        template: _react.default.createElement(Template, null, _react.default.createElement(RenderFromTemplateContext, null)),
                        notFound: NotFound ? _react.default.createElement(NotFound, null) : undefined,
                        childProp: childProp,
                        rootLayoutIncluded: rootLayoutIncludedAtThisLevelOrAbove
                    })
                ];
            }));
            const parallelRouteComponents = parallelRouteMap.reduce((list, [parallelRouteKey, Comp])=>{
                list[parallelRouteKey] = Comp;
                return list;
            }, {});
            if (!Component) {
                return {
                    Component: ()=>_react.default.createElement(_react.default.Fragment, null, parallelRouteComponents.children)
                };
            }
            return {
                Component: ()=>{
                    let props = {};
                    const cacheBustingUrlSuffix = dev ? `?ts=${Date.now()}` : "";
                    return _react.default.createElement(_react.default.Fragment, null, preloadedFontFiles.map((fontFile)=>{
                        const ext = /\.(woff|woff2|eot|ttf|otf)$/.exec(fontFile)[1];
                        return _react.default.createElement("link", {
                            key: fontFile,
                            rel: "preload",
                            href: `${assetPrefix}/_next/${fontFile}`,
                            as: "font",
                            type: `font/${ext}`,
                            crossOrigin: "anonymous"
                        });
                    }), stylesheets ? stylesheets.map((href, index)=>_react.default.createElement("link", {
                            rel: "stylesheet",
                            href: `${assetPrefix}/_next/${href}${cacheBustingUrlSuffix}`,
                            precedence: "high",
                            key: index
                        })) : null, _react.default.createElement(Component, Object.assign({}, props, parallelRouteComponents, {
                        params: currentParams
                    }, isPage ? {
                        searchParams: query
                    } : {})));
                }
            };
        };
        const streamToBufferedResult = async (renderResult)=>{
            const renderChunks = [];
            const writable = new _stream.Writable({
                write (chunk, _encoding, callback) {
                    renderChunks.push(chunk);
                    callback();
                }
            });
            await renderResult.pipe(writable);
            return Buffer.concat(renderChunks).toString();
        };
        const generateFlight = async ()=>{
            const walkTreeWithFlightRouterState = async ({ createSegmentPath , loaderTreeToFilter , parentParams , isFirst , flightRouterState , parentRendered  })=>{
                const [segment, parallelRoutes] = loaderTreeToFilter;
                const parallelRoutesKeys = Object.keys(parallelRoutes);
                const segmentParam = getDynamicParamFromSegment(segment);
                const currentParams = segmentParam && segmentParam.value !== null ? {
                    ...parentParams,
                    [segmentParam.param]: segmentParam.value
                } : parentParams;
                const actualSegment = segmentParam ? segmentParam.treeSegment : segment;
                const renderComponentsOnThisLevel = !flightRouterState || !(0, _matchSegments).matchSegment(actualSegment, flightRouterState[0]) || parallelRoutesKeys.length === 0 || flightRouterState[3] === "refetch";
                if (!parentRendered && renderComponentsOnThisLevel) {
                    return [
                        actualSegment,
                        createFlightRouterStateFromLoaderTree(loaderTreeToFilter),
                        isPrefetch && !Boolean(loaderTreeToFilter[2].loading) ? null : _react.default.createElement((await createComponentTree({
                            createSegmentPath: (child)=>{
                                return createSegmentPath(child);
                            },
                            loaderTree: loaderTreeToFilter,
                            parentParams: currentParams,
                            firstItem: isFirst
                        })).Component)
                    ];
                }
                for (const parallelRouteKey of parallelRoutesKeys){
                    const parallelRoute = parallelRoutes[parallelRouteKey];
                    const currentSegmentPath = isFirst ? [
                        parallelRouteKey
                    ] : [
                        actualSegment,
                        parallelRouteKey
                    ];
                    const path = await walkTreeWithFlightRouterState({
                        createSegmentPath: (child)=>{
                            return createSegmentPath([
                                ...currentSegmentPath,
                                ...child
                            ]);
                        },
                        loaderTreeToFilter: parallelRoute,
                        parentParams: currentParams,
                        flightRouterState: flightRouterState && flightRouterState[1][parallelRouteKey],
                        parentRendered: parentRendered || renderComponentsOnThisLevel,
                        isFirst: false
                    });
                    if (typeof path[path.length - 1] !== "string") {
                        return [
                            actualSegment,
                            parallelRouteKey,
                            ...path
                        ];
                    }
                }
                return [
                    actualSegment
                ];
            };
            const flightData = [
                (await walkTreeWithFlightRouterState({
                    createSegmentPath: (child)=>child,
                    loaderTreeToFilter: loaderTree,
                    parentParams: {},
                    flightRouterState: providedFlightRouterState,
                    isFirst: true
                })).slice(1)
            ];
            const readable = ComponentMod.renderToReadableStream(flightData, serverComponentManifest, {
                context: serverContexts,
                onError: flightDataRendererErrorHandler
            }).pipeThrough((0, _nodeWebStreamsHelper).createBufferedTransformStream());
            return new FlightRenderResult(readable);
        };
        if (isFlight && !isStaticGeneration) {
            return generateFlight();
        }
        const { Component: ComponentTree  } = await createComponentTree({
            createSegmentPath: (child)=>child,
            loaderTree: loaderTree,
            parentParams: {},
            firstItem: true
        });
        const AppRouter = ComponentMod.AppRouter;
        let serverComponentsInlinedTransformStream = new TransformStream();
        const initialCanonicalUrl = req.url;
        const csp = req.headers["content-security-policy"];
        let nonce;
        if (csp && typeof csp === "string") {
            nonce = getScriptNonceFromHeader(csp);
        }
        const serverComponentsRenderOpts = {
            transformStream: serverComponentsInlinedTransformStream,
            serverComponentManifest,
            serverContexts,
            rscChunks: []
        };
        const validateRootLayout = dev ? {
            validateRootLayout: {
                assetPrefix: renderOpts.assetPrefix,
                getTree: ()=>createFlightRouterStateFromLoaderTree(loaderTree)
            }
        } : {};
        const initialHead = await resolveHead(loaderTree, {});
        const ServerComponentsRenderer = createServerComponentRenderer(()=>{
            const initialTree = createFlightRouterStateFromLoaderTree(loaderTree);
            return _react.default.createElement(AppRouter, {
                assetPrefix: assetPrefix,
                initialCanonicalUrl: initialCanonicalUrl,
                initialTree: initialTree,
                initialHead: initialHead
            }, _react.default.createElement(ComponentTree, null));
        }, ComponentMod, serverComponentsRenderOpts, serverComponentsErrorHandler, nonce);
        const serverInsertedHTMLCallbacks = new Set();
        function InsertedHTML({ children  }) {
            serverInsertedHTMLCallbacks.clear();
            const addInsertedHtml = _react.default.useCallback((handler)=>{
                serverInsertedHTMLCallbacks.add(handler);
            }, []);
            return _react.default.createElement(_headManagerContext.HeadManagerContext.Provider, {
                value: {
                    appDir: true,
                    nonce
                }
            }, _react.default.createElement(_serverInsertedHtml.ServerInsertedHTMLContext.Provider, {
                value: addInsertedHtml
            }, children));
        }
        const bodyResult = async ()=>{
            const polyfills = buildManifest.polyfillFiles.filter((polyfill)=>polyfill.endsWith(".js") && !polyfill.endsWith(".module.js")).map((polyfill)=>{
                return {
                    src: `${assetPrefix}/_next/${polyfill}`,
                    integrity: subresourceIntegrityManifest == null ? void 0 : subresourceIntegrityManifest[polyfill]
                };
            });
            const content = _react.default.createElement(InsertedHTML, null, _react.default.createElement(ServerComponentsRenderer, null));
            let polyfillsFlushed = false;
            const getServerInsertedHTML = ()=>{
                const flushed = renderToString(_react.default.createElement(_react.default.Fragment, null, Array.from(serverInsertedHTMLCallbacks).map((callback)=>callback()), polyfillsFlushed ? null : polyfills == null ? void 0 : polyfills.map((polyfill)=>{
                    return _react.default.createElement("script", {
                        key: polyfill.src,
                        src: polyfill.src,
                        integrity: polyfill.integrity,
                        noModule: true,
                        nonce: nonce
                    });
                })));
                polyfillsFlushed = true;
                return flushed;
            };
            try {
                const renderStream = await (0, _nodeWebStreamsHelper).renderToInitialStream({
                    ReactDOMServer: _serverBrowser.default,
                    element: content,
                    streamOptions: {
                        onError: htmlRendererErrorHandler,
                        nonce,
                        bootstrapScripts: [
                            ...subresourceIntegrityManifest ? buildManifest.rootMainFiles.map((src)=>({
                                    src: `${assetPrefix}/_next/` + src,
                                    integrity: subresourceIntegrityManifest[src]
                                })) : buildManifest.rootMainFiles.map((src)=>`${assetPrefix}/_next/` + src)
                        ]
                    }
                });
                const result = await (0, _nodeWebStreamsHelper).continueFromInitialStream(renderStream, {
                    dataStream: serverComponentsInlinedTransformStream == null ? void 0 : serverComponentsInlinedTransformStream.readable,
                    generateStaticHTML: isStaticGeneration || generateStaticHTML,
                    getServerInsertedHTML,
                    serverInsertedHTMLToHead: true,
                    ...validateRootLayout
                });
                return result;
            } catch (err) {
                const shouldNotIndex = err.digest === _notFound.NOT_FOUND_ERROR_CODE;
                if (err.digest === _notFound.NOT_FOUND_ERROR_CODE) {
                    res.statusCode = 404;
                }
                const renderStream = await (0, _nodeWebStreamsHelper).renderToInitialStream({
                    ReactDOMServer: _serverBrowser.default,
                    element: _react.default.createElement("html", {
                        id: "__next_error__"
                    }, _react.default.createElement("head", null, shouldNotIndex ? _react.default.createElement("meta", {
                        name: "robots",
                        content: "noindex"
                    }) : null), _react.default.createElement("body", null)),
                    streamOptions: {
                        nonce,
                        bootstrapScripts: subresourceIntegrityManifest ? buildManifest.rootMainFiles.map((src)=>({
                                src: `${assetPrefix}/_next/` + src,
                                integrity: subresourceIntegrityManifest[src]
                            })) : buildManifest.rootMainFiles.map((src)=>`${assetPrefix}/_next/` + src)
                    }
                });
                return await (0, _nodeWebStreamsHelper).continueFromInitialStream(renderStream, {
                    dataStream: serverComponentsInlinedTransformStream == null ? void 0 : serverComponentsInlinedTransformStream.readable,
                    generateStaticHTML: isStaticGeneration,
                    getServerInsertedHTML,
                    serverInsertedHTMLToHead: true,
                    ...validateRootLayout
                });
            }
        };
        const renderResult1 = new _renderResult.default(await bodyResult());
        if (isStaticGeneration) {
            const htmlResult = await streamToBufferedResult(renderResult1);
            if (capturedErrors.length > 0) {
                throw capturedErrors[0];
            }
            const filteredFlightData = await streamToBufferedResult(await generateFlight());
            renderOpts.pageData = filteredFlightData;
            renderOpts.revalidate = typeof (staticGenerationStore == null ? void 0 : staticGenerationStore.fetchRevalidate) === "undefined" ? defaultRevalidate : staticGenerationStore == null ? void 0 : staticGenerationStore.fetchRevalidate;
            return new _renderResult.default(htmlResult);
        }
        return renderResult1;
    };
    const initialStaticGenerationStore = {
        isStaticGeneration,
        inUse: true,
        pathname
    };
    const tryGetPreviewData = process.env.NEXT_RUNTIME === "edge" ? ()=>false : __turbopack_require__("[project-with-next]/node_modules/next/dist/server/api-utils/node.js (ecmascript, ssr)").tryGetPreviewData;
    const previewData = tryGetPreviewData(req, res, renderOpts.previewProps);
    let cachedHeadersInstance;
    let cachedCookiesInstance;
    const requestStore = {
        get headers () {
            if (!cachedHeadersInstance) {
                cachedHeadersInstance = new ReadonlyHeaders(headersWithoutFlight(req.headers));
            }
            return cachedHeadersInstance;
        },
        get cookies () {
            if (!cachedCookiesInstance) {
                cachedCookiesInstance = new ReadonlyNextCookies({
                    headers: {
                        get: (key)=>{
                            if (key !== "cookie") {
                                throw new Error("Only cookie header is supported");
                            }
                            return req.headers.cookie;
                        }
                    }
                });
            }
            return cachedCookiesInstance;
        },
        previewData
    };
    function handleRequestStoreRun(fn) {
        if ("getStore" in requestAsyncStorage) {
            return new Promise((resolve, reject)=>{
                requestAsyncStorage.run(requestStore, ()=>{
                    return Promise.resolve(fn()).then(resolve).catch(reject);
                });
            });
        } else {
            Object.assign(requestAsyncStorage, requestStore);
            return Promise.resolve(fn());
        }
    }
    function handleStaticGenerationStoreRun(fn) {
        if ("getStore" in staticGenerationAsyncStorage) {
            return new Promise((resolve, reject)=>{
                staticGenerationAsyncStorage.run(initialStaticGenerationStore, ()=>{
                    return Promise.resolve(fn()).then(resolve).catch(reject);
                });
            });
        } else {
            Object.assign(staticGenerationAsyncStorage, initialStaticGenerationStore);
            return Promise.resolve(fn()).finally(()=>{
                staticGenerationAsyncStorage.inUse = false;
            });
        }
    }
    return handleRequestStoreRun(()=>handleStaticGenerationStoreRun(()=>wrappedRender()));
}

}.call(this) }),
"[project-with-next]/node_modules/next/dist/server/render-result.js (ecmascript, ssr)": (function({ r: __turbopack_require__, x: __turbopack_external_require__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, c: __turbopack_cache__, l: __turbopack_load__, p: process, __dirname, m: module, e: exports }) { !function() {

"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = void 0;
class RenderResult {
    constructor(response, { contentType  } = {}){
        this._result = response;
        this._contentType = contentType;
    }
    contentType() {
        return this._contentType;
    }
    toUnchunkedString() {
        if (typeof this._result !== "string") {
            throw new Error("invariant: dynamic responses cannot be unchunked. This is a bug in Next.js");
        }
        return this._result;
    }
    pipe(res) {
        if (typeof this._result === "string") {
            throw new Error("invariant: static responses cannot be piped. This is a bug in Next.js");
        }
        const response = this._result;
        const flush = typeof res.flush === "function" ? ()=>res.flush() : ()=>{};
        return (async ()=>{
            const reader = response.getReader();
            let fatalError = false;
            try {
                while(true){
                    const { done , value  } = await reader.read();
                    if (done) {
                        res.end();
                        return;
                    }
                    fatalError = true;
                    res.write(value);
                    flush();
                }
            } catch (err) {
                if (fatalError) {
                    res.destroy(err);
                }
                throw err;
            }
        })();
    }
    isDynamic() {
        return typeof this._result !== "string";
    }
    static fromStatic(value) {
        return new RenderResult(value);
    }
    static empty = RenderResult.fromStatic("");
}
exports.default = RenderResult;

}.call(this) }),
"[project-with-next]/node_modules/next/dist/server/node-web-streams-helper.js (ecmascript, ssr)": (function({ r: __turbopack_require__, x: __turbopack_external_require__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, c: __turbopack_cache__, l: __turbopack_load__, p: process, __dirname, m: module, e: exports }) { !function() {

"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.encodeText = encodeText;
exports.decodeText = decodeText;
exports.readableStreamTee = readableStreamTee;
exports.chainStreams = chainStreams;
exports.streamFromArray = streamFromArray;
exports.streamToString = streamToString;
exports.createBufferedTransformStream = createBufferedTransformStream;
exports.createInsertedHTMLStream = createInsertedHTMLStream;
exports.renderToInitialStream = renderToInitialStream;
exports.createHeadInjectionTransformStream = createHeadInjectionTransformStream;
exports.createDeferredSuffixStream = createDeferredSuffixStream;
exports.createInlineDataStream = createInlineDataStream;
exports.createSuffixStream = createSuffixStream;
exports.createRootLayoutValidatorStream = createRootLayoutValidatorStream;
exports.continueFromInitialStream = continueFromInitialStream;
var _nonNullable = __turbopack_require__("[project-with-next]/node_modules/next/dist/lib/non-nullable.js (ecmascript, ssr)");
function encodeText(input) {
    return new TextEncoder().encode(input);
}
function decodeText(input, textDecoder) {
    return textDecoder ? textDecoder.decode(input, {
        stream: true
    }) : new TextDecoder().decode(input);
}
function readableStreamTee(readable) {
    const transformStream = new TransformStream();
    const transformStream2 = new TransformStream();
    const writer = transformStream.writable.getWriter();
    const writer2 = transformStream2.writable.getWriter();
    const reader = readable.getReader();
    function read() {
        reader.read().then(({ done , value  })=>{
            if (done) {
                writer.close();
                writer2.close();
                return;
            }
            writer.write(value);
            writer2.write(value);
            read();
        });
    }
    read();
    return [
        transformStream.readable,
        transformStream2.readable
    ];
}
function chainStreams(streams) {
    const { readable , writable  } = new TransformStream();
    let promise = Promise.resolve();
    for(let i = 0; i < streams.length; ++i){
        promise = promise.then(()=>streams[i].pipeTo(writable, {
                preventClose: i + 1 < streams.length
            }));
    }
    return readable;
}
function streamFromArray(strings) {
    const { readable , writable  } = new TransformStream();
    const writer = writable.getWriter();
    strings.forEach((str)=>writer.write(encodeText(str)));
    writer.close();
    return readable;
}
async function streamToString(stream) {
    const reader = stream.getReader();
    const textDecoder = new TextDecoder();
    let bufferedString = "";
    while(true){
        const { done , value  } = await reader.read();
        if (done) {
            return bufferedString;
        }
        bufferedString += decodeText(value, textDecoder);
    }
}
function createBufferedTransformStream(transform = (v)=>v) {
    let bufferedString = "";
    let pendingFlush = null;
    const flushBuffer = (controller)=>{
        if (!pendingFlush) {
            pendingFlush = new Promise((resolve)=>{
                setTimeout(async ()=>{
                    const buffered = await transform(bufferedString);
                    controller.enqueue(encodeText(buffered));
                    bufferedString = "";
                    pendingFlush = null;
                    resolve();
                }, 0);
            });
        }
        return pendingFlush;
    };
    const textDecoder = new TextDecoder();
    return new TransformStream({
        transform (chunk, controller) {
            bufferedString += decodeText(chunk, textDecoder);
            flushBuffer(controller);
        },
        flush () {
            if (pendingFlush) {
                return pendingFlush;
            }
        }
    });
}
function createInsertedHTMLStream(getServerInsertedHTML) {
    return new TransformStream({
        async transform (chunk, controller) {
            const insertedHTMLChunk = encodeText(await getServerInsertedHTML());
            controller.enqueue(insertedHTMLChunk);
            controller.enqueue(chunk);
        }
    });
}
function renderToInitialStream({ ReactDOMServer , element , streamOptions  }) {
    return ReactDOMServer.renderToReadableStream(element, streamOptions);
}
function createHeadInjectionTransformStream(inject) {
    let injected = false;
    return new TransformStream({
        async transform (chunk, controller) {
            const content = decodeText(chunk);
            let index;
            if (!injected && (index = content.indexOf("</head")) !== -1) {
                injected = true;
                const injectedContent = content.slice(0, index) + await inject() + content.slice(index);
                controller.enqueue(encodeText(injectedContent));
            } else {
                controller.enqueue(chunk);
            }
        }
    });
}
function createDeferredSuffixStream(suffix) {
    let suffixFlushed = false;
    let suffixFlushTask = null;
    return new TransformStream({
        transform (chunk, controller) {
            controller.enqueue(chunk);
            if (!suffixFlushed && suffix) {
                suffixFlushed = true;
                suffixFlushTask = new Promise((res)=>{
                    setTimeout(()=>{
                        controller.enqueue(encodeText(suffix));
                        res();
                    });
                });
            }
        },
        flush (controller) {
            if (suffixFlushTask) return suffixFlushTask;
            if (!suffixFlushed && suffix) {
                suffixFlushed = true;
                controller.enqueue(encodeText(suffix));
            }
        }
    });
}
function createInlineDataStream(dataStream) {
    let dataStreamFinished = null;
    return new TransformStream({
        transform (chunk, controller) {
            controller.enqueue(chunk);
            if (!dataStreamFinished) {
                const dataStreamReader = dataStream.getReader();
                dataStreamFinished = new Promise((res)=>setTimeout(async ()=>{
                        try {
                            while(true){
                                const { done , value  } = await dataStreamReader.read();
                                if (done) {
                                    return res();
                                }
                                controller.enqueue(value);
                            }
                        } catch (err) {
                            controller.error(err);
                        }
                        res();
                    }, 0));
            }
        },
        flush () {
            if (dataStreamFinished) {
                return dataStreamFinished;
            }
        }
    });
}
function createSuffixStream(suffix) {
    return new TransformStream({
        flush (controller) {
            if (suffix) {
                controller.enqueue(encodeText(suffix));
            }
        }
    });
}
function createRootLayoutValidatorStream(assetPrefix = "", getTree) {
    let foundHtml = false;
    let foundBody = false;
    return new TransformStream({
        async transform (chunk, controller) {
            if (!foundHtml || !foundBody) {
                const content = decodeText(chunk);
                if (!foundHtml && content.includes("<html")) {
                    foundHtml = true;
                }
                if (!foundBody && content.includes("<body")) {
                    foundBody = true;
                }
            }
            controller.enqueue(chunk);
        },
        flush (controller) {
            const missingTags = [
                foundHtml ? null : "html",
                foundBody ? null : "body"
            ].filter(_nonNullable.nonNullable);
            if (missingTags.length > 0) {
                controller.enqueue(encodeText(`<script>self.__next_root_layout_missing_tags_error=${JSON.stringify({
                    missingTags,
                    assetPrefix: assetPrefix ?? "",
                    tree: getTree()
                })}</script>`));
            }
        }
    });
}
async function continueFromInitialStream(renderStream, { suffix , dataStream , generateStaticHTML , getServerInsertedHTML , serverInsertedHTMLToHead , validateRootLayout  }) {
    const closeTag = "</body></html>";
    const suffixUnclosed = suffix ? suffix.split(closeTag)[0] : null;
    if (generateStaticHTML) {
        await renderStream.allReady;
    }
    const transforms = [
        createBufferedTransformStream(),
        getServerInsertedHTML && !serverInsertedHTMLToHead ? createInsertedHTMLStream(getServerInsertedHTML) : null,
        suffixUnclosed != null ? createDeferredSuffixStream(suffixUnclosed) : null,
        dataStream ? createInlineDataStream(dataStream) : null,
        suffixUnclosed != null ? createSuffixStream(closeTag) : null,
        createHeadInjectionTransformStream(async ()=>{
            const serverInsertedHTML = getServerInsertedHTML && serverInsertedHTMLToHead ? await getServerInsertedHTML() : "";
            return serverInsertedHTML;
        }),
        validateRootLayout ? createRootLayoutValidatorStream(validateRootLayout.assetPrefix, validateRootLayout.getTree) : null
    ].filter(_nonNullable.nonNullable);
    return transforms.reduce((readable, transform)=>readable.pipeThrough(transform), renderStream);
}

}.call(this) }),
"[project-with-next]/node_modules/next/dist/server/htmlescape.js (ecmascript, ssr)": (function({ r: __turbopack_require__, x: __turbopack_external_require__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, c: __turbopack_cache__, l: __turbopack_load__, p: process, __dirname, m: module, e: exports }) { !function() {

"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.htmlEscapeJsonString = htmlEscapeJsonString;
exports.ESCAPE_REGEX = void 0;
const ESCAPE_LOOKUP = {
    "&": "\\u0026",
    ">": "\\u003e",
    "<": "\\u003c",
    "\u2028": "\\u2028",
    "\u2029": "\\u2029"
};
const ESCAPE_REGEX = /[&><\u2028\u2029]/g;
exports.ESCAPE_REGEX = ESCAPE_REGEX;
function htmlEscapeJsonString(str) {
    return str.replace(ESCAPE_REGEX, (match)=>ESCAPE_LOOKUP[match]);
}

}.call(this) }),
"[project-with-next]/node_modules/next/dist/server/utils.js (ecmascript, ssr)": (function({ r: __turbopack_require__, x: __turbopack_external_require__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, c: __turbopack_cache__, l: __turbopack_load__, p: process, __dirname, m: module, e: exports }) { !function() {

"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.isBlockedPage = isBlockedPage;
exports.cleanAmpPath = cleanAmpPath;
exports.shouldUseReactRoot = void 0;
var _react = _interopRequireDefault(__turbopack_require__("[project-with-next]/node_modules/next/dist/compiled/react/index.js (ecmascript, ssr)"));
var _constants = __turbopack_require__("[project-with-next]/node_modules/next/dist/shared/lib/constants.js (ecmascript, ssr)");
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function isBlockedPage(pathname) {
    return _constants.BLOCKED_PAGES.includes(pathname);
}
function cleanAmpPath(pathname) {
    if (pathname.match(/\?amp=(y|yes|true|1)/)) {
        pathname = pathname.replace(/\?amp=(y|yes|true|1)&?/, "?");
    }
    if (pathname.match(/&amp=(y|yes|true|1)/)) {
        pathname = pathname.replace(/&amp=(y|yes|true|1)/, "");
    }
    pathname = pathname.replace(/\?$/, "");
    return pathname;
}
const shouldUseReactRoot = parseInt(_react.default.version) >= 18;
exports.shouldUseReactRoot = shouldUseReactRoot;

}.call(this) }),
"[project-with-next]/node_modules/next/dist/server/internal-utils.js (ecmascript, ssr)": (function({ r: __turbopack_require__, x: __turbopack_external_require__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, c: __turbopack_cache__, l: __turbopack_load__, p: process, __dirname, m: module, e: exports }) { !function() {

"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.stripInternalQueries = stripInternalQueries;
exports.stripInternalSearchParams = stripInternalSearchParams;
const INTERNAL_QUERY_NAMES = [
    "__nextFallback",
    "__nextLocale",
    "__nextDefaultLocale",
    "__nextIsNotFound",
    "__rsc__",
    "__next_router_state_tree__",
    "__next_router_prefetch__"
];
const EXTENDED_INTERNAL_QUERY_NAMES = [
    "__nextDataReq"
];
function stripInternalQueries(query) {
    for (const name of INTERNAL_QUERY_NAMES){
        delete query[name];
    }
}
function stripInternalSearchParams(searchParams, extended) {
    for (const name of INTERNAL_QUERY_NAMES){
        searchParams.delete(name);
    }
    if (extended) {
        for (const name of EXTENDED_INTERNAL_QUERY_NAMES){
            searchParams.delete(name);
        }
    }
    return searchParams;
}

}.call(this) }),
"[project-with-next]/node_modules/next/dist/server/web/spec-extension/cookies.js (ecmascript, ssr)": (function({ r: __turbopack_require__, x: __turbopack_external_require__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, c: __turbopack_cache__, l: __turbopack_load__, p: process, __dirname, m: module, e: exports }) { !function() {

"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
var _cookie = _interopRequireDefault(__turbopack_require__("[project-with-next]/node_modules/next/dist/compiled/cookie/index.js (ecmascript, ssr)"));
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
const normalizeCookieOptions = (options)=>{
    options = Object.assign({}, options);
    if (options.maxAge) {
        options.expires = new Date(Date.now() + options.maxAge * 1000);
    }
    if (options.path == null) {
        options.path = "/";
    }
    return options;
};
const serializeValue = (value)=>typeof value === "object" ? `j:${JSON.stringify(value)}` : String(value);
const serializeExpiredCookie = (key, options = {})=>_cookie.default.serialize(key, "", {
        expires: new Date(0),
        path: "/",
        ...options
    });
const deserializeCookie = (input)=>{
    const value = input.headers.get("set-cookie");
    return value !== undefined && value !== null ? value.split(", ") : [];
};
const serializeCookie = (input)=>input.join(", ");
class Cookies extends Map {
    constructor(input){
        const parsedInput = typeof input === "string" ? _cookie.default.parse(input) : {};
        super(Object.entries(parsedInput));
    }
    set(key, value, options = {}) {
        return super.set(key, _cookie.default.serialize(key, serializeValue(value), normalizeCookieOptions(options)));
    }
    [Symbol.for("edge-runtime.inspect.custom")]() {
        return Object.fromEntries(this.entries());
    }
}
exports.Cookies = Cookies;
class NextCookies extends Cookies {
    constructor(response){
        super(response.headers.get("cookie"));
        this.response = response;
    }
    get = (...args)=>{
        return this.getWithOptions(...args).value;
    };
    getWithOptions = (...args)=>{
        const raw = super.get(...args);
        if (typeof raw !== "string") return {
            value: raw,
            options: {}
        };
        const { [args[0]]: value , ...options } = _cookie.default.parse(raw);
        return {
            value,
            options
        };
    };
    set = (...args)=>{
        const isAlreadyAdded = super.has(args[0]);
        super.set(...args);
        const currentCookie = super.get(args[0]);
        if (typeof currentCookie !== "string") {
            throw new Error(`Invariant: failed to generate cookie for ${JSON.stringify(args)}`);
        }
        if (isAlreadyAdded) {
            const setCookie = serializeCookie(deserializeCookie(this.response).filter((value)=>!value.startsWith(`${args[0]}=`)));
            if (setCookie) {
                this.response.headers.set("set-cookie", [
                    currentCookie,
                    setCookie
                ].join(", "));
            } else {
                this.response.headers.set("set-cookie", currentCookie);
            }
        } else {
            this.response.headers.append("set-cookie", currentCookie);
        }
        return this;
    };
    delete = (key, options = {})=>{
        const isDeleted = super.delete(key);
        if (isDeleted) {
            const setCookie = serializeCookie(deserializeCookie(this.response).filter((value)=>!value.startsWith(`${key}=`)));
            const expiredCookie = serializeExpiredCookie(key, options);
            this.response.headers.set("set-cookie", [
                expiredCookie,
                setCookie
            ].join(", "));
        }
        return isDeleted;
    };
    clear = (options = {})=>{
        const expiredCookies = Array.from(super.keys()).map((key)=>serializeExpiredCookie(key, options)).join(", ");
        if (expiredCookies) this.response.headers.set("set-cookie", expiredCookies);
        return super.clear();
    };
}
exports.NextCookies = NextCookies;

}.call(this) }),
"[project-with-next]/node_modules/next/dist/server/api-utils/node.js (ecmascript, ssr)": (function({ r: __turbopack_require__, x: __turbopack_external_require__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, c: __turbopack_cache__, l: __turbopack_load__, p: process, __dirname, m: module, e: exports }) { !function() {

"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.tryGetPreviewData = tryGetPreviewData;
exports.parseBody = parseBody;
exports.apiResolver = apiResolver;
var _ = __turbopack_require__("[project-with-next]/node_modules/next/dist/server/api-utils/index.js (ecmascript, ssr)");
var _bytes = _interopRequireDefault(__turbopack_require__("[project-with-next]/node_modules/next/dist/compiled/bytes/index.js (ecmascript, ssr)"));
var _etag = __turbopack_require__("[project-with-next]/node_modules/next/dist/server/lib/etag.js (ecmascript, ssr)");
var _sendPayload = __turbopack_require__("[project-with-next]/node_modules/next/dist/server/send-payload/index.js (ecmascript, ssr)");
var _stream = __turbopack_external_require__("stream");
var _contentType = __turbopack_require__("[project-with-next]/node_modules/next/dist/compiled/content-type/index.js (ecmascript, ssr)");
var _isError = _interopRequireDefault(__turbopack_require__("[project-with-next]/node_modules/next/dist/lib/is-error.js (ecmascript, ssr)"));
var _utils = __turbopack_require__("[project-with-next]/node_modules/next/dist/shared/lib/utils.js (ecmascript, ssr)");
var _interopDefault = __turbopack_require__("[project-with-next]/node_modules/next/dist/lib/interop-default.js (ecmascript, ssr)");
var _index = __turbopack_require__("[project-with-next]/node_modules/next/dist/server/api-utils/index.js (ecmascript, ssr)");
var _mockRequest = __turbopack_require__("[project-with-next]/node_modules/next/dist/server/lib/mock-request.js (ecmascript, ssr)");
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function tryGetPreviewData(req, res, options) {
    if (options && (0, _).checkIsManualRevalidate(req, options).isManualRevalidate) {
        return false;
    }
    if (_index.SYMBOL_PREVIEW_DATA in req) {
        return req[_index.SYMBOL_PREVIEW_DATA];
    }
    const getCookies = (0, _index).getCookieParser(req.headers);
    let cookies;
    try {
        cookies = getCookies();
    } catch  {
        return false;
    }
    const hasBypass = _index.COOKIE_NAME_PRERENDER_BYPASS in cookies;
    const hasData = _index.COOKIE_NAME_PRERENDER_DATA in cookies;
    if (!(hasBypass || hasData)) {
        return false;
    }
    if (hasBypass !== hasData) {
        (0, _index).clearPreviewData(res);
        return false;
    }
    if (cookies[_index.COOKIE_NAME_PRERENDER_BYPASS] !== options.previewModeId) {
        (0, _index).clearPreviewData(res);
        return false;
    }
    const tokenPreviewData = cookies[_index.COOKIE_NAME_PRERENDER_DATA];
    let encryptedPreviewData;
    try {
        const jsonwebtoken = __turbopack_require__("[project-with-next]/node_modules/next/dist/compiled/jsonwebtoken/index.js (ecmascript, ssr)");
        encryptedPreviewData = jsonwebtoken.verify(tokenPreviewData, options.previewModeSigningKey);
    } catch  {
        (0, _index).clearPreviewData(res);
        return false;
    }
    const { decryptWithSecret  } = __turbopack_require__("[project-with-next]/node_modules/next/dist/server/crypto-utils.js (ecmascript, ssr)");
    const decryptedPreviewData = decryptWithSecret(Buffer.from(options.previewModeEncryptionKey), encryptedPreviewData.data);
    try {
        const data = JSON.parse(decryptedPreviewData);
        Object.defineProperty(req, _index.SYMBOL_PREVIEW_DATA, {
            value: data,
            enumerable: false
        });
        return data;
    } catch  {
        return false;
    }
}
function parseJson(str) {
    if (str.length === 0) {
        return {};
    }
    try {
        return JSON.parse(str);
    } catch (e) {
        throw new _index.ApiError(400, "Invalid JSON");
    }
}
async function parseBody(req, limit) {
    let contentType;
    try {
        contentType = (0, _contentType).parse(req.headers["content-type"] || "text/plain");
    } catch  {
        contentType = (0, _contentType).parse("text/plain");
    }
    const { type , parameters  } = contentType;
    const encoding = parameters.charset || "utf-8";
    let buffer;
    try {
        const getRawBody = __turbopack_require__("[project-with-next]/node_modules/next/dist/compiled/raw-body/index.js (ecmascript, ssr)");
        buffer = await getRawBody(req, {
            encoding,
            limit
        });
    } catch (e) {
        if ((0, _isError).default(e) && e.type === "entity.too.large") {
            throw new _index.ApiError(413, `Body exceeded ${limit} limit`);
        } else {
            throw new _index.ApiError(400, "Invalid body");
        }
    }
    const body = buffer.toString();
    if (type === "application/json" || type === "application/ld+json") {
        return parseJson(body);
    } else if (type === "application/x-www-form-urlencoded") {
        const qs = __turbopack_external_require__("querystring");
        return qs.decode(body);
    } else {
        return body;
    }
}
function getMaxContentLength(responseLimit) {
    if (responseLimit && typeof responseLimit !== "boolean") {
        return _bytes.default.parse(responseLimit);
    }
    return _index.RESPONSE_LIMIT_DEFAULT;
}
function sendData(req, res, body) {
    if (body === null || body === undefined) {
        res.end();
        return;
    }
    if (res.statusCode === 204 || res.statusCode === 304) {
        res.removeHeader("Content-Type");
        res.removeHeader("Content-Length");
        res.removeHeader("Transfer-Encoding");
        if (process.env.NODE_ENV === "development" && body) {
            console.warn(`A body was attempted to be set with a 204 statusCode for ${req.url}, this is invalid and the body was ignored.\n` + `See more info here https://nextjs.org/docs/messages/invalid-api-status-body`);
        }
        res.end();
        return;
    }
    const contentType = res.getHeader("Content-Type");
    if (body instanceof _stream.Stream) {
        if (!contentType) {
            res.setHeader("Content-Type", "application/octet-stream");
        }
        body.pipe(res);
        return;
    }
    const isJSONLike = [
        "object",
        "number",
        "boolean"
    ].includes(typeof body);
    const stringifiedBody = isJSONLike ? JSON.stringify(body) : body;
    const etag = (0, _etag).generateETag(stringifiedBody);
    if ((0, _sendPayload).sendEtagResponse(req, res, etag)) {
        return;
    }
    if (Buffer.isBuffer(body)) {
        if (!contentType) {
            res.setHeader("Content-Type", "application/octet-stream");
        }
        res.setHeader("Content-Length", body.length);
        res.end(body);
        return;
    }
    if (isJSONLike) {
        res.setHeader("Content-Type", "application/json; charset=utf-8");
    }
    res.setHeader("Content-Length", Buffer.byteLength(stringifiedBody));
    res.end(stringifiedBody);
}
function sendJson(res, jsonBody) {
    res.setHeader("Content-Type", "application/json; charset=utf-8");
    res.send(JSON.stringify(jsonBody));
}
function isNotValidData(str) {
    return typeof str !== "string" || str.length < 16;
}
function setPreviewData(res, data, options) {
    if (isNotValidData(options.previewModeId)) {
        throw new Error("invariant: invalid previewModeId");
    }
    if (isNotValidData(options.previewModeEncryptionKey)) {
        throw new Error("invariant: invalid previewModeEncryptionKey");
    }
    if (isNotValidData(options.previewModeSigningKey)) {
        throw new Error("invariant: invalid previewModeSigningKey");
    }
    const jsonwebtoken = __turbopack_require__("[project-with-next]/node_modules/next/dist/compiled/jsonwebtoken/index.js (ecmascript, ssr)");
    const { encryptWithSecret  } = __turbopack_require__("[project-with-next]/node_modules/next/dist/server/crypto-utils.js (ecmascript, ssr)");
    const payload = jsonwebtoken.sign({
        data: encryptWithSecret(Buffer.from(options.previewModeEncryptionKey), JSON.stringify(data))
    }, options.previewModeSigningKey, {
        algorithm: "HS256",
        ...options.maxAge !== undefined ? {
            expiresIn: options.maxAge
        } : undefined
    });
    if (payload.length > 2048) {
        throw new Error(`Preview data is limited to 2KB currently, reduce how much data you are storing as preview data to continue`);
    }
    const { serialize  } = __turbopack_require__("[project-with-next]/node_modules/next/dist/compiled/cookie/index.js (ecmascript, ssr)");
    const previous = res.getHeader("Set-Cookie");
    res.setHeader(`Set-Cookie`, [
        ...typeof previous === "string" ? [
            previous
        ] : Array.isArray(previous) ? previous : [],
        serialize(_index.COOKIE_NAME_PRERENDER_BYPASS, options.previewModeId, {
            httpOnly: true,
            sameSite: process.env.NODE_ENV !== "development" ? "none" : "lax",
            secure: process.env.NODE_ENV !== "development",
            path: "/",
            ...options.maxAge !== undefined ? {
                maxAge: options.maxAge
            } : undefined,
            ...options.path !== undefined ? {
                path: options.path
            } : undefined
        }),
        serialize(_index.COOKIE_NAME_PRERENDER_DATA, payload, {
            httpOnly: true,
            sameSite: process.env.NODE_ENV !== "development" ? "none" : "lax",
            secure: process.env.NODE_ENV !== "development",
            path: "/",
            ...options.maxAge !== undefined ? {
                maxAge: options.maxAge
            } : undefined,
            ...options.path !== undefined ? {
                path: options.path
            } : undefined
        })
    ]);
    return res;
}
async function revalidate(urlPath, opts, req, context) {
    if (typeof urlPath !== "string" || !urlPath.startsWith("/")) {
        throw new Error(`Invalid urlPath provided to revalidate(), must be a path e.g. /blog/post-1, received ${urlPath}`);
    }
    const revalidateHeaders = {
        [_index.PRERENDER_REVALIDATE_HEADER]: context.previewModeId,
        ...opts.unstable_onlyGenerated ? {
            [_.PRERENDER_REVALIDATE_ONLY_GENERATED_HEADER]: "1"
        } : {}
    };
    try {
        if (context.trustHostHeader) {
            const res = await fetch(`https://${req.headers.host}${urlPath}`, {
                method: "HEAD",
                headers: {
                    ...revalidateHeaders,
                    cookie: req.headers.cookie || ""
                }
            });
            const cacheHeader = res.headers.get("x-vercel-cache") || res.headers.get("x-nextjs-cache");
            if ((cacheHeader == null ? void 0 : cacheHeader.toUpperCase()) !== "REVALIDATED" && !(res.status === 404 && opts.unstable_onlyGenerated)) {
                throw new Error(`Invalid response ${res.status}`);
            }
        } else if (context.revalidate) {
            const { req: mockReq , res: mockRes , streamPromise  } = (0, _mockRequest).mockRequest(urlPath, revalidateHeaders, "GET");
            await context.revalidate(mockReq, mockRes);
            await streamPromise;
            if (mockRes.getHeader("x-nextjs-cache") !== "REVALIDATED" && !(mockRes.statusCode === 404 && opts.unstable_onlyGenerated)) {
                throw new Error(`Invalid response ${mockRes.statusCode}`);
            }
        } else {
            throw new Error(`Invariant: required internal revalidate method not passed to api-utils`);
        }
    } catch (err) {
        throw new Error(`Failed to revalidate ${urlPath}: ${(0, _isError).default(err) ? err.message : err}`);
    }
}
async function apiResolver(req, res, query, resolverModule, apiContext, propagateError, dev, page) {
    const apiReq = req;
    const apiRes = res;
    try {
        var ref, ref1, ref2;
        if (!resolverModule) {
            res.statusCode = 404;
            res.end("Not Found");
            return;
        }
        const config = resolverModule.config || {};
        const bodyParser = ((ref = config.api) == null ? void 0 : ref.bodyParser) !== false;
        const responseLimit = ((ref1 = config.api) == null ? void 0 : ref1.responseLimit) ?? true;
        const externalResolver = ((ref2 = config.api) == null ? void 0 : ref2.externalResolver) || false;
        (0, _index).setLazyProp({
            req: apiReq
        }, "cookies", (0, _index).getCookieParser(req.headers));
        apiReq.query = query;
        (0, _index).setLazyProp({
            req: apiReq
        }, "previewData", ()=>tryGetPreviewData(req, res, apiContext));
        (0, _index).setLazyProp({
            req: apiReq
        }, "preview", ()=>apiReq.previewData !== false ? true : undefined);
        if (bodyParser && !apiReq.body) {
            apiReq.body = await parseBody(apiReq, config.api && config.api.bodyParser && config.api.bodyParser.sizeLimit ? config.api.bodyParser.sizeLimit : "1mb");
        }
        let contentLength = 0;
        const maxContentLength = getMaxContentLength(responseLimit);
        const writeData = apiRes.write;
        const endResponse = apiRes.end;
        apiRes.write = (...args)=>{
            contentLength += Buffer.byteLength(args[0] || "");
            return writeData.apply(apiRes, args);
        };
        apiRes.end = (...args)=>{
            if (args.length && typeof args[0] !== "function") {
                contentLength += Buffer.byteLength(args[0] || "");
            }
            if (responseLimit && contentLength >= maxContentLength) {
                console.warn(`API response for ${req.url} exceeds ${_bytes.default.format(maxContentLength)}. API Routes are meant to respond quickly. https://nextjs.org/docs/messages/api-routes-response-size-limit`);
            }
            endResponse.apply(apiRes, args);
        };
        apiRes.status = (statusCode)=>(0, _index).sendStatusCode(apiRes, statusCode);
        apiRes.send = (data)=>sendData(apiReq, apiRes, data);
        apiRes.json = (data)=>sendJson(apiRes, data);
        apiRes.redirect = (statusOrUrl, url)=>(0, _index).redirect(apiRes, statusOrUrl, url);
        apiRes.setPreviewData = (data, options = {})=>setPreviewData(apiRes, data, Object.assign({}, apiContext, options));
        apiRes.clearPreviewData = (options = {})=>(0, _index).clearPreviewData(apiRes, options);
        apiRes.revalidate = (urlPath, opts)=>revalidate(urlPath, opts || {}, req, apiContext);
        apiRes.unstable_revalidate = ()=>{
            throw new Error(`"unstable_revalidate" has been renamed to "revalidate" see more info here: https://nextjs.org/docs/basic-features/data-fetching/incremental-static-regeneration#on-demand-revalidation`);
        };
        const resolver = (0, _interopDefault).interopDefault(resolverModule);
        let wasPiped = false;
        if (process.env.NODE_ENV !== "production") {
            res.once("pipe", ()=>wasPiped = true);
        }
        await resolver(req, res);
        if (process.env.NODE_ENV !== "production" && !externalResolver && !(0, _utils).isResSent(res) && !wasPiped) {
            console.warn(`API resolved without sending a response for ${req.url}, this may result in stalled requests.`);
        }
    } catch (err) {
        if (err instanceof _index.ApiError) {
            (0, _index).sendError(apiRes, err.statusCode, err.message);
        } else {
            if (dev) {
                if ((0, _isError).default(err)) {
                    err.page = page;
                }
                throw err;
            }
            console.error(err);
            if (propagateError) {
                throw err;
            }
            (0, _index).sendError(apiRes, 500, "Internal Server Error");
        }
    }
}

}.call(this) }),
"[project-with-next]/node_modules/next/dist/server/api-utils/index.js (ecmascript, ssr)": (function({ r: __turbopack_require__, x: __turbopack_external_require__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, c: __turbopack_cache__, l: __turbopack_load__, p: process, __dirname, m: module, e: exports }) { !function() {

"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.getCookieParser = getCookieParser;
exports.sendStatusCode = sendStatusCode;
exports.redirect = redirect;
exports.checkIsManualRevalidate = checkIsManualRevalidate;
exports.clearPreviewData = clearPreviewData;
exports.sendError = sendError;
exports.setLazyProp = setLazyProp;
exports.SYMBOL_CLEARED_COOKIES = exports.SYMBOL_PREVIEW_DATA = exports.RESPONSE_LIMIT_DEFAULT = exports.COOKIE_NAME_PRERENDER_DATA = exports.COOKIE_NAME_PRERENDER_BYPASS = exports.PRERENDER_REVALIDATE_ONLY_GENERATED_HEADER = exports.PRERENDER_REVALIDATE_HEADER = void 0;
function getCookieParser(headers) {
    return function parseCookie() {
        const header = headers.cookie;
        if (!header) {
            return {};
        }
        const { parse: parseCookieFn  } = __turbopack_require__("[project-with-next]/node_modules/next/dist/compiled/cookie/index.js (ecmascript, ssr)");
        return parseCookieFn(Array.isArray(header) ? header.join(";") : header);
    };
}
function sendStatusCode(res, statusCode) {
    res.statusCode = statusCode;
    return res;
}
function redirect(res, statusOrUrl, url) {
    if (typeof statusOrUrl === "string") {
        url = statusOrUrl;
        statusOrUrl = 307;
    }
    if (typeof statusOrUrl !== "number" || typeof url !== "string") {
        throw new Error(`Invalid redirect arguments. Please use a single argument URL, e.g. res.redirect('/destination') or use a status code and URL, e.g. res.redirect(307, '/destination').`);
    }
    res.writeHead(statusOrUrl, {
        Location: url
    });
    res.write(url);
    res.end();
    return res;
}
const PRERENDER_REVALIDATE_HEADER = "x-prerender-revalidate";
exports.PRERENDER_REVALIDATE_HEADER = PRERENDER_REVALIDATE_HEADER;
const PRERENDER_REVALIDATE_ONLY_GENERATED_HEADER = "x-prerender-revalidate-if-generated";
exports.PRERENDER_REVALIDATE_ONLY_GENERATED_HEADER = PRERENDER_REVALIDATE_ONLY_GENERATED_HEADER;
function checkIsManualRevalidate(req, previewProps) {
    return {
        isManualRevalidate: req.headers[PRERENDER_REVALIDATE_HEADER] === previewProps.previewModeId,
        revalidateOnlyGenerated: !!req.headers[PRERENDER_REVALIDATE_ONLY_GENERATED_HEADER]
    };
}
const COOKIE_NAME_PRERENDER_BYPASS = `__prerender_bypass`;
exports.COOKIE_NAME_PRERENDER_BYPASS = COOKIE_NAME_PRERENDER_BYPASS;
const COOKIE_NAME_PRERENDER_DATA = `__next_preview_data`;
exports.COOKIE_NAME_PRERENDER_DATA = COOKIE_NAME_PRERENDER_DATA;
const RESPONSE_LIMIT_DEFAULT = 4 * 1024 * 1024;
exports.RESPONSE_LIMIT_DEFAULT = RESPONSE_LIMIT_DEFAULT;
const SYMBOL_PREVIEW_DATA = Symbol(COOKIE_NAME_PRERENDER_DATA);
exports.SYMBOL_PREVIEW_DATA = SYMBOL_PREVIEW_DATA;
const SYMBOL_CLEARED_COOKIES = Symbol(COOKIE_NAME_PRERENDER_BYPASS);
exports.SYMBOL_CLEARED_COOKIES = SYMBOL_CLEARED_COOKIES;
function clearPreviewData(res, options = {}) {
    if (SYMBOL_CLEARED_COOKIES in res) {
        return res;
    }
    const { serialize  } = __turbopack_require__("[project-with-next]/node_modules/next/dist/compiled/cookie/index.js (ecmascript, ssr)");
    const previous = res.getHeader("Set-Cookie");
    res.setHeader(`Set-Cookie`, [
        ...typeof previous === "string" ? [
            previous
        ] : Array.isArray(previous) ? previous : [],
        serialize(COOKIE_NAME_PRERENDER_BYPASS, "", {
            expires: new Date(0),
            httpOnly: true,
            sameSite: process.env.NODE_ENV !== "development" ? "none" : "lax",
            secure: process.env.NODE_ENV !== "development",
            path: "/",
            ...options.path !== undefined ? {
                path: options.path
            } : undefined
        }),
        serialize(COOKIE_NAME_PRERENDER_DATA, "", {
            expires: new Date(0),
            httpOnly: true,
            sameSite: process.env.NODE_ENV !== "development" ? "none" : "lax",
            secure: process.env.NODE_ENV !== "development",
            path: "/",
            ...options.path !== undefined ? {
                path: options.path
            } : undefined
        })
    ]);
    Object.defineProperty(res, SYMBOL_CLEARED_COOKIES, {
        value: true,
        enumerable: false
    });
    return res;
}
class ApiError extends Error {
    constructor(statusCode, message){
        super(message);
        this.statusCode = statusCode;
    }
}
exports.ApiError = ApiError;
function sendError(res, statusCode, message) {
    res.statusCode = statusCode;
    res.statusMessage = message;
    res.end(message);
}
function setLazyProp({ req  }, prop, getter) {
    const opts = {
        configurable: true,
        enumerable: true
    };
    const optsReset = {
        ...opts,
        writable: true
    };
    Object.defineProperty(req, prop, {
        ...opts,
        get: ()=>{
            const value = getter();
            Object.defineProperty(req, prop, {
                ...optsReset,
                value
            });
            return value;
        },
        set: (value)=>{
            Object.defineProperty(req, prop, {
                ...optsReset,
                value
            });
        }
    });
}

}.call(this) }),
"[project-with-next]/node_modules/next/dist/server/lib/etag.js (ecmascript, ssr)": (function({ r: __turbopack_require__, x: __turbopack_external_require__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, c: __turbopack_cache__, l: __turbopack_load__, p: process, __dirname, m: module, e: exports }) { !function() {

"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.generateETag = exports.fnv1a52 = void 0;
const fnv1a52 = (str)=>{
    const len = str.length;
    let i = 0, t0 = 0, v0 = 0x2325, t1 = 0, v1 = 0x8422, t2 = 0, v2 = 0x9ce4, t3 = 0, v3 = 0xcbf2;
    while(i < len){
        v0 ^= str.charCodeAt(i++);
        t0 = v0 * 435;
        t1 = v1 * 435;
        t2 = v2 * 435;
        t3 = v3 * 435;
        t2 += v0 << 8;
        t3 += v1 << 8;
        t1 += t0 >>> 16;
        v0 = t0 & 65535;
        t2 += t1 >>> 16;
        v1 = t1 & 65535;
        v3 = t3 + (t2 >>> 16) & 65535;
        v2 = t2 & 65535;
    }
    return (v3 & 15) * 281474976710656 + v2 * 4294967296 + v1 * 65536 + (v0 ^ v3 >> 4);
};
exports.fnv1a52 = fnv1a52;
const generateETag = (payload, weak = false)=>{
    const prefix = weak ? 'W/"' : '"';
    return prefix + fnv1a52(payload).toString(36) + payload.length.toString(36) + '"';
};
exports.generateETag = generateETag;

}.call(this) }),
"[project-with-next]/node_modules/next/dist/server/send-payload/index.js (ecmascript, ssr)": (function({ r: __turbopack_require__, x: __turbopack_external_require__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, c: __turbopack_cache__, l: __turbopack_load__, p: process, __dirname, m: module, e: exports }) { !function() {

"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "setRevalidateHeaders", {
    enumerable: true,
    get: function() {
        return _revalidateHeaders.setRevalidateHeaders;
    }
});
exports.sendEtagResponse = sendEtagResponse;
exports.sendRenderResult = sendRenderResult;
var _utils = __turbopack_require__("[project-with-next]/node_modules/next/dist/shared/lib/utils.js (ecmascript, ssr)");
var _etag = __turbopack_require__("[project-with-next]/node_modules/next/dist/server/lib/etag.js (ecmascript, ssr)");
var _fresh = _interopRequireDefault(__turbopack_require__("[project-with-next]/node_modules/next/dist/compiled/fresh/index.js (ecmascript, ssr)"));
var _revalidateHeaders = __turbopack_require__("[project-with-next]/node_modules/next/dist/server/send-payload/revalidate-headers.js (ecmascript, ssr)");
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function sendEtagResponse(req, res, etag) {
    if (etag) {
        res.setHeader("ETag", etag);
    }
    if ((0, _fresh).default(req.headers, {
        etag
    })) {
        res.statusCode = 304;
        res.end();
        return true;
    }
    return false;
}
async function sendRenderResult({ req , res , result , type , generateEtags , poweredByHeader , options  }) {
    if ((0, _utils).isResSent(res)) {
        return;
    }
    if (poweredByHeader && type === "html") {
        res.setHeader("X-Powered-By", "Next.js");
    }
    const payload = result.isDynamic() ? null : await result.toUnchunkedString();
    if (payload) {
        const etag = generateEtags ? (0, _etag).generateETag(payload) : undefined;
        if (sendEtagResponse(req, res, etag)) {
            return;
        }
    }
    const resultContentType = result.contentType();
    if (!res.getHeader("Content-Type")) {
        res.setHeader("Content-Type", resultContentType ? resultContentType : type === "rsc" ? "application/octet-stream" : type === "json" ? "application/json" : "text/html; charset=utf-8");
    }
    if (payload) {
        res.setHeader("Content-Length", Buffer.byteLength(payload));
    }
    if (options != null) {
        (0, _revalidateHeaders).setRevalidateHeaders(res, options);
    }
    if (req.method === "HEAD") {
        res.end(null);
    } else if (payload) {
        res.end(payload);
    } else {
        await result.pipe(res);
    }
}

}.call(this) }),
"[project-with-next]/node_modules/next/dist/server/lib/mock-request.js (ecmascript, ssr)": (function({ r: __turbopack_require__, x: __turbopack_external_require__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, c: __turbopack_cache__, l: __turbopack_load__, p: process, __dirname, m: module, e: exports }) { !function() {

"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.mockRequest = mockRequest;
var _stream = _interopRequireDefault(__turbopack_external_require__("stream"));
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function mockRequest(requestUrl, requestHeaders, requestMethod, requestConnection) {
    const resBuffers = [];
    const mockRes = new _stream.default.Writable();
    const isStreamFinished = new Promise(function(resolve, reject) {
        mockRes.on("finish", ()=>resolve(true));
        mockRes.on("end", ()=>resolve(true));
        mockRes.on("error", (err)=>reject(err));
    });
    mockRes.write = (chunk)=>{
        resBuffers.push(Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk));
    };
    mockRes._write = (chunk, _encoding, callback)=>{
        mockRes.write(chunk);
        callback();
    };
    const mockHeaders = {};
    mockRes.writeHead = (_status, _headers)=>Object.assign(mockHeaders, _headers);
    mockRes.getHeader = (name)=>mockHeaders[name.toLowerCase()];
    mockRes.getHeaders = ()=>mockHeaders;
    mockRes.getHeaderNames = ()=>Object.keys(mockHeaders);
    mockRes.setHeader = (name, value)=>mockHeaders[name.toLowerCase()] = value;
    mockRes.removeHeader = (name)=>{
        delete mockHeaders[name.toLowerCase()];
    };
    mockRes._implicitHeader = ()=>{};
    mockRes.connection = requestConnection;
    mockRes.finished = false;
    mockRes.statusCode = 200;
    const mockReq = new _stream.default.Readable();
    mockReq._read = ()=>{
        mockReq.emit("end");
        mockReq.emit("close");
        return Buffer.from("");
    };
    mockReq.headers = requestHeaders;
    mockReq.method = requestMethod;
    mockReq.url = requestUrl;
    mockReq.connection = requestConnection;
    return {
        resBuffers,
        req: mockReq,
        res: mockRes,
        streamPromise: isStreamFinished
    };
}

}.call(this) }),
"[project-with-next]/node_modules/next/dist/server/crypto-utils.js (ecmascript, ssr)": (function({ r: __turbopack_require__, x: __turbopack_external_require__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, c: __turbopack_cache__, l: __turbopack_load__, p: process, __dirname, m: module, e: exports }) { !function() {

"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.encryptWithSecret = encryptWithSecret;
exports.decryptWithSecret = decryptWithSecret;
var _crypto = _interopRequireDefault(__turbopack_external_require__("crypto"));
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
const CIPHER_ALGORITHM = `aes-256-gcm`, CIPHER_KEY_LENGTH = 32, CIPHER_IV_LENGTH = 16, CIPHER_TAG_LENGTH = 16, CIPHER_SALT_LENGTH = 64;
const PBKDF2_ITERATIONS = 100000;
function encryptWithSecret(secret, data) {
    const iv = _crypto.default.randomBytes(CIPHER_IV_LENGTH);
    const salt = _crypto.default.randomBytes(CIPHER_SALT_LENGTH);
    const key = _crypto.default.pbkdf2Sync(secret, salt, PBKDF2_ITERATIONS, CIPHER_KEY_LENGTH, `sha512`);
    const cipher = _crypto.default.createCipheriv(CIPHER_ALGORITHM, key, iv);
    const encrypted = Buffer.concat([
        cipher.update(data, `utf8`),
        cipher.final()
    ]);
    const tag = cipher.getAuthTag();
    return Buffer.concat([
        salt,
        iv,
        tag,
        encrypted
    ]).toString(`hex`);
}
function decryptWithSecret(secret, encryptedData) {
    const buffer = Buffer.from(encryptedData, `hex`);
    const salt = buffer.slice(0, CIPHER_SALT_LENGTH);
    const iv = buffer.slice(CIPHER_SALT_LENGTH, CIPHER_SALT_LENGTH + CIPHER_IV_LENGTH);
    const tag = buffer.slice(CIPHER_SALT_LENGTH + CIPHER_IV_LENGTH, CIPHER_SALT_LENGTH + CIPHER_IV_LENGTH + CIPHER_TAG_LENGTH);
    const encrypted = buffer.slice(CIPHER_SALT_LENGTH + CIPHER_IV_LENGTH + CIPHER_TAG_LENGTH);
    const key = _crypto.default.pbkdf2Sync(secret, salt, PBKDF2_ITERATIONS, CIPHER_KEY_LENGTH, `sha512`);
    const decipher = _crypto.default.createDecipheriv(CIPHER_ALGORITHM, key, iv);
    decipher.setAuthTag(tag);
    return decipher.update(encrypted) + decipher.final(`utf8`);
}

}.call(this) }),
"[project-with-next]/node_modules/next/dist/server/send-payload/revalidate-headers.js (ecmascript, ssr)": (function({ r: __turbopack_require__, x: __turbopack_external_require__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, c: __turbopack_cache__, l: __turbopack_load__, p: process, __dirname, m: module, e: exports }) { !function() {

"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.setRevalidateHeaders = setRevalidateHeaders;
function setRevalidateHeaders(res, options) {
    if (options.private || options.stateful) {
        if (options.private || !res.hasHeader("Cache-Control")) {
            res.setHeader("Cache-Control", `private, no-cache, no-store, max-age=0, must-revalidate`);
        }
    } else if (typeof options.revalidate === "number") {
        if (options.revalidate < 1) {
            throw new Error(`invariant: invalid Cache-Control duration provided: ${options.revalidate} < 1`);
        }
        res.setHeader("Cache-Control", `s-maxage=${options.revalidate}, stale-while-revalidate`);
    } else if (options.revalidate === false) {
        res.setHeader("Cache-Control", `s-maxage=31536000, stale-while-revalidate`);
    }
}

}.call(this) }),
}, ({ loadedChunks, instantiateRuntimeModule }) => {
    if(!(true && loadedChunks.has("chunks/ssr/node_modules_next_dist_feef3e.js") && loadedChunks.has("chunks/ssr/node_modules_next_dist_10dde3.js") && loadedChunks.has("chunks/ssr/node_modules_next_dist_88ef14.js") && loadedChunks.has("chunks/ssr/node_modules_795f60.js") && loadedChunks.has("chunks/ssr/node_modules_2d9e30.js") && loadedChunks.has("chunks/ssr/node_modules_next_dist_compiled_e91a99.js") && loadedChunks.has("chunks/ssr/node_modules_next_dist_client_components_1b02ff.js") && loadedChunks.has("chunks/ssr/node_modules_next_dist_decf83.js") && loadedChunks.has("chunks/ssr/_50320c.js") && loadedChunks.has("chunks/rsc/app_74ef08.js") && loadedChunks.has("chunks/rsc/app_page_f45b78.tsx.js") && loadedChunks.has("chunks/rsc/app_layout_5e7964.js") && loadedChunks.has("chunks/rsc/node_modules_next_dist_compiled_5836d8.js") && loadedChunks.has("chunks/rsc/node_modules_next_dist_93cb54.js") && loadedChunks.has("chunks/rsc/node_modules_next_dist_esm_client_components_9c503e.js") && loadedChunks.has("chunks/rsc/node_modules_next_dist_client_components_0765ce.js") && loadedChunks.has("chunks/rsc/node_modules_next_dist_531d50.js"))) return true;
    instantiateRuntimeModule("[project-with-next]/.env.js (ssr)");
instantiateRuntimeModule("[project-with-next]/app/entry (ecmascript, ssr)");
}]);
(() => {
  // When a chunk is executed, it will either register itself with the current
  // instance of the runtime, or it will push itself onto the list of pending
  // chunks (`self.TURBOPACK`).
  //
  // When the runtime executes, it will pick up and register all pending chunks,
  // and replace the list of pending chunks with itself so later chunks can
  // register directly with it.

  /* eslint-disable @next/next/no-assign-module-variable */

  if (!Array.isArray(self.TURBOPACK)) {
    return;
  }

  /** @typedef {import('../types').ChunkRegistration} ChunkRegistration */
  /** @typedef {import('../types').ChunkModule} ChunkModule */
  /** @typedef {import('../types').Chunk} Chunk */
  /** @typedef {import('../types').ModuleFactory} ModuleFactory */

  /** @typedef {import('../types').ChunkPath} ChunkPath */
  /** @typedef {import('../types').ModuleId} ModuleId */

  /** @typedef {import('../types').Module} Module */
  /** @typedef {import('../types').Exports} Exports */
  /** @typedef {import('../types').EsmInteropNamespace} EsmInteropNamespace */
  /** @typedef {import('../types').Runnable} Runnable */

  /** @typedef {import('../types').Runtime} Runtime */

  /** @typedef {import('../types').RefreshHelpers} RefreshHelpers */
  /** @typedef {import('../types/hot').Hot} Hot */
  /** @typedef {import('../types/hot').HotData} HotData */
  /** @typedef {import('../types/hot').AcceptFunction} AcceptFunction */
  /** @typedef {import('../types/hot').AcceptCallback} AcceptCallback */
  /** @typedef {import('../types/hot').AcceptErrorHandler} AcceptErrorHandler */
  /** @typedef {import('../types/hot').HotState} HotState */
  /** @typedef {import('../types/protocol').EcmascriptChunkUpdate} EcmascriptChunkUpdate */
  /** @typedef {import('../types/protocol').HmrUpdateEntry} HmrUpdateEntry */

  /** @typedef {import('../types/runtime').Loader} Loader */
  /** @typedef {import('../types/runtime').ModuleEffect} ModuleEffect */

  /** @type {ChunkRegistration[]} */
  const chunksToRegister = self.TURBOPACK;
  /** @type {Array<Runnable>} */
  let runnable = [];
  /** @type {Object.<ModuleId, ModuleFactory>} */
  const moduleFactories = { __proto__: null };
  /** @type {Object.<ModuleId, Module>} */
  const moduleCache = { __proto__: null };
  /**
   * Contains the IDs of all chunks that have been loaded.
   *
   * @type {Set<ChunkPath>}
   */
  const loadedChunks = new Set();
  /**
   * Maps a chunk ID to the chunk's loader if the chunk is currently being loaded.
   *
   * @type {Map<ChunkPath, Loader>}
   */
  const chunkLoaders = new Map();
  /**
   * Maps module IDs to persisted data between executions of their hot module
   * implementation (`hot.data`).
   *
   * @type {Map<ModuleId, HotData>}
   */
  const moduleHotData = new Map();
  /**
   * Maps module instances to their hot module state.
   *
   * @type {Map<Module, HotState>}
   */
  const moduleHotState = new Map();
  /**
   * Module IDs that are instantiated as part of the runtime of a chunk.
   *
   * @type {Set<ModuleId>}
   */
  const runtimeModules = new Set();
  /**
   * Map from module ID to the chunks that contain this module.
   *
   * In HMR, we need to keep track of which modules are contained in which so
   * chunks. This is so we don't eagerly dispose of a module when it is removed
   * from chunk A, but still exists in chunk B.
   */
  const moduleChunksMap = new Map();
  const hOP = Object.prototype.hasOwnProperty;
  const _process =
    typeof process !== "undefined"
      ? process
      : {
          env: {},
          // Some modules rely on `process.browser` to execute browser-specific code.
          // NOTE: `process.browser` is specific to Webpack.
          browser: true,
        };

  const toStringTag = typeof Symbol !== "undefined" && Symbol.toStringTag;

  /**
   * @param {any} obj
   * @param {PropertyKey} name
   * @param {PropertyDescriptor & ThisType<any>} options
   */
  function defineProp(obj, name, options) {
    if (!hOP.call(obj, name)) Object.defineProperty(obj, name, options);
  }

  /**
   * Adds the getters to the exports object
   *
   * @param {Exports} exports
   * @param {Record<string, () => any>} getters
   */
  function esm(exports, getters) {
    defineProp(exports, "__esModule", { value: true });
    if (toStringTag) defineProp(exports, toStringTag, { value: "Module" });
    for (const key in getters) {
      defineProp(exports, key, { get: getters[key], enumerable: true });
    }
  }

  /**
   * @param {Module} module
   * @param {any} value
   */
  function exportValue(module, value) {
    module.exports = value;
  }

  /**
   * @param {Record<string, any>} obj
   * @param {string} key
   */
  function createGetter(obj, key) {
    return () => obj[key];
  }

  /**
   * @param {Exports} raw
   * @param {EsmInteropNamespace} ns
   * @param {boolean} [allowExportDefault]
   */
  function interopEsm(raw, ns, allowExportDefault) {
    /** @type {Object.<string, () => any>} */
    const getters = { __proto__: null };
    if (typeof raw === "object" || typeof raw === "function") {
      for (const key in raw) {
        getters[key] = createGetter(raw, key);
      }
    }
    if (!(allowExportDefault && "default" in getters)) {
      getters["default"] = () => raw;
    }
    esm(ns, getters);
  }

  /**
   * @param {Module} sourceModule
   * @param {ModuleId} id
   * @param {boolean} allowExportDefault
   * @returns {EsmInteropNamespace}
   */
  function esmImport(sourceModule, id, allowExportDefault) {
    const module = getOrInstantiateModuleFromParent(id, sourceModule);
    const raw = module.exports;
    if (raw.__esModule) return raw;
    if (module.interopNamespace) return module.interopNamespace;
    const ns = (module.interopNamespace = {});
    interopEsm(raw, ns, allowExportDefault);
    return ns;
  }

  /**
   * @param {Module} sourceModule
   * @param {ModuleId} id
   * @returns {Exports}
   */
  function commonJsRequire(sourceModule, id) {
    return getOrInstantiateModuleFromParent(id, sourceModule).exports;
  }

  function externalRequire(id) {
    let raw;
    try {
      raw = require(id);
    } catch (err) {
      // TODO(alexkirsz) This can happen when a client-side module tries to load
      // an external module we don't provide a shim for (e.g. querystring, url).
      // For now, we fail semi-silently, but in the future this should be a
      // compilation error.
      console.error(`Failed to load external module ${id}: ${err}`);
      return undefined;
    }
    if (raw.__esModule) {
      return raw;
    }
    const ns = {};
    interopEsm(raw, ns, true);
    return ns;
  }

  /**
   * @param {string} chunkPath
   * @returns {Promise<any> | undefined}
   */
  function loadChunk(chunkPath) {
    if (loadedChunks.has(chunkPath)) {
      return Promise.resolve();
    }

    const chunkLoader = getOrCreateChunkLoader(chunkPath);

    return chunkLoader.promise;
  }

  /**
   * @param {string} chunkPath
   * @returns {Loader}
   */
  function getOrCreateChunkLoader(chunkPath) {
    let chunkLoader = chunkLoaders.get(chunkPath);
    if (chunkLoader) {
      return chunkLoader;
    }

    let resolve;
    let reject;
    const promise = new Promise((innerResolve, innerReject) => {
      resolve = innerResolve;
      reject = innerReject;
    });

    const onError = () => {
      chunkLoaders.delete(chunkPath);
      reject(new Error(`Failed to load chunk from ${chunkPath}`));
    };

    const onLoad = () => {
      chunkLoaders.delete(chunkPath);
      resolve();
    };

    chunkLoader = {
      promise,
      onLoad,
    };
    chunkLoaders.set(chunkPath, chunkLoader);

    if (typeof document === "undefined") {
      throw new Error(
        "Loading chunks outside the browser is not currently supported. If using next/dynamic, try opting out of ssr for now: https://nextjs.org/docs/advanced-features/dynamic-import#with-no-ssr"
      );
    }

    if (chunkPath.endsWith(".css")) {
      const link = document.createElement("link");
      link.rel = "stylesheet";
      link.href = `/${chunkPath}`;
      link.onerror = onError;
      link.onload = () => {
        loadedChunks.add(chunkPath);
        onLoad();
      };
      document.body.appendChild(link);
    } else if (chunkPath.endsWith(".js")) {
      const script = document.createElement("script");
      script.src = `/${chunkPath}`;
      // We'll only mark the chunk as loaded once the script has been executed,
      // which happens in `registerChunk`.
      script.onerror = onError;
      document.body.appendChild(script);
    } else {
      throw new Error(`can't infer type of chunk from path ${chunkPath}`);
    }

    return chunkLoader;
  }

  /**
   * @enum {number}
   */
  const SourceType = {
    /**
     * The module was instantiated because it was included in an evaluated chunk's
     * runtime.
     */
    Runtime: 0,
    /**
     * The module was instantiated because a parent module imported it.
     */
    Parent: 1,
    /**
     * The module was instantiated because it was included in a chunk's hot module
     * update.
     */
    Update: 2,
  };

  /**
   *
   * @param {ModuleId} id
   * @param {SourceType} sourceType
   * @param {ModuleId} [sourceId]
   * @returns {Module}
   */
  function instantiateModule(id, sourceType, sourceId) {
    const moduleFactory = moduleFactories[id];
    if (typeof moduleFactory !== "function") {
      // This can happen if modules incorrectly handle HMR disposes/updates,
      // e.g. when they keep a `setTimeout` around which still executes old code
      // and contains e.g. a `require("something")` call.
      let instantiationReason;
      switch (sourceType) {
        case SourceType.Runtime:
          instantiationReason = "as a runtime entry";
          break;
        case SourceType.Parent:
          instantiationReason = `because it was required from module ${sourceId}`;
          break;
        case SourceType.Update:
          instantiationReason = "because of an HMR update";
          break;
      }
      throw new Error(
        `Module ${id} was instantiated ${instantiationReason}, but the module factory is not available. It might have been deleted in an HMR update.`
      );
    }

    const hotData = moduleHotData.get(id);
    const { hot, hotState } = createModuleHot(hotData);

    /** @type {Module} */
    const module = {
      exports: {},
      loaded: false,
      id,
      parents: [],
      children: [],
      interopNamespace: undefined,
      hot,
    };
    moduleCache[id] = module;
    moduleHotState.set(module, hotState);

    if (sourceType === SourceType.Runtime) {
      runtimeModules.add(id);
    } else if (sourceType === SourceType.Parent) {
      module.parents.push(sourceId);

      // No need to add this module as a child of the parent module here, this
      // has already been taken care of in `getOrInstantiateModuleFromParent`.
    }

    runModuleExecutionHooks(module, () => {
      moduleFactory.call(module.exports, {
        e: module.exports,
        r: commonJsRequire.bind(null, module),
        x: externalRequire,
        i: esmImport.bind(null, module),
        s: esm.bind(null, module.exports),
        v: exportValue.bind(null, module),
        m: module,
        c: moduleCache,
        l: loadChunk,
        p: _process,
        __dirname: module.id.replace(/(^|\/)[\/]+$/, ""),
      });
    });

    module.loaded = true;
    if (module.interopNamespace) {
      // in case of a circular dependency: cjs1 -> esm2 -> cjs1
      interopEsm(module.exports, module.interopNamespace);
    }

    return module;
  }

  /**
   * NOTE(alexkirsz) Webpack has an "module execution" interception hook that
   * Next.js' React Refresh runtime hooks into to add module context to the
   * refresh registry.
   *
   * @param {Module} module
   * @param {() => void} executeModule
   */
  function runModuleExecutionHooks(module, executeModule) {
    const cleanupReactRefreshIntercept =
      typeof self.$RefreshInterceptModuleExecution$ === "function"
        ? self.$RefreshInterceptModuleExecution$(module.id)
        : () => {};

    executeModule();

    if ("$RefreshHelpers$" in self) {
      // This pattern can also be used to register the exports of
      // a module with the React Refresh runtime.
      registerExportsAndSetupBoundaryForReactRefresh(
        module,
        self.$RefreshHelpers$
      );
    }

    cleanupReactRefreshIntercept();
  }

  /**
   * Retrieves a module from the cache, or instantiate it if it is not cached.
   *
   * @param {ModuleId} id
   * @param {Module} sourceModule
   * @returns {Module}
   */
  function getOrInstantiateModuleFromParent(id, sourceModule) {
    if (!sourceModule.hot.active) {
      console.warn(
        `Unexpected import of module ${id} from module ${sourceModule.id}, which was deleted by an HMR update`
      );
    }

    const module = moduleCache[id];

    if (sourceModule.children.indexOf(id) === -1) {
      sourceModule.children.push(id);
    }

    if (module) {
      if (module.parents.indexOf(sourceModule.id) === -1) {
        module.parents.push(sourceModule.id);
      }

      return module;
    }

    return instantiateModule(id, SourceType.Parent, sourceModule.id);
  }

  /**
   * This is adapted from https://github.com/vercel/next.js/blob/3466862d9dc9c8bb3131712134d38757b918d1c0/packages/react-refresh-utils/internal/ReactRefreshModule.runtime.ts
   *
   * @param {Module} module
   * @param {RefreshHelpers} helpers
   */
  function registerExportsAndSetupBoundaryForReactRefresh(module, helpers) {
    const currentExports = module.exports;
    const prevExports = module.hot.data.prevExports ?? null;

    helpers.registerExportsForReactRefresh(currentExports, module.id);

    // A module can be accepted automatically based on its exports, e.g. when
    // it is a Refresh Boundary.
    if (helpers.isReactRefreshBoundary(currentExports)) {
      // Save the previous exports on update so we can compare the boundary
      // signatures.
      module.hot.dispose((data) => {
        data.prevExports = currentExports;
      });
      // Unconditionally accept an update to this module, we'll check if it's
      // still a Refresh Boundary later.
      module.hot.accept();

      // This field is set when the previous version of this module was a
      // Refresh Boundary, letting us know we need to check for invalidation or
      // enqueue an update.
      if (prevExports !== null) {
        // A boundary can become ineligible if its exports are incompatible
        // with the previous exports.
        //
        // For example, if you add/remove/change exports, we'll want to
        // re-execute the importing modules, and force those components to
        // re-render. Similarly, if you convert a class component to a
        // function, we want to invalidate the boundary.
        if (
          helpers.shouldInvalidateReactRefreshBoundary(
            prevExports,
            currentExports
          )
        ) {
          module.hot.invalidate();
        } else {
          helpers.scheduleUpdate();
        }
      }
    } else {
      // Since we just executed the code for the module, it's possible that the
      // new exports made it ineligible for being a boundary.
      // We only care about the case when we were _previously_ a boundary,
      // because we already accepted this update (accidental side effect).
      const isNoLongerABoundary = prevExports !== null;
      if (isNoLongerABoundary) {
        module.hot.invalidate();
      }
    }
  }

  /**
   * @param {ModuleId[]} dependencyChain
   * @returns {string}
   */
  function formatDependencyChain(dependencyChain) {
    return `Dependency chain: ${dependencyChain.join(" -> ")}`;
  }

  /**
   * @param {HmrUpdateEntry} factory
   * @returns {ModuleFactory}
   * @private
   */
  function _eval(factory) {
    let code = factory.code;
    if (factory.map) code += `\n\n//# sourceMappingURL=${factory.map}`;
    return eval(code);
  }

  /**
   * @param {EcmascriptChunkUpdate} update
   * @returns {{outdatedModules: Set<any>, newModuleFactories: Map<any, any>}}
   */
  function computeOutdatedModules(update) {
    const outdatedModules = new Set();
    const newModuleFactories = new Map();

    for (const [moduleId, factory] of Object.entries(update.added)) {
      newModuleFactories.set(moduleId, _eval(factory));
    }

    for (const [moduleId, factory] of Object.entries(update.modified)) {
      const effect = getAffectedModuleEffects(moduleId);

      switch (effect.type) {
        case "unaccepted":
          throw new Error(
            `cannot apply update: unaccepted module. ${formatDependencyChain(
              effect.dependencyChain
            )}.`
          );
        case "self-declined":
          throw new Error(
            `cannot apply update: self-declined module. ${formatDependencyChain(
              effect.dependencyChain
            )}.`
          );
        case "accepted":
          newModuleFactories.set(moduleId, _eval(factory));
          for (const outdatedModuleId of effect.outdatedModules) {
            outdatedModules.add(outdatedModuleId);
          }
          break;
        // TODO(alexkirsz) Dependencies: handle dependencies effects.
      }
    }

    return { outdatedModules, newModuleFactories };
  }

  /**
   * @param {Iterable<ModuleId>} outdatedModules
   * @returns {{ moduleId: ModuleId, errorHandler: true | Function }[]}
   */
  function computeOutdatedSelfAcceptedModules(outdatedModules) {
    const outdatedSelfAcceptedModules = [];
    for (const moduleId of outdatedModules) {
      const module = moduleCache[moduleId];
      const hotState = moduleHotState.get(module);
      if (module && hotState.selfAccepted && !hotState.selfInvalidated) {
        outdatedSelfAcceptedModules.push({
          moduleId,
          errorHandler: hotState.selfAccepted,
        });
      }
    }
    return outdatedSelfAcceptedModules;
  }

  /**
   * @param {ChunkPath} chunkPath
   * @param {Iterable<ModuleId>} outdatedModules
   * @param {Iterable<ModuleId>} deletedModules
   */
  function disposePhase(chunkPath, outdatedModules, deletedModules) {
    for (const moduleId of outdatedModules) {
      const module = moduleCache[moduleId];
      if (!module) {
        continue;
      }

      const data = disposeModule(module);

      moduleHotData.set(moduleId, data);
    }

    for (const moduleId of deletedModules) {
      const module = moduleCache[moduleId];
      if (!module) {
        continue;
      }

      const noRemainingChunks = removeModuleFromChunk(moduleId, chunkPath);

      if (noRemainingChunks) {
        disposeModule(module);

        moduleHotData.delete(moduleId);
      }
    }

    // TODO(alexkirsz) Dependencies: remove outdated dependency from module
    // children.
  }

  /**
   * Disposes of an instance of a module.
   *
   * Returns the persistent hot data that should be kept for the next module
   * instance.
   *
   * @param {Module} module
   * @returns {{}}
   */
  function disposeModule(module) {
    const hotState = moduleHotState.get(module);
    const data = {};

    // Run the `hot.dispose` handler, if any, passing in the persistent
    // `hot.data` object.
    for (const disposeHandler of hotState.disposeHandlers) {
      disposeHandler(data);
    }

    // This used to warn in `getOrInstantiateModuleFromParent` when a disposed
    // module is still importing other modules.
    module.hot.active = false;

    delete moduleCache[module.id];
    moduleHotState.delete(module);

    // TODO(alexkirsz) Dependencies: delete the module from outdated deps.

    // Remove the disposed module from its children's parents list.
    // It will be added back once the module re-instantiates and imports its
    // children again.
    for (const childId of module.children) {
      const child = moduleCache[childId];
      if (!child) {
        continue;
      }

      const idx = child.parents.indexOf(module.id);
      if (idx >= 0) {
        child.parents.splice(idx, 1);
      }
    }

    return data;
  }

  /**
   *
   * @param {ChunkPath} chunkPath
   * @param {{ moduleId: ModuleId, errorHandler: true | Function }[]} outdatedSelfAcceptedModules
   * @param {Map<string, ModuleFactory>} newModuleFactories
   */
  function applyPhase(
    chunkPath,
    outdatedSelfAcceptedModules,
    newModuleFactories
  ) {
    // Update module factories.
    for (const [moduleId, factory] of newModuleFactories.entries()) {
      moduleFactories[moduleId] = factory;
      addModuleToChunk(moduleId, chunkPath);
    }

    // TODO(alexkirsz) Run new runtime entries here.

    // TODO(alexkirsz) Dependencies: call accept handlers for outdated deps.

    // Re-instantiate all outdated self-accepted modules.
    for (const { moduleId, errorHandler } of outdatedSelfAcceptedModules) {
      try {
        instantiateModule(moduleId, SourceType.Update);
      } catch (err) {
        if (typeof errorHandler === "function") {
          try {
            errorHandler(err, { moduleId, module: moduleCache[moduleId] });
          } catch (_) {
            // Ignore error.
          }
        }
      }
    }
  }

  /**
   *
   * @param {ChunkPath} chunkPath
   * @param {EcmascriptChunkUpdate} update
   */
  function applyUpdate(chunkPath, update) {
    const { outdatedModules, newModuleFactories } =
      computeOutdatedModules(update);

    const deletedModules = new Set(update.deleted);

    const outdatedSelfAcceptedModules =
      computeOutdatedSelfAcceptedModules(outdatedModules);

    disposePhase(chunkPath, outdatedModules, deletedModules);
    applyPhase(chunkPath, outdatedSelfAcceptedModules, newModuleFactories);
  }

  /**
   *
   * @param {ModuleId} moduleId
   * @returns {ModuleEffect}
   */
  function getAffectedModuleEffects(moduleId) {
    const outdatedModules = new Set();

    /** @typedef {{moduleId?: ModuleId, dependencyChain: ModuleId[]}} QueueItem */

    /** @type {QueueItem[]} */
    const queue = [
      {
        moduleId,
        dependencyChain: [],
      },
    ];

    while (queue.length > 0) {
      const { moduleId, dependencyChain } =
        /** @type {QueueItem} */ queue.shift();
      outdatedModules.add(moduleId);

      // We've arrived at the runtime of the chunk, which means that nothing
      // else above can accept this update.
      if (moduleId === undefined) {
        return {
          type: "unaccepted",
          dependencyChain,
        };
      }

      const module = moduleCache[moduleId];
      const hotState = moduleHotState.get(module);

      if (
        // The module is not in the cache. Since this is a "modified" update,
        // it means that the module was never instantiated before.
        !module || // The module accepted itself without invalidating itself.
        // TODO is that right?
        (hotState.selfAccepted && !hotState.selfInvalidated)
      ) {
        continue;
      }

      if (hotState.selfDeclined) {
        return {
          type: "self-declined",
          dependencyChain,
          moduleId,
        };
      }

      if (runtimeModules.has(moduleId)) {
        queue.push({
          moduleId: undefined,
          dependencyChain: [...dependencyChain, moduleId],
        });
        continue;
      }

      for (const parentId of module.parents) {
        const parent = moduleCache[parentId];

        if (!parent) {
          // TODO(alexkirsz) Is this even possible?
          continue;
        }

        // TODO(alexkirsz) Dependencies: check accepted and declined
        // dependencies here.

        queue.push({
          moduleId: parentId,
          dependencyChain: [...dependencyChain, moduleId],
        });
      }
    }

    return {
      type: "accepted",
      moduleId,
      outdatedModules,
    };
  }

  /**
   * @param {ChunkPath} chunkPath
   * @param {import('../types/protocol').ServerMessage} update
   */
  function handleApply(chunkPath, update) {
    switch (update.type) {
      case "partial":
        applyUpdate(chunkPath, update.instruction);
        break;
      case "restart":
        self.location.reload();
        break;
      default:
        throw new Error(`Unknown update type: ${update.type}`);
    }
  }

  /**
   * @param {HotData} [hotData]
   * @returns {{hotState: HotState, hot: Hot}}
   */
  function createModuleHot(hotData) {
    /** @type {HotState} */
    const hotState = {
      selfAccepted: false,
      selfDeclined: false,
      selfInvalidated: false,
      disposeHandlers: [],
    };

    /**
     * TODO(alexkirsz) Support full (dep, callback, errorHandler) form.
     *
     * @param {string | string[] | AcceptErrorHandler} [dep]
     * @param {AcceptCallback} [_callback]
     * @param {AcceptErrorHandler} [_errorHandler]
     */
    function accept(dep, _callback, _errorHandler) {
      if (dep === undefined) {
        hotState.selfAccepted = true;
      } else if (typeof dep === "function") {
        hotState.selfAccepted = dep;
      } else {
        throw new Error("unsupported `accept` signature");
      }
    }

    /** @type {Hot} */
    const hot = {
      // TODO(alexkirsz) This is not defined in the HMR API. It was used to
      // decide whether to warn whenever an HMR-disposed module required other
      // modules. We might want to remove it.
      active: true,

      data: hotData ?? {},

      accept: accept,

      decline: (dep) => {
        if (dep === undefined) {
          hotState.selfDeclined = true;
        } else {
          throw new Error("unsupported `decline` signature");
        }
      },

      dispose: (callback) => {
        hotState.disposeHandlers.push(callback);
      },

      addDisposeHandler: (callback) => {
        hotState.disposeHandlers.push(callback);
      },

      removeDisposeHandler: (callback) => {
        const idx = hotState.disposeHandlers.indexOf(callback);
        if (idx >= 0) {
          hotState.disposeHandlers.splice(idx, 1);
        }
      },

      invalidate: () => {
        hotState.selfInvalidated = true;
        // TODO(alexkirsz) The original HMR code had management-related code
        // here.
      },

      // NOTE(alexkirsz) This is part of the management API, which we don't
      // implement, but the Next.js React Refresh runtime uses this to decide
      // whether to schedule an update.
      status: () => "idle",
    };

    return { hot, hotState };
  }

  /**
   * Adds a module to a chunk.
   *
   * @param {ModuleId} moduleId
   * @param {ChunkPath} chunkPath
   */
  function addModuleToChunk(moduleId, chunkPath) {
    let moduleChunks = moduleChunksMap.get(moduleId);
    if (!moduleChunks) {
      moduleChunks = new Set([chunkPath]);
      moduleChunksMap.set(moduleId, moduleChunks);
    } else {
      moduleChunks.add(chunkPath);
    }
  }

  /**
   * Removes a module from a chunk. Returns true there are no remaining chunks
   * including this module.
   *
   * @param {ModuleId} moduleId
   * @param {ChunkPath} chunkPath
   * @returns {boolean}
   */
  function removeModuleFromChunk(moduleId, chunkPath) {
    const moduleChunks = moduleChunksMap.get(moduleId);
    moduleChunks.delete(chunkPath);

    if (moduleChunks.size > 0) {
      return false;
    }

    moduleChunksMap.delete(moduleId);
    return true;
  }

  /**
   * Instantiates a runtime module.
   */
  /**
   *
   * @param {ModuleId} moduleId
   * @returns {Module}
   */
  function instantiateRuntimeModule(moduleId) {
    return instantiateModule(moduleId, SourceType.Runtime);
  }

  /**
   * Subscribes to chunk updates from the update server and applies them.
   *
   * @param {ChunkPath} chunkPath
   */
  function subscribeToChunkUpdates(chunkPath) {
    // This adds a chunk update listener once the handler code has been loaded
    self.TURBOPACK_CHUNK_UPDATE_LISTENERS.push([
      chunkPath,
      handleApply.bind(null, chunkPath),
    ]);
  }

  function markChunkAsLoaded(chunkPath) {
    loadedChunks.add(chunkPath);

    const chunkLoader = chunkLoaders.get(chunkPath);
    if (!chunkLoader) {
      // This happens for all initial chunks that are loaded directly from
      // the HTML.
      return;
    }

    // Only chunks that are loaded via `loadChunk` will have a loader.
    chunkLoader.onLoad();
  }

  /** @type {Runtime} */
  const runtime = {
    loadedChunks,
    modules: moduleFactories,
    cache: moduleCache,
    instantiateRuntimeModule,
  };

  /**
   * @param {ChunkRegistration} chunkRegistration
   */
  function registerChunk([chunkPath, chunkModules, ...run]) {
    markChunkAsLoaded(chunkPath);
    subscribeToChunkUpdates(chunkPath);
    for (const [moduleId, moduleFactory] of Object.entries(chunkModules)) {
      if (!moduleFactories[moduleId]) {
        moduleFactories[moduleId] = moduleFactory;
      }
      addModuleToChunk(moduleId, chunkPath);
    }
    runnable.push(...run);
    runnable = runnable.filter((r) => r(runtime));
  }

  self.TURBOPACK_CHUNK_UPDATE_LISTENERS =
    self.TURBOPACK_CHUNK_UPDATE_LISTENERS || [];
  self.TURBOPACK = { push: registerChunk };
  chunksToRegister.forEach(registerChunk);
})();


//# sourceMappingURL=_85e422.js.a1a1bea66ac701d4.map