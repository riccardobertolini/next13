(self.TURBOPACK = self.TURBOPACK || []).push(["chunks/ssr/node_modules_next_dist_compiled_e91a99.js", {

"[project-with-next]/node_modules/next/dist/compiled/react-is/index.js (ecmascript, ssr)": (function({ r: __turbopack_require__, x: __turbopack_external_require__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, c: __turbopack_cache__, l: __turbopack_load__, p: process, __dirname, m: module, e: exports }) { !function() {

'use strict';
if (process.env.NODE_ENV === 'production') {
    module.exports = __turbopack_require__("[project-with-next]/node_modules/next/dist/compiled/react-is/cjs/react-is.production.min.js (ecmascript, ssr)");
} else {
    module.exports = __turbopack_require__("[project-with-next]/node_modules/next/dist/compiled/react-is/cjs/react-is.development.js (ecmascript, ssr)");
}

}.call(this) }),
"[project-with-next]/node_modules/next/dist/compiled/react-is/cjs/react-is.production.min.js (ecmascript, ssr)": (function({ r: __turbopack_require__, x: __turbopack_external_require__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, c: __turbopack_cache__, l: __turbopack_load__, p: process, __dirname, m: module, e: exports }) { !function() {

'use strict';
var b = Symbol.for("react.element"), c = Symbol.for("react.portal"), d = Symbol.for("react.fragment"), e = Symbol.for("react.strict_mode"), f = Symbol.for("react.profiler"), g = Symbol.for("react.provider"), h = Symbol.for("react.context"), k = Symbol.for("react.server_context"), l = Symbol.for("react.forward_ref"), m = Symbol.for("react.suspense"), n = Symbol.for("react.suspense_list"), p = Symbol.for("react.memo"), q = Symbol.for("react.lazy"), t = Symbol.for("react.offscreen"), u;
u = Symbol.for("react.module.reference");
function v(a) {
    if ("object" === typeof a && null !== a) {
        var r = a.$$typeof;
        switch(r){
            case b:
                switch(a = a.type, a){
                    case d:
                    case f:
                    case e:
                    case m:
                    case n:
                        return a;
                    default:
                        switch(a = a && a.$$typeof, a){
                            case k:
                            case h:
                            case l:
                            case q:
                            case p:
                            case g:
                                return a;
                            default:
                                return r;
                        }
                }
            case c:
                return r;
        }
    }
}
exports.ContextConsumer = h;
exports.ContextProvider = g;
exports.Element = b;
exports.ForwardRef = l;
exports.Fragment = d;
exports.Lazy = q;
exports.Memo = p;
exports.Portal = c;
exports.Profiler = f;
exports.StrictMode = e;
exports.Suspense = m;
exports.SuspenseList = n;
exports.isAsyncMode = function() {
    return !1;
};
exports.isConcurrentMode = function() {
    return !1;
};
exports.isContextConsumer = function(a) {
    return v(a) === h;
};
exports.isContextProvider = function(a) {
    return v(a) === g;
};
exports.isElement = function(a) {
    return "object" === typeof a && null !== a && a.$$typeof === b;
};
exports.isForwardRef = function(a) {
    return v(a) === l;
};
exports.isFragment = function(a) {
    return v(a) === d;
};
exports.isLazy = function(a) {
    return v(a) === q;
};
exports.isMemo = function(a) {
    return v(a) === p;
};
exports.isPortal = function(a) {
    return v(a) === c;
};
exports.isProfiler = function(a) {
    return v(a) === f;
};
exports.isStrictMode = function(a) {
    return v(a) === e;
};
exports.isSuspense = function(a) {
    return v(a) === m;
};
exports.isSuspenseList = function(a) {
    return v(a) === n;
};
exports.isValidElementType = function(a) {
    return "string" === typeof a || "function" === typeof a || a === d || a === f || a === e || a === m || a === n || a === t || "object" === typeof a && null !== a && (a.$$typeof === q || a.$$typeof === p || a.$$typeof === g || a.$$typeof === h || a.$$typeof === l || a.$$typeof === u || void 0 !== a.getModuleId) ? !0 : !1;
};
exports.typeOf = v;

}.call(this) }),
"[project-with-next]/node_modules/next/dist/compiled/react-is/cjs/react-is.development.js (ecmascript, ssr)": (function({ r: __turbopack_require__, x: __turbopack_external_require__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, c: __turbopack_cache__, l: __turbopack_load__, p: process, __dirname, m: module, e: exports }) { !function() {

'use strict';
if (process.env.NODE_ENV !== "production") {
    (function() {
        'use strict';
        var REACT_ELEMENT_TYPE = Symbol.for('react.element');
        var REACT_PORTAL_TYPE = Symbol.for('react.portal');
        var REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');
        var REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode');
        var REACT_PROFILER_TYPE = Symbol.for('react.profiler');
        var REACT_PROVIDER_TYPE = Symbol.for('react.provider');
        var REACT_CONTEXT_TYPE = Symbol.for('react.context');
        var REACT_SERVER_CONTEXT_TYPE = Symbol.for('react.server_context');
        var REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');
        var REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');
        var REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');
        var REACT_MEMO_TYPE = Symbol.for('react.memo');
        var REACT_LAZY_TYPE = Symbol.for('react.lazy');
        var REACT_OFFSCREEN_TYPE = Symbol.for('react.offscreen');
        var enableScopeAPI = false;
        var enableCacheElement = false;
        var enableTransitionTracing = false;
        var enableLegacyHidden = false;
        var enableDebugTracing = false;
        var REACT_MODULE_REFERENCE;
        {
            REACT_MODULE_REFERENCE = Symbol.for('react.module.reference');
        }
        function isValidElementType(type) {
            if (typeof type === 'string' || typeof type === 'function') {
                return true;
            }
            if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {
                return true;
            }
            if (typeof type === 'object' && type !== null) {
                if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== undefined) {
                    return true;
                }
            }
            return false;
        }
        function typeOf(object) {
            if (typeof object === 'object' && object !== null) {
                var $$typeof = object.$$typeof;
                switch($$typeof){
                    case REACT_ELEMENT_TYPE:
                        var type = object.type;
                        switch(type){
                            case REACT_FRAGMENT_TYPE:
                            case REACT_PROFILER_TYPE:
                            case REACT_STRICT_MODE_TYPE:
                            case REACT_SUSPENSE_TYPE:
                            case REACT_SUSPENSE_LIST_TYPE:
                                return type;
                            default:
                                var $$typeofType = type && type.$$typeof;
                                switch($$typeofType){
                                    case REACT_SERVER_CONTEXT_TYPE:
                                    case REACT_CONTEXT_TYPE:
                                    case REACT_FORWARD_REF_TYPE:
                                    case REACT_LAZY_TYPE:
                                    case REACT_MEMO_TYPE:
                                    case REACT_PROVIDER_TYPE:
                                        return $$typeofType;
                                    default:
                                        return $$typeof;
                                }
                        }
                    case REACT_PORTAL_TYPE:
                        return $$typeof;
                }
            }
            return undefined;
        }
        var ContextConsumer = REACT_CONTEXT_TYPE;
        var ContextProvider = REACT_PROVIDER_TYPE;
        var Element = REACT_ELEMENT_TYPE;
        var ForwardRef = REACT_FORWARD_REF_TYPE;
        var Fragment = REACT_FRAGMENT_TYPE;
        var Lazy = REACT_LAZY_TYPE;
        var Memo = REACT_MEMO_TYPE;
        var Portal = REACT_PORTAL_TYPE;
        var Profiler = REACT_PROFILER_TYPE;
        var StrictMode = REACT_STRICT_MODE_TYPE;
        var Suspense = REACT_SUSPENSE_TYPE;
        var SuspenseList = REACT_SUSPENSE_LIST_TYPE;
        var hasWarnedAboutDeprecatedIsAsyncMode = false;
        var hasWarnedAboutDeprecatedIsConcurrentMode = false;
        function isAsyncMode(object) {
            {
                if (!hasWarnedAboutDeprecatedIsAsyncMode) {
                    hasWarnedAboutDeprecatedIsAsyncMode = true;
                    console['warn']('The ReactIs.isAsyncMode() alias has been deprecated, ' + 'and will be removed in React 18+.');
                }
            }
            return false;
        }
        function isConcurrentMode(object) {
            {
                if (!hasWarnedAboutDeprecatedIsConcurrentMode) {
                    hasWarnedAboutDeprecatedIsConcurrentMode = true;
                    console['warn']('The ReactIs.isConcurrentMode() alias has been deprecated, ' + 'and will be removed in React 18+.');
                }
            }
            return false;
        }
        function isContextConsumer(object) {
            return typeOf(object) === REACT_CONTEXT_TYPE;
        }
        function isContextProvider(object) {
            return typeOf(object) === REACT_PROVIDER_TYPE;
        }
        function isElement(object) {
            return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
        }
        function isForwardRef(object) {
            return typeOf(object) === REACT_FORWARD_REF_TYPE;
        }
        function isFragment(object) {
            return typeOf(object) === REACT_FRAGMENT_TYPE;
        }
        function isLazy(object) {
            return typeOf(object) === REACT_LAZY_TYPE;
        }
        function isMemo(object) {
            return typeOf(object) === REACT_MEMO_TYPE;
        }
        function isPortal(object) {
            return typeOf(object) === REACT_PORTAL_TYPE;
        }
        function isProfiler(object) {
            return typeOf(object) === REACT_PROFILER_TYPE;
        }
        function isStrictMode(object) {
            return typeOf(object) === REACT_STRICT_MODE_TYPE;
        }
        function isSuspense(object) {
            return typeOf(object) === REACT_SUSPENSE_TYPE;
        }
        function isSuspenseList(object) {
            return typeOf(object) === REACT_SUSPENSE_LIST_TYPE;
        }
        exports.ContextConsumer = ContextConsumer;
        exports.ContextProvider = ContextProvider;
        exports.Element = Element;
        exports.ForwardRef = ForwardRef;
        exports.Fragment = Fragment;
        exports.Lazy = Lazy;
        exports.Memo = Memo;
        exports.Portal = Portal;
        exports.Profiler = Profiler;
        exports.StrictMode = StrictMode;
        exports.Suspense = Suspense;
        exports.SuspenseList = SuspenseList;
        exports.isAsyncMode = isAsyncMode;
        exports.isConcurrentMode = isConcurrentMode;
        exports.isContextConsumer = isContextConsumer;
        exports.isContextProvider = isContextProvider;
        exports.isElement = isElement;
        exports.isForwardRef = isForwardRef;
        exports.isFragment = isFragment;
        exports.isLazy = isLazy;
        exports.isMemo = isMemo;
        exports.isPortal = isPortal;
        exports.isProfiler = isProfiler;
        exports.isStrictMode = isStrictMode;
        exports.isSuspense = isSuspense;
        exports.isSuspenseList = isSuspenseList;
        exports.isValidElementType = isValidElementType;
        exports.typeOf = typeOf;
    })();
}

}.call(this) }),
"[project-with-next]/node_modules/next/dist/compiled/react-server-dom-webpack/client.js (ecmascript, ssr)": (function({ r: __turbopack_require__, x: __turbopack_external_require__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, c: __turbopack_cache__, l: __turbopack_load__, p: process, __dirname, m: module, e: exports }) { !function() {

(()=>{
    "use strict";
    var __webpack_modules__ = {
        415: (__unused_webpack_module, exports, __nccwpck_require__)=>{
            if (process.env.NODE_ENV !== "production") {
                (function() {
                    'use strict';
                    var React = __nccwpck_require__(522);
                    function createStringDecoder() {
                        return new TextDecoder();
                    }
                    var decoderOptions = {
                        stream: true
                    };
                    function readPartialStringChunk(decoder, buffer) {
                        return decoder.decode(buffer, decoderOptions);
                    }
                    function readFinalStringChunk(decoder, buffer) {
                        return decoder.decode(buffer);
                    }
                    function parseModel(response, json) {
                        return JSON.parse(json, response._fromJSON);
                    }
                    function resolveModuleReference(bundlerConfig, moduleData) {
                        if (bundlerConfig) {
                            var resolvedModuleData = bundlerConfig[moduleData.id][moduleData.name];
                            if (moduleData.async) {
                                return {
                                    id: resolvedModuleData.id,
                                    chunks: resolvedModuleData.chunks,
                                    name: resolvedModuleData.name,
                                    async: true
                                };
                            } else {
                                return resolvedModuleData;
                            }
                        }
                        return moduleData;
                    }
                    var chunkCache = new Map();
                    var asyncModuleCache = new Map();
                    function ignoreReject() {}
                    function preloadModule(moduleData) {
                        var chunks = moduleData.chunks;
                        var promises = [];
                        for(var i = 0; i < chunks.length; i++){
                            var chunkId = chunks[i];
                            var entry = chunkCache.get(chunkId);
                            if (entry === undefined) {
                                var thenable = globalThis.__next_chunk_load__(chunkId);
                                promises.push(thenable);
                                var resolve = chunkCache.set.bind(chunkCache, chunkId, null);
                                thenable.then(resolve, ignoreReject);
                                chunkCache.set(chunkId, thenable);
                            } else if (entry !== null) {
                                promises.push(entry);
                            }
                        }
                        if (moduleData.async) {
                            var existingPromise = asyncModuleCache.get(moduleData.id);
                            if (existingPromise) {
                                if (existingPromise.status === 'fulfilled') {
                                    return null;
                                }
                                return existingPromise;
                            } else {
                                var modulePromise = Promise.all(promises).then(function() {
                                    return globalThis.__next_require__(moduleData.id);
                                });
                                modulePromise.then(function(value) {
                                    var fulfilledThenable = modulePromise;
                                    fulfilledThenable.status = 'fulfilled';
                                    fulfilledThenable.value = value;
                                }, function(reason) {
                                    var rejectedThenable = modulePromise;
                                    rejectedThenable.status = 'rejected';
                                    rejectedThenable.reason = reason;
                                });
                                asyncModuleCache.set(moduleData.id, modulePromise);
                                return modulePromise;
                            }
                        } else if (promises.length > 0) {
                            return Promise.all(promises);
                        } else {
                            return null;
                        }
                    }
                    function requireModule(moduleData) {
                        var moduleExports;
                        if (moduleData.async) {
                            var promise = asyncModuleCache.get(moduleData.id);
                            if (promise.status === 'fulfilled') {
                                moduleExports = promise.value;
                            } else {
                                throw promise.reason;
                            }
                        } else {
                            moduleExports = globalThis.__next_require__(moduleData.id);
                        }
                        if (moduleData.name === '*') {
                            return moduleExports;
                        }
                        if (moduleData.name === '') {
                            return moduleExports.__esModule ? moduleExports.default : moduleExports;
                        }
                        return moduleExports[moduleData.name];
                    }
                    var REACT_ELEMENT_TYPE = Symbol.for('react.element');
                    var REACT_LAZY_TYPE = Symbol.for('react.lazy');
                    var REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED = Symbol.for('react.default_value');
                    var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
                    var ContextRegistry = ReactSharedInternals.ContextRegistry;
                    function getOrCreateServerContext(globalName) {
                        if (!ContextRegistry[globalName]) {
                            ContextRegistry[globalName] = React.createServerContext(globalName, REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED);
                        }
                        return ContextRegistry[globalName];
                    }
                    var PENDING = 'pending';
                    var BLOCKED = 'blocked';
                    var RESOLVED_MODEL = 'resolved_model';
                    var RESOLVED_MODULE = 'resolved_module';
                    var INITIALIZED = 'fulfilled';
                    var ERRORED = 'rejected';
                    function Chunk(status, value, reason, response) {
                        this.status = status;
                        this.value = value;
                        this.reason = reason;
                        this._response = response;
                    }
                    Chunk.prototype = Object.create(Promise.prototype);
                    Chunk.prototype.then = function(resolve, reject) {
                        var chunk = this;
                        switch(chunk.status){
                            case RESOLVED_MODEL:
                                initializeModelChunk(chunk);
                                break;
                            case RESOLVED_MODULE:
                                initializeModuleChunk(chunk);
                                break;
                        }
                        switch(chunk.status){
                            case INITIALIZED:
                                resolve(chunk.value);
                                break;
                            case PENDING:
                            case BLOCKED:
                                if (resolve) {
                                    if (chunk.value === null) {
                                        chunk.value = [];
                                    }
                                    chunk.value.push(resolve);
                                }
                                if (reject) {
                                    if (chunk.reason === null) {
                                        chunk.reason = [];
                                    }
                                    chunk.reason.push(reject);
                                }
                                break;
                            default:
                                reject(chunk.reason);
                                break;
                        }
                    };
                    function readChunk(chunk) {
                        switch(chunk.status){
                            case RESOLVED_MODEL:
                                initializeModelChunk(chunk);
                                break;
                            case RESOLVED_MODULE:
                                initializeModuleChunk(chunk);
                                break;
                        }
                        switch(chunk.status){
                            case INITIALIZED:
                                return chunk.value;
                            case PENDING:
                            case BLOCKED:
                                throw chunk;
                            default:
                                throw chunk.reason;
                        }
                    }
                    function getRoot(response) {
                        var chunk = getChunk(response, 0);
                        return chunk;
                    }
                    function createPendingChunk(response) {
                        return new Chunk(PENDING, null, null, response);
                    }
                    function createBlockedChunk(response) {
                        return new Chunk(BLOCKED, null, null, response);
                    }
                    function createErrorChunk(response, error) {
                        return new Chunk(ERRORED, null, error, response);
                    }
                    function createInitializedChunk(response, value) {
                        return new Chunk(INITIALIZED, value, null, response);
                    }
                    function wakeChunk(listeners, value) {
                        for(var i = 0; i < listeners.length; i++){
                            var listener = listeners[i];
                            listener(value);
                        }
                    }
                    function wakeChunkIfInitialized(chunk, resolveListeners, rejectListeners) {
                        switch(chunk.status){
                            case INITIALIZED:
                                wakeChunk(resolveListeners, chunk.value);
                                break;
                            case PENDING:
                            case BLOCKED:
                                chunk.value = resolveListeners;
                                chunk.reason = rejectListeners;
                                break;
                            case ERRORED:
                                if (rejectListeners) {
                                    wakeChunk(rejectListeners, chunk.reason);
                                }
                                break;
                        }
                    }
                    function triggerErrorOnChunk(chunk, error) {
                        if (chunk.status !== PENDING && chunk.status !== BLOCKED) {
                            return;
                        }
                        var listeners = chunk.reason;
                        var erroredChunk = chunk;
                        erroredChunk.status = ERRORED;
                        erroredChunk.reason = error;
                        if (listeners !== null) {
                            wakeChunk(listeners, error);
                        }
                    }
                    function createResolvedModelChunk(response, value) {
                        return new Chunk(RESOLVED_MODEL, value, null, response);
                    }
                    function createResolvedModuleChunk(response, value) {
                        return new Chunk(RESOLVED_MODULE, value, null, response);
                    }
                    function resolveModelChunk(chunk, value) {
                        if (chunk.status !== PENDING) {
                            return;
                        }
                        var resolveListeners = chunk.value;
                        var rejectListeners = chunk.reason;
                        var resolvedChunk = chunk;
                        resolvedChunk.status = RESOLVED_MODEL;
                        resolvedChunk.value = value;
                        if (resolveListeners !== null) {
                            initializeModelChunk(resolvedChunk);
                            wakeChunkIfInitialized(chunk, resolveListeners, rejectListeners);
                        }
                    }
                    function resolveModuleChunk(chunk, value) {
                        if (chunk.status !== PENDING && chunk.status !== BLOCKED) {
                            return;
                        }
                        var resolveListeners = chunk.value;
                        var rejectListeners = chunk.reason;
                        var resolvedChunk = chunk;
                        resolvedChunk.status = RESOLVED_MODULE;
                        resolvedChunk.value = value;
                        if (resolveListeners !== null) {
                            initializeModuleChunk(resolvedChunk);
                            wakeChunkIfInitialized(chunk, resolveListeners, rejectListeners);
                        }
                    }
                    var initializingChunk = null;
                    var initializingChunkBlockedModel = null;
                    function initializeModelChunk(chunk) {
                        var prevChunk = initializingChunk;
                        var prevBlocked = initializingChunkBlockedModel;
                        initializingChunk = chunk;
                        initializingChunkBlockedModel = null;
                        try {
                            var _value = parseModel(chunk._response, chunk.value);
                            if (initializingChunkBlockedModel !== null && initializingChunkBlockedModel.deps > 0) {
                                initializingChunkBlockedModel.value = _value;
                                var blockedChunk = chunk;
                                blockedChunk.status = BLOCKED;
                                blockedChunk.value = null;
                                blockedChunk.reason = null;
                            } else {
                                var initializedChunk = chunk;
                                initializedChunk.status = INITIALIZED;
                                initializedChunk.value = _value;
                            }
                        } catch (error) {
                            var erroredChunk = chunk;
                            erroredChunk.status = ERRORED;
                            erroredChunk.reason = error;
                        } finally{
                            initializingChunk = prevChunk;
                            initializingChunkBlockedModel = prevBlocked;
                        }
                    }
                    function initializeModuleChunk(chunk) {
                        try {
                            var _value2 = requireModule(chunk.value);
                            var initializedChunk = chunk;
                            initializedChunk.status = INITIALIZED;
                            initializedChunk.value = _value2;
                        } catch (error) {
                            var erroredChunk = chunk;
                            erroredChunk.status = ERRORED;
                            erroredChunk.reason = error;
                        }
                    }
                    function reportGlobalError(response, error) {
                        response._chunks.forEach(function(chunk) {
                            if (chunk.status === PENDING) {
                                triggerErrorOnChunk(chunk, error);
                            }
                        });
                    }
                    function createElement(type, key, props) {
                        var element = {
                            $$typeof: REACT_ELEMENT_TYPE,
                            type: type,
                            key: key,
                            ref: null,
                            props: props,
                            _owner: null
                        };
                        {
                            element._store = {};
                            Object.defineProperty(element._store, 'validated', {
                                configurable: false,
                                enumerable: false,
                                writable: true,
                                value: true
                            });
                            Object.defineProperty(element, '_self', {
                                configurable: false,
                                enumerable: false,
                                writable: false,
                                value: null
                            });
                            Object.defineProperty(element, '_source', {
                                configurable: false,
                                enumerable: false,
                                writable: false,
                                value: null
                            });
                        }
                        return element;
                    }
                    function createLazyChunkWrapper(chunk) {
                        var lazyType = {
                            $$typeof: REACT_LAZY_TYPE,
                            _payload: chunk,
                            _init: readChunk
                        };
                        return lazyType;
                    }
                    function getChunk(response, id) {
                        var chunks = response._chunks;
                        var chunk = chunks.get(id);
                        if (!chunk) {
                            chunk = createPendingChunk(response);
                            chunks.set(id, chunk);
                        }
                        return chunk;
                    }
                    function createModelResolver(chunk, parentObject, key) {
                        var blocked;
                        if (initializingChunkBlockedModel) {
                            blocked = initializingChunkBlockedModel;
                            blocked.deps++;
                        } else {
                            blocked = initializingChunkBlockedModel = {
                                deps: 1,
                                value: null
                            };
                        }
                        return function(value) {
                            parentObject[key] = value;
                            blocked.deps--;
                            if (blocked.deps === 0) {
                                if (chunk.status !== BLOCKED) {
                                    return;
                                }
                                var resolveListeners = chunk.value;
                                var initializedChunk = chunk;
                                initializedChunk.status = INITIALIZED;
                                initializedChunk.value = blocked.value;
                                if (resolveListeners !== null) {
                                    wakeChunk(resolveListeners, blocked.value);
                                }
                            }
                        };
                    }
                    function createModelReject(chunk) {
                        return function(error) {
                            return triggerErrorOnChunk(chunk, error);
                        };
                    }
                    function parseModelString(response, parentObject, key, value) {
                        switch(value[0]){
                            case '$':
                                {
                                    if (value === '$') {
                                        return REACT_ELEMENT_TYPE;
                                    } else if (value[1] === '$' || value[1] === '@') {
                                        return value.substring(1);
                                    } else {
                                        var id = parseInt(value.substring(1), 16);
                                        var chunk = getChunk(response, id);
                                        switch(chunk.status){
                                            case RESOLVED_MODEL:
                                                initializeModelChunk(chunk);
                                                break;
                                            case RESOLVED_MODULE:
                                                initializeModuleChunk(chunk);
                                                break;
                                        }
                                        switch(chunk.status){
                                            case INITIALIZED:
                                                return chunk.value;
                                            case PENDING:
                                            case BLOCKED:
                                                var parentChunk = initializingChunk;
                                                chunk.then(createModelResolver(parentChunk, parentObject, key), createModelReject(parentChunk));
                                                return null;
                                            default:
                                                throw chunk.reason;
                                        }
                                    }
                                }
                            case '@':
                                {
                                    var _id = parseInt(value.substring(1), 16);
                                    var _chunk = getChunk(response, _id);
                                    return createLazyChunkWrapper(_chunk);
                                }
                        }
                        return value;
                    }
                    function parseModelTuple(response, value) {
                        var tuple = value;
                        if (tuple[0] === REACT_ELEMENT_TYPE) {
                            return createElement(tuple[1], tuple[2], tuple[3]);
                        }
                        return value;
                    }
                    function createResponse(bundlerConfig) {
                        var chunks = new Map();
                        var response = {
                            _bundlerConfig: bundlerConfig,
                            _chunks: chunks
                        };
                        return response;
                    }
                    function resolveModel(response, id, model) {
                        var chunks = response._chunks;
                        var chunk = chunks.get(id);
                        if (!chunk) {
                            chunks.set(id, createResolvedModelChunk(response, model));
                        } else {
                            resolveModelChunk(chunk, model);
                        }
                    }
                    function resolveProvider(response, id, contextName) {
                        var chunks = response._chunks;
                        chunks.set(id, createInitializedChunk(response, getOrCreateServerContext(contextName).Provider));
                    }
                    function resolveModule(response, id, model) {
                        var chunks = response._chunks;
                        var chunk = chunks.get(id);
                        var moduleMetaData = parseModel(response, model);
                        var moduleReference = resolveModuleReference(response._bundlerConfig, moduleMetaData);
                        var promise = preloadModule(moduleReference);
                        if (promise) {
                            var blockedChunk;
                            if (!chunk) {
                                blockedChunk = createBlockedChunk(response);
                                chunks.set(id, blockedChunk);
                            } else {
                                blockedChunk = chunk;
                                blockedChunk.status = BLOCKED;
                            }
                            promise.then(function() {
                                return resolveModuleChunk(blockedChunk, moduleReference);
                            }, function(error) {
                                return triggerErrorOnChunk(blockedChunk, error);
                            });
                        } else {
                            if (!chunk) {
                                chunks.set(id, createResolvedModuleChunk(response, moduleReference));
                            } else {
                                resolveModuleChunk(chunk, moduleReference);
                            }
                        }
                    }
                    function resolveSymbol(response, id, name) {
                        var chunks = response._chunks;
                        chunks.set(id, createInitializedChunk(response, Symbol.for(name)));
                    }
                    function resolveErrorDev(response, id, digest, message, stack) {
                        var error = new Error(message || 'An error occurred in the Server Components render but no message was provided');
                        error.stack = stack;
                        error.digest = digest;
                        var errorWithDigest = error;
                        var chunks = response._chunks;
                        var chunk = chunks.get(id);
                        if (!chunk) {
                            chunks.set(id, createErrorChunk(response, errorWithDigest));
                        } else {
                            triggerErrorOnChunk(chunk, errorWithDigest);
                        }
                    }
                    function close(response) {
                        reportGlobalError(response, new Error('Connection closed.'));
                    }
                    function processFullRow(response, row) {
                        if (row === '') {
                            return;
                        }
                        var tag = row[0];
                        var colon = row.indexOf(':', 1);
                        var id = parseInt(row.substring(1, colon), 16);
                        var text = row.substring(colon + 1);
                        switch(tag){
                            case 'J':
                                {
                                    resolveModel(response, id, text);
                                    return;
                                }
                            case 'M':
                                {
                                    resolveModule(response, id, text);
                                    return;
                                }
                            case 'P':
                                {
                                    resolveProvider(response, id, text);
                                    return;
                                }
                            case 'S':
                                {
                                    resolveSymbol(response, id, JSON.parse(text));
                                    return;
                                }
                            case 'E':
                                {
                                    var errorInfo = JSON.parse(text);
                                    {
                                        resolveErrorDev(response, id, errorInfo.digest, errorInfo.message, errorInfo.stack);
                                    }
                                    return;
                                }
                            default:
                                {
                                    throw new Error("Error parsing the data. It's probably an error code or network corruption.");
                                }
                        }
                    }
                    function processStringChunk(response, chunk, offset) {
                        var linebreak = chunk.indexOf('\n', offset);
                        while(linebreak > -1){
                            var fullrow = response._partialRow + chunk.substring(offset, linebreak);
                            processFullRow(response, fullrow);
                            response._partialRow = '';
                            offset = linebreak + 1;
                            linebreak = chunk.indexOf('\n', offset);
                        }
                        response._partialRow += chunk.substring(offset);
                    }
                    function processBinaryChunk(response, chunk) {
                        var stringDecoder = response._stringDecoder;
                        var linebreak = chunk.indexOf(10);
                        while(linebreak > -1){
                            var fullrow = response._partialRow + readFinalStringChunk(stringDecoder, chunk.subarray(0, linebreak));
                            processFullRow(response, fullrow);
                            response._partialRow = '';
                            chunk = chunk.subarray(linebreak + 1);
                            linebreak = chunk.indexOf(10);
                        }
                        response._partialRow += readPartialStringChunk(stringDecoder, chunk);
                    }
                    function createFromJSONCallback(response) {
                        return function(key, value) {
                            if (typeof value === 'string') {
                                return parseModelString(response, this, key, value);
                            }
                            if (typeof value === 'object' && value !== null) {
                                return parseModelTuple(response, value);
                            }
                            return value;
                        };
                    }
                    function createResponse$1(bundlerConfig) {
                        var stringDecoder = createStringDecoder();
                        var response = createResponse(bundlerConfig);
                        response._partialRow = '';
                        {
                            response._stringDecoder = stringDecoder;
                        }
                        response._fromJSON = createFromJSONCallback(response);
                        return response;
                    }
                    function startReadingFromStream(response, stream) {
                        var reader = stream.getReader();
                        function progress(_ref) {
                            var done = _ref.done, value = _ref.value;
                            if (done) {
                                close(response);
                                return;
                            }
                            var buffer = value;
                            processBinaryChunk(response, buffer);
                            return reader.read().then(progress).catch(error);
                        }
                        function error(e) {
                            reportGlobalError(response, e);
                        }
                        reader.read().then(progress).catch(error);
                    }
                    function createFromReadableStream(stream, options) {
                        var response = createResponse$1(options && options.moduleMap ? options.moduleMap : null);
                        startReadingFromStream(response, stream);
                        return getRoot(response);
                    }
                    function createFromFetch(promiseForResponse, options) {
                        var response = createResponse$1(options && options.moduleMap ? options.moduleMap : null);
                        promiseForResponse.then(function(r) {
                            startReadingFromStream(response, r.body);
                        }, function(e) {
                            reportGlobalError(response, e);
                        });
                        return getRoot(response);
                    }
                    function createFromXHR(request, options) {
                        var response = createResponse$1(options && options.moduleMap ? options.moduleMap : null);
                        var processedLength = 0;
                        function progress(e) {
                            var chunk = request.responseText;
                            processStringChunk(response, chunk, processedLength);
                            processedLength = chunk.length;
                        }
                        function load(e) {
                            progress();
                            close(response);
                        }
                        function error(e) {
                            reportGlobalError(response, new TypeError('Network error'));
                        }
                        request.addEventListener('progress', progress);
                        request.addEventListener('load', load);
                        request.addEventListener('error', error);
                        request.addEventListener('abort', error);
                        request.addEventListener('timeout', error);
                        return getRoot(response);
                    }
                    exports.createFromFetch = createFromFetch;
                    exports.createFromReadableStream = createFromReadableStream;
                    exports.createFromXHR = createFromXHR;
                })();
            }
        },
        291: (__unused_webpack_module, exports, __nccwpck_require__)=>{
            var h = __nccwpck_require__(522), k = {
                stream: !0
            };
            function m(a, b) {
                return a ? (a = a[b.id][b.name], b.async ? {
                    id: a.id,
                    chunks: a.chunks,
                    name: a.name,
                    async: !0
                } : a) : b;
            }
            var n = new Map, p = new Map;
            function q() {}
            function r(a) {
                for(var b = a.chunks, c = [], d = 0; d < b.length; d++){
                    var e = b[d], f = n.get(e);
                    if (void 0 === f) {
                        f = globalThis.__next_chunk_load__(e);
                        c.push(f);
                        var l = n.set.bind(n, e, null);
                        f.then(l, q);
                        n.set(e, f);
                    } else null !== f && c.push(f);
                }
                if (a.async) {
                    if (b = p.get(a.id)) return "fulfilled" === b.status ? null : b;
                    var g = Promise.all(c).then(function() {
                        return globalThis.__next_require__(a.id);
                    });
                    g.then(function(a) {
                        g.status = "fulfilled";
                        g.value = a;
                    }, function(a) {
                        g.status = "rejected";
                        g.reason = a;
                    });
                    p.set(a.id, g);
                    return g;
                }
                return 0 < c.length ? Promise.all(c) : null;
            }
            var t = Symbol.for("react.element"), u = Symbol.for("react.lazy"), v = Symbol.for("react.default_value"), w = h.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ContextRegistry;
            function x(a) {
                w[a] || (w[a] = h.createServerContext(a, v));
                return w[a];
            }
            function y(a, b, c, d) {
                this.status = a;
                this.value = b;
                this.reason = c;
                this._response = d;
            }
            y.prototype = Object.create(Promise.prototype);
            y.prototype.then = function(a, b) {
                switch(this.status){
                    case "resolved_model":
                        z(this);
                        break;
                    case "resolved_module":
                        B(this);
                }
                switch(this.status){
                    case "fulfilled":
                        a(this.value);
                        break;
                    case "pending":
                    case "blocked":
                        a && (null === this.value && (this.value = []), this.value.push(a));
                        b && (null === this.reason && (this.reason = []), this.reason.push(b));
                        break;
                    default:
                        b(this.reason);
                }
            };
            function C(a) {
                switch(a.status){
                    case "resolved_model":
                        z(a);
                        break;
                    case "resolved_module":
                        B(a);
                }
                switch(a.status){
                    case "fulfilled":
                        return a.value;
                    case "pending":
                    case "blocked":
                        throw a;
                    default:
                        throw a.reason;
                }
            }
            function D(a, b) {
                return new y("fulfilled", b, null, a);
            }
            function E(a, b) {
                for(var c = 0; c < a.length; c++)(0, a[c])(b);
            }
            function F(a, b, c) {
                switch(a.status){
                    case "fulfilled":
                        E(b, a.value);
                        break;
                    case "pending":
                    case "blocked":
                        a.value = b;
                        a.reason = c;
                        break;
                    case "rejected":
                        c && E(c, a.reason);
                }
            }
            function G(a, b) {
                if ("pending" === a.status || "blocked" === a.status) {
                    var c = a.reason;
                    a.status = "rejected";
                    a.reason = b;
                    null !== c && E(c, b);
                }
            }
            function H(a, b) {
                if ("pending" === a.status || "blocked" === a.status) {
                    var c = a.value, d = a.reason;
                    a.status = "resolved_module";
                    a.value = b;
                    null !== c && (B(a), F(a, c, d));
                }
            }
            var I = null, J = null;
            function z(a) {
                var b = I, c = J;
                I = a;
                J = null;
                try {
                    var d = JSON.parse(a.value, a._response._fromJSON);
                    null !== J && 0 < J.deps ? (J.value = d, a.status = "blocked", a.value = null, a.reason = null) : (a.status = "fulfilled", a.value = d);
                } catch (e) {
                    a.status = "rejected", a.reason = e;
                } finally{
                    I = b, J = c;
                }
            }
            function B(a) {
                try {
                    var b = a.value;
                    if (b.async) {
                        var c = p.get(b.id);
                        if ("fulfilled" === c.status) var d = c.value;
                        else throw c.reason;
                    } else d = globalThis.__next_require__(b.id);
                    var e = "*" === b.name ? d : "" === b.name ? d.__esModule ? d.default : d : d[b.name];
                    a.status = "fulfilled";
                    a.value = e;
                } catch (f) {
                    a.status = "rejected", a.reason = f;
                }
            }
            function K(a, b) {
                a._chunks.forEach(function(a) {
                    "pending" === a.status && G(a, b);
                });
            }
            function L(a, b) {
                var c = a._chunks, d = c.get(b);
                d || (d = new y("pending", null, null, a), c.set(b, d));
                return d;
            }
            function N(a, b, c) {
                if (J) {
                    var d = J;
                    d.deps++;
                } else d = J = {
                    deps: 1,
                    value: null
                };
                return function(e) {
                    b[c] = e;
                    d.deps--;
                    0 === d.deps && "blocked" === a.status && (e = a.value, a.status = "fulfilled", a.value = d.value, null !== e && E(e, d.value));
                };
            }
            function O(a) {
                return function(b) {
                    return G(a, b);
                };
            }
            function P(a, b, c, d) {
                switch(d[0]){
                    case "$":
                        if ("$" === d) return t;
                        if ("$" === d[1] || "@" === d[1]) return d.substring(1);
                        d = parseInt(d.substring(1), 16);
                        a = L(a, d);
                        switch(a.status){
                            case "resolved_model":
                                z(a);
                                break;
                            case "resolved_module":
                                B(a);
                        }
                        switch(a.status){
                            case "fulfilled":
                                return a.value;
                            case "pending":
                            case "blocked":
                                return d = I, a.then(N(d, b, c), O(d)), null;
                            default:
                                throw a.reason;
                        }
                    case "@":
                        return b = parseInt(d.substring(1), 16), b = L(a, b), {
                            $$typeof: u,
                            _payload: b,
                            _init: C
                        };
                }
                return d;
            }
            function Q(a, b, c) {
                var d = a._chunks, e = d.get(b);
                c = JSON.parse(c, a._fromJSON);
                var f = m(a._bundlerConfig, c);
                if (c = r(f)) {
                    if (e) {
                        var l = e;
                        l.status = "blocked";
                    } else l = new y("blocked", null, null, a), d.set(b, l);
                    c.then(function() {
                        return H(l, f);
                    }, function(a) {
                        return G(l, a);
                    });
                } else e ? H(e, f) : d.set(b, new y("resolved_module", f, null, a));
            }
            function R(a) {
                K(a, Error("Connection closed."));
            }
            function S(a, b) {
                if ("" !== b) {
                    var c = b[0], d = b.indexOf(":", 1), e = parseInt(b.substring(1, d), 16);
                    b = b.substring(d + 1);
                    switch(c){
                        case "J":
                            d = a._chunks;
                            (c = d.get(e)) ? "pending" === c.status && (a = c.value, e = c.reason, c.status = "resolved_model", c.value = b, null !== a && (z(c), F(c, a, e))) : d.set(e, new y("resolved_model", b, null, a));
                            break;
                        case "M":
                            Q(a, e, b);
                            break;
                        case "P":
                            a._chunks.set(e, D(a, x(b).Provider));
                            break;
                        case "S":
                            b = JSON.parse(b);
                            a._chunks.set(e, D(a, Symbol.for(b)));
                            break;
                        case "E":
                            c = JSON.parse(b).digest;
                            b = Error("An error occurred in the Server Components render. The specific message is omitted in production builds to avoid leaking sensitive details. A digest property is included on this error instance which may provide additional details about the nature of the error.");
                            b.stack = "Error: " + b.message;
                            b.digest = c;
                            c = a._chunks;
                            (d = c.get(e)) ? G(d, b) : c.set(e, new y("rejected", null, b, a));
                            break;
                        default:
                            throw Error("Error parsing the data. It's probably an error code or network corruption.");
                    }
                }
            }
            function T(a) {
                return function(b, c) {
                    return "string" === typeof c ? P(a, this, b, c) : "object" === typeof c && null !== c ? (b = c[0] === t ? {
                        $$typeof: t,
                        type: c[1],
                        key: c[2],
                        ref: null,
                        props: c[3],
                        _owner: null
                    } : c, b) : c;
                };
            }
            function U(a) {
                var b = new TextDecoder, c = new Map;
                a = {
                    _bundlerConfig: a,
                    _chunks: c,
                    _partialRow: "",
                    _stringDecoder: b
                };
                a._fromJSON = T(a);
                return a;
            }
            function V(a, b) {
                function c(b) {
                    var f = b.value;
                    if (b.done) R(a);
                    else {
                        b = f;
                        f = a._stringDecoder;
                        for(var g = b.indexOf(10); -1 < g;){
                            var M = a._partialRow;
                            var A = b.subarray(0, g);
                            A = f.decode(A);
                            S(a, M + A);
                            a._partialRow = "";
                            b = b.subarray(g + 1);
                            g = b.indexOf(10);
                        }
                        a._partialRow += f.decode(b, k);
                        return e.read().then(c).catch(d);
                    }
                }
                function d(b) {
                    K(a, b);
                }
                var e = b.getReader();
                e.read().then(c).catch(d);
            }
            exports.createFromFetch = function(a, b) {
                var c = U(b && b.moduleMap ? b.moduleMap : null);
                a.then(function(a) {
                    V(c, a.body);
                }, function(a) {
                    K(c, a);
                });
                return L(c, 0);
            };
            exports.createFromReadableStream = function(a, b) {
                b = U(b && b.moduleMap ? b.moduleMap : null);
                V(b, a);
                return L(b, 0);
            };
            exports.createFromXHR = function(a, b) {
                function c() {
                    for(var b = a.responseText, c = f, d = b.indexOf("\n", c); -1 < d;)c = e._partialRow + b.substring(c, d), S(e, c), e._partialRow = "", c = d + 1, d = b.indexOf("\n", c);
                    e._partialRow += b.substring(c);
                    f = b.length;
                }
                function d() {
                    K(e, new TypeError("Network error"));
                }
                var e = U(b && b.moduleMap ? b.moduleMap : null), f = 0;
                a.addEventListener("progress", c);
                a.addEventListener("load", function() {
                    c();
                    R(e);
                });
                a.addEventListener("error", d);
                a.addEventListener("abort", d);
                a.addEventListener("timeout", d);
                return L(e, 0);
            };
        },
        967: (module, __unused_webpack_exports, __nccwpck_require__)=>{
            if (process.env.NODE_ENV === 'production') {
                module.exports = __nccwpck_require__(291);
            } else {
                module.exports = __nccwpck_require__(415);
            }
        },
        522: (module)=>{
            module.exports = __turbopack_require__("[project-with-next]/node_modules/next/dist/compiled/react/index.js (ecmascript, ssr)");
        }
    };
    var __webpack_module_cache__ = {};
    function __nccwpck_require__(moduleId) {
        var cachedModule = __webpack_module_cache__[moduleId];
        if (cachedModule !== undefined) {
            return cachedModule.exports;
        }
        var module = __webpack_module_cache__[moduleId] = {
            exports: {}
        };
        var threw = true;
        try {
            __webpack_modules__[moduleId](module, module.exports, __nccwpck_require__);
            threw = false;
        } finally{
            if (threw) delete __webpack_module_cache__[moduleId];
        }
        return module.exports;
    }
    if (typeof __nccwpck_require__ !== 'undefined') __nccwpck_require__.ab = __dirname + "/";
    var __webpack_exports__ = __nccwpck_require__(967);
    module.exports = __webpack_exports__;
})();

}.call(this) }),
"[project-with-next]/node_modules/next/dist/compiled/react/index.js (ecmascript, ssr)": (function({ r: __turbopack_require__, x: __turbopack_external_require__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, c: __turbopack_cache__, l: __turbopack_load__, p: process, __dirname, m: module, e: exports }) { !function() {

'use strict';
if (process.env.NODE_ENV === 'production') {
    module.exports = __turbopack_require__("[project-with-next]/node_modules/next/dist/compiled/react/cjs/react.production.min.js (ecmascript, ssr)");
} else {
    module.exports = __turbopack_require__("[project-with-next]/node_modules/next/dist/compiled/react/cjs/react.development.js (ecmascript, ssr)");
}

}.call(this) }),
"[project-with-next]/node_modules/next/dist/compiled/react/cjs/react.production.min.js (ecmascript, ssr)": (function({ r: __turbopack_require__, x: __turbopack_external_require__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, c: __turbopack_cache__, l: __turbopack_load__, p: process, __dirname, m: module, e: exports }) { !function() {

'use strict';
var l = Symbol.for("react.element"), n = Symbol.for("react.portal"), p = Symbol.for("react.fragment"), q = Symbol.for("react.strict_mode"), r = Symbol.for("react.profiler"), t = Symbol.for("react.provider"), u = Symbol.for("react.context"), v = Symbol.for("react.server_context"), w = Symbol.for("react.forward_ref"), x = Symbol.for("react.suspense"), y = Symbol.for("react.memo"), z = Symbol.for("react.lazy"), A = Symbol.for("react.default_value"), B = Symbol.iterator;
function C(a) {
    if (null === a || "object" !== typeof a) return null;
    a = B && a[B] || a["@@iterator"];
    return "function" === typeof a ? a : null;
}
var D = {
    isMounted: function() {
        return !1;
    },
    enqueueForceUpdate: function() {},
    enqueueReplaceState: function() {},
    enqueueSetState: function() {}
}, E = Object.assign, F = {};
function G(a, b, d) {
    this.props = a;
    this.context = b;
    this.refs = F;
    this.updater = d || D;
}
G.prototype.isReactComponent = {};
G.prototype.setState = function(a, b) {
    if ("object" !== typeof a && "function" !== typeof a && null != a) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
    this.updater.enqueueSetState(this, a, b, "setState");
};
G.prototype.forceUpdate = function(a) {
    this.updater.enqueueForceUpdate(this, a, "forceUpdate");
};
function H() {}
H.prototype = G.prototype;
function I(a, b, d) {
    this.props = a;
    this.context = b;
    this.refs = F;
    this.updater = d || D;
}
var J = I.prototype = new H;
J.constructor = I;
E(J, G.prototype);
J.isPureReactComponent = !0;
var K = Array.isArray, L = Object.prototype.hasOwnProperty, M = {
    current: null
}, N = {
    key: !0,
    ref: !0,
    __self: !0,
    __source: !0
};
function O(a, b, d) {
    var c, e = {}, f = null, g = null;
    if (null != b) for(c in void 0 !== b.ref && (g = b.ref), void 0 !== b.key && (f = "" + b.key), b)L.call(b, c) && !N.hasOwnProperty(c) && (e[c] = b[c]);
    var h = arguments.length - 2;
    if (1 === h) e.children = d;
    else if (1 < h) {
        for(var k = Array(h), m = 0; m < h; m++)k[m] = arguments[m + 2];
        e.children = k;
    }
    if (a && a.defaultProps) for(c in h = a.defaultProps, h)void 0 === e[c] && (e[c] = h[c]);
    return {
        $$typeof: l,
        type: a,
        key: f,
        ref: g,
        props: e,
        _owner: M.current
    };
}
function aa(a, b) {
    return {
        $$typeof: l,
        type: a.type,
        key: b,
        ref: a.ref,
        props: a.props,
        _owner: a._owner
    };
}
function P(a) {
    return "object" === typeof a && null !== a && a.$$typeof === l;
}
function escape(a) {
    var b = {
        "=": "=0",
        ":": "=2"
    };
    return "$" + a.replace(/[=:]/g, function(a) {
        return b[a];
    });
}
var Q = /\/+/g;
function R(a, b) {
    return "object" === typeof a && null !== a && null != a.key ? escape("" + a.key) : b.toString(36);
}
function S(a, b, d, c, e) {
    var f = typeof a;
    if ("undefined" === f || "boolean" === f) a = null;
    var g = !1;
    if (null === a) g = !0;
    else switch(f){
        case "string":
        case "number":
            g = !0;
            break;
        case "object":
            switch(a.$$typeof){
                case l:
                case n:
                    g = !0;
            }
    }
    if (g) return g = a, e = e(g), a = "" === c ? "." + R(g, 0) : c, K(e) ? (d = "", null != a && (d = a.replace(Q, "$&/") + "/"), S(e, b, d, "", function(a) {
        return a;
    })) : null != e && (P(e) && (e = aa(e, d + (!e.key || g && g.key === e.key ? "" : ("" + e.key).replace(Q, "$&/") + "/") + a)), b.push(e)), 1;
    g = 0;
    c = "" === c ? "." : c + ":";
    if (K(a)) for(var h = 0; h < a.length; h++){
        f = a[h];
        var k = c + R(f, h);
        g += S(f, b, d, k, e);
    }
    else if (k = C(a), "function" === typeof k) for(a = k.call(a), h = 0; !(f = a.next()).done;)f = f.value, k = c + R(f, h++), g += S(f, b, d, k, e);
    else if ("object" === f) throw b = String(a), Error("Objects are not valid as a React child (found: " + ("[object Object]" === b ? "object with keys {" + Object.keys(a).join(", ") + "}" : b) + "). If you meant to render a collection of children, use an array instead.");
    return g;
}
function T(a, b, d) {
    if (null == a) return a;
    var c = [], e = 0;
    S(a, c, "", "", function(a) {
        return b.call(d, a, e++);
    });
    return c;
}
function ba(a) {
    if (-1 === a._status) {
        var b = a._result;
        b = b();
        b.then(function(b) {
            if (0 === a._status || -1 === a._status) a._status = 1, a._result = b;
        }, function(b) {
            if (0 === a._status || -1 === a._status) a._status = 2, a._result = b;
        });
        -1 === a._status && (a._status = 0, a._result = b);
    }
    if (1 === a._status) return a._result.default;
    throw a._result;
}
var U = {
    current: null
};
function ca() {
    return new WeakMap;
}
function V() {
    return {
        s: 0,
        v: void 0,
        o: null,
        p: null
    };
}
var W = {
    current: null
}, X = {
    transition: null
}, Y = {
    ReactCurrentDispatcher: W,
    ReactCurrentCache: U,
    ReactCurrentBatchConfig: X,
    ReactCurrentOwner: M,
    ContextRegistry: {}
}, Z = Y.ContextRegistry;
exports.Children = {
    map: T,
    forEach: function(a, b, d) {
        T(a, function() {
            b.apply(this, arguments);
        }, d);
    },
    count: function(a) {
        var b = 0;
        T(a, function() {
            b++;
        });
        return b;
    },
    toArray: function(a) {
        return T(a, function(a) {
            return a;
        }) || [];
    },
    only: function(a) {
        if (!P(a)) throw Error("React.Children.only expected to receive a single React element child.");
        return a;
    }
};
exports.Component = G;
exports.Fragment = p;
exports.Profiler = r;
exports.PureComponent = I;
exports.StrictMode = q;
exports.Suspense = x;
exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = Y;
exports.cache = function(a) {
    return function() {
        var b = U.current;
        if (!b) return a.apply(null, arguments);
        var d = b.getCacheForType(ca);
        b = d.get(a);
        void 0 === b && (b = V(), d.set(a, b));
        d = 0;
        for(var c = arguments.length; d < c; d++){
            var e = arguments[d];
            if ("function" === typeof e || "object" === typeof e && null !== e) {
                var f = b.o;
                null === f && (b.o = f = new WeakMap);
                b = f.get(e);
                void 0 === b && (b = V(), f.set(e, b));
            } else f = b.p, null === f && (b.p = f = new Map), b = f.get(e), void 0 === b && (b = V(), f.set(e, b));
        }
        if (1 === b.s) return b.v;
        if (2 === b.s) throw b.v;
        try {
            var g = a.apply(null, arguments);
            d = b;
            d.s = 1;
            return d.v = g;
        } catch (h) {
            throw g = b, g.s = 2, g.v = h, h;
        }
    };
};
exports.cloneElement = function(a, b, d) {
    if (null === a || void 0 === a) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + a + ".");
    var c = E({}, a.props), e = a.key, f = a.ref, g = a._owner;
    if (null != b) {
        void 0 !== b.ref && (f = b.ref, g = M.current);
        void 0 !== b.key && (e = "" + b.key);
        if (a.type && a.type.defaultProps) var h = a.type.defaultProps;
        for(k in b)L.call(b, k) && !N.hasOwnProperty(k) && (c[k] = void 0 === b[k] && void 0 !== h ? h[k] : b[k]);
    }
    var k = arguments.length - 2;
    if (1 === k) c.children = d;
    else if (1 < k) {
        h = Array(k);
        for(var m = 0; m < k; m++)h[m] = arguments[m + 2];
        c.children = h;
    }
    return {
        $$typeof: l,
        type: a.type,
        key: e,
        ref: f,
        props: c,
        _owner: g
    };
};
exports.createContext = function(a) {
    a = {
        $$typeof: u,
        _currentValue: a,
        _currentValue2: a,
        _threadCount: 0,
        Provider: null,
        Consumer: null,
        _defaultValue: null,
        _globalName: null
    };
    a.Provider = {
        $$typeof: t,
        _context: a
    };
    return a.Consumer = a;
};
exports.createElement = O;
exports.createFactory = function(a) {
    var b = O.bind(null, a);
    b.type = a;
    return b;
};
exports.createRef = function() {
    return {
        current: null
    };
};
exports.createServerContext = function(a, b) {
    var d = !0;
    if (!Z[a]) {
        d = !1;
        var c = {
            $$typeof: v,
            _currentValue: b,
            _currentValue2: b,
            _defaultValue: b,
            _threadCount: 0,
            Provider: null,
            Consumer: null,
            _globalName: a
        };
        c.Provider = {
            $$typeof: t,
            _context: c
        };
        Z[a] = c;
    }
    c = Z[a];
    if (c._defaultValue === A) c._defaultValue = b, c._currentValue === A && (c._currentValue = b), c._currentValue2 === A && (c._currentValue2 = b);
    else if (d) throw Error("ServerContext: " + a + " already defined");
    return c;
};
exports.forwardRef = function(a) {
    return {
        $$typeof: w,
        render: a
    };
};
exports.isValidElement = P;
exports.lazy = function(a) {
    return {
        $$typeof: z,
        _payload: {
            _status: -1,
            _result: a
        },
        _init: ba
    };
};
exports.memo = function(a, b) {
    return {
        $$typeof: y,
        type: a,
        compare: void 0 === b ? null : b
    };
};
exports.startTransition = function(a) {
    var b = X.transition;
    X.transition = {};
    try {
        a();
    } finally{
        X.transition = b;
    }
};
exports.unstable_act = function() {
    throw Error("act(...) is not supported in production builds of React.");
};
exports.unstable_useCacheRefresh = function() {
    return W.current.useCacheRefresh();
};
exports.use = function(a) {
    return W.current.use(a);
};
exports.useCallback = function(a, b) {
    return W.current.useCallback(a, b);
};
exports.useContext = function(a) {
    return W.current.useContext(a);
};
exports.useDebugValue = function() {};
exports.useDeferredValue = function(a) {
    return W.current.useDeferredValue(a);
};
exports.useEffect = function(a, b) {
    return W.current.useEffect(a, b);
};
exports.useId = function() {
    return W.current.useId();
};
exports.useImperativeHandle = function(a, b, d) {
    return W.current.useImperativeHandle(a, b, d);
};
exports.useInsertionEffect = function(a, b) {
    return W.current.useInsertionEffect(a, b);
};
exports.useLayoutEffect = function(a, b) {
    return W.current.useLayoutEffect(a, b);
};
exports.useMemo = function(a, b) {
    return W.current.useMemo(a, b);
};
exports.useReducer = function(a, b, d) {
    return W.current.useReducer(a, b, d);
};
exports.useRef = function(a) {
    return W.current.useRef(a);
};
exports.useState = function(a) {
    return W.current.useState(a);
};
exports.useSyncExternalStore = function(a, b, d) {
    return W.current.useSyncExternalStore(a, b, d);
};
exports.useTransition = function() {
    return W.current.useTransition();
};
exports.version = "18.3.0-next-d925a8d0b-20221024";

}.call(this) }),
"[project-with-next]/node_modules/next/dist/compiled/react/cjs/react.development.js (ecmascript, ssr)": (function({ r: __turbopack_require__, x: __turbopack_external_require__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, c: __turbopack_cache__, l: __turbopack_load__, p: process, __dirname, m: module, e: exports }) { !function() {

'use strict';
if (process.env.NODE_ENV !== "production") {
    (function() {
        'use strict';
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === 'function') {
            __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
        }
        var ReactVersion = '18.3.0-next-d925a8d0b-20221024';
        var REACT_ELEMENT_TYPE = Symbol.for('react.element');
        var REACT_PORTAL_TYPE = Symbol.for('react.portal');
        var REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');
        var REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode');
        var REACT_PROFILER_TYPE = Symbol.for('react.profiler');
        var REACT_PROVIDER_TYPE = Symbol.for('react.provider');
        var REACT_CONTEXT_TYPE = Symbol.for('react.context');
        var REACT_SERVER_CONTEXT_TYPE = Symbol.for('react.server_context');
        var REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');
        var REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');
        var REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');
        var REACT_MEMO_TYPE = Symbol.for('react.memo');
        var REACT_LAZY_TYPE = Symbol.for('react.lazy');
        var REACT_OFFSCREEN_TYPE = Symbol.for('react.offscreen');
        var REACT_CACHE_TYPE = Symbol.for('react.cache');
        var REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED = Symbol.for('react.default_value');
        var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
        var FAUX_ITERATOR_SYMBOL = '@@iterator';
        function getIteratorFn(maybeIterable) {
            if (maybeIterable === null || typeof maybeIterable !== 'object') {
                return null;
            }
            var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
            if (typeof maybeIterator === 'function') {
                return maybeIterator;
            }
            return null;
        }
        var ReactCurrentDispatcher = {
            current: null
        };
        var ReactCurrentCache = {
            current: null
        };
        var ReactCurrentBatchConfig = {
            transition: null
        };
        var ReactCurrentActQueue = {
            current: null,
            isBatchingLegacy: false,
            didScheduleLegacyUpdate: false,
            didUsePromise: false
        };
        var ReactCurrentOwner = {
            current: null
        };
        var ReactDebugCurrentFrame = {};
        var currentExtraStackFrame = null;
        function setExtraStackFrame(stack) {
            {
                currentExtraStackFrame = stack;
            }
        }
        {
            ReactDebugCurrentFrame.setExtraStackFrame = function(stack) {
                {
                    currentExtraStackFrame = stack;
                }
            };
            ReactDebugCurrentFrame.getCurrentStack = null;
            ReactDebugCurrentFrame.getStackAddendum = function() {
                var stack = '';
                if (currentExtraStackFrame) {
                    stack += currentExtraStackFrame;
                }
                var impl = ReactDebugCurrentFrame.getCurrentStack;
                if (impl) {
                    stack += impl() || '';
                }
                return stack;
            };
        }
        var enableScopeAPI = false;
        var enableCacheElement = false;
        var enableTransitionTracing = false;
        var enableLegacyHidden = false;
        var enableDebugTracing = false;
        var ContextRegistry = {};
        var ReactSharedInternals = {
            ReactCurrentDispatcher: ReactCurrentDispatcher,
            ReactCurrentCache: ReactCurrentCache,
            ReactCurrentBatchConfig: ReactCurrentBatchConfig,
            ReactCurrentOwner: ReactCurrentOwner
        };
        {
            ReactSharedInternals.ReactDebugCurrentFrame = ReactDebugCurrentFrame;
            ReactSharedInternals.ReactCurrentActQueue = ReactCurrentActQueue;
        }
        {
            ReactSharedInternals.ContextRegistry = ContextRegistry;
        }
        function warn(format) {
            {
                {
                    for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
                        args[_key - 1] = arguments[_key];
                    }
                    printWarning('warn', format, args);
                }
            }
        }
        function error(format) {
            {
                {
                    for(var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++){
                        args[_key2 - 1] = arguments[_key2];
                    }
                    printWarning('error', format, args);
                }
            }
        }
        function printWarning(level, format, args) {
            {
                var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
                var stack = ReactDebugCurrentFrame.getStackAddendum();
                if (stack !== '') {
                    format += '%s';
                    args = args.concat([
                        stack
                    ]);
                }
                var argsWithFormat = args.map(function(item) {
                    return String(item);
                });
                argsWithFormat.unshift('Warning: ' + format);
                Function.prototype.apply.call(console[level], console, argsWithFormat);
            }
        }
        var didWarnStateUpdateForUnmountedComponent = {};
        function warnNoop(publicInstance, callerName) {
            {
                var _constructor = publicInstance.constructor;
                var componentName = _constructor && (_constructor.displayName || _constructor.name) || 'ReactClass';
                var warningKey = componentName + "." + callerName;
                if (didWarnStateUpdateForUnmountedComponent[warningKey]) {
                    return;
                }
                error("Can't call %s on a component that is not yet mounted. " + 'This is a no-op, but it might indicate a bug in your application. ' + 'Instead, assign to `this.state` directly or define a `state = {};` ' + 'class property with the desired state in the %s component.', callerName, componentName);
                didWarnStateUpdateForUnmountedComponent[warningKey] = true;
            }
        }
        var ReactNoopUpdateQueue = {
            isMounted: function(publicInstance) {
                return false;
            },
            enqueueForceUpdate: function(publicInstance, callback, callerName) {
                warnNoop(publicInstance, 'forceUpdate');
            },
            enqueueReplaceState: function(publicInstance, completeState, callback, callerName) {
                warnNoop(publicInstance, 'replaceState');
            },
            enqueueSetState: function(publicInstance, partialState, callback, callerName) {
                warnNoop(publicInstance, 'setState');
            }
        };
        var assign = Object.assign;
        var emptyObject = {};
        {
            Object.freeze(emptyObject);
        }
        function Component(props, context, updater) {
            this.props = props;
            this.context = context;
            this.refs = emptyObject;
            this.updater = updater || ReactNoopUpdateQueue;
        }
        Component.prototype.isReactComponent = {};
        Component.prototype.setState = function(partialState, callback) {
            if (typeof partialState !== 'object' && typeof partialState !== 'function' && partialState != null) {
                throw new Error('setState(...): takes an object of state variables to update or a ' + 'function which returns an object of state variables.');
            }
            this.updater.enqueueSetState(this, partialState, callback, 'setState');
        };
        Component.prototype.forceUpdate = function(callback) {
            this.updater.enqueueForceUpdate(this, callback, 'forceUpdate');
        };
        {
            var deprecatedAPIs = {
                isMounted: [
                    'isMounted',
                    'Instead, make sure to clean up subscriptions and pending requests in ' + 'componentWillUnmount to prevent memory leaks.'
                ],
                replaceState: [
                    'replaceState',
                    'Refactor your code to use setState instead (see ' + 'https://github.com/facebook/react/issues/3236).'
                ]
            };
            var defineDeprecationWarning = function(methodName, info) {
                Object.defineProperty(Component.prototype, methodName, {
                    get: function() {
                        warn('%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]);
                        return undefined;
                    }
                });
            };
            for(var fnName in deprecatedAPIs){
                if (deprecatedAPIs.hasOwnProperty(fnName)) {
                    defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
                }
            }
        }
        function ComponentDummy() {}
        ComponentDummy.prototype = Component.prototype;
        function PureComponent(props, context, updater) {
            this.props = props;
            this.context = context;
            this.refs = emptyObject;
            this.updater = updater || ReactNoopUpdateQueue;
        }
        var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();
        pureComponentPrototype.constructor = PureComponent;
        assign(pureComponentPrototype, Component.prototype);
        pureComponentPrototype.isPureReactComponent = true;
        function createRef() {
            var refObject = {
                current: null
            };
            {
                Object.seal(refObject);
            }
            return refObject;
        }
        var isArrayImpl = Array.isArray;
        function isArray(a) {
            return isArrayImpl(a);
        }
        function typeName(value) {
            {
                var hasToStringTag = typeof Symbol === 'function' && Symbol.toStringTag;
                var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || 'Object';
                return type;
            }
        }
        function willCoercionThrow(value) {
            {
                try {
                    testStringCoercion(value);
                    return false;
                } catch (e) {
                    return true;
                }
            }
        }
        function testStringCoercion(value) {
            return '' + value;
        }
        function checkKeyStringCoercion(value) {
            {
                if (willCoercionThrow(value)) {
                    error('The provided key is an unsupported type %s.' + ' This value must be coerced to a string before before using it here.', typeName(value));
                    return testStringCoercion(value);
                }
            }
        }
        function getWrappedName(outerType, innerType, wrapperName) {
            var displayName = outerType.displayName;
            if (displayName) {
                return displayName;
            }
            var functionName = innerType.displayName || innerType.name || '';
            return functionName !== '' ? wrapperName + "(" + functionName + ")" : wrapperName;
        }
        function getContextName(type) {
            return type.displayName || 'Context';
        }
        function getComponentNameFromType(type) {
            if (type == null) {
                return null;
            }
            {
                if (typeof type.tag === 'number') {
                    error('Received an unexpected object in getComponentNameFromType(). ' + 'This is likely a bug in React. Please file an issue.');
                }
            }
            if (typeof type === 'function') {
                return type.displayName || type.name || null;
            }
            if (typeof type === 'string') {
                return type;
            }
            switch(type){
                case REACT_FRAGMENT_TYPE:
                    return 'Fragment';
                case REACT_PORTAL_TYPE:
                    return 'Portal';
                case REACT_PROFILER_TYPE:
                    return 'Profiler';
                case REACT_STRICT_MODE_TYPE:
                    return 'StrictMode';
                case REACT_SUSPENSE_TYPE:
                    return 'Suspense';
                case REACT_SUSPENSE_LIST_TYPE:
                    return 'SuspenseList';
                case REACT_CACHE_TYPE:
                    {
                        return 'Cache';
                    }
            }
            if (typeof type === 'object') {
                switch(type.$$typeof){
                    case REACT_CONTEXT_TYPE:
                        var context = type;
                        return getContextName(context) + '.Consumer';
                    case REACT_PROVIDER_TYPE:
                        var provider = type;
                        return getContextName(provider._context) + '.Provider';
                    case REACT_FORWARD_REF_TYPE:
                        return getWrappedName(type, type.render, 'ForwardRef');
                    case REACT_MEMO_TYPE:
                        var outerName = type.displayName || null;
                        if (outerName !== null) {
                            return outerName;
                        }
                        return getComponentNameFromType(type.type) || 'Memo';
                    case REACT_LAZY_TYPE:
                        {
                            var lazyComponent = type;
                            var payload = lazyComponent._payload;
                            var init = lazyComponent._init;
                            try {
                                return getComponentNameFromType(init(payload));
                            } catch (x) {
                                return null;
                            }
                        }
                    case REACT_SERVER_CONTEXT_TYPE:
                        {
                            var context2 = type;
                            return (context2.displayName || context2._globalName) + '.Provider';
                        }
                }
            }
            return null;
        }
        var hasOwnProperty = Object.prototype.hasOwnProperty;
        var RESERVED_PROPS = {
            key: true,
            ref: true,
            __self: true,
            __source: true
        };
        var specialPropKeyWarningShown, specialPropRefWarningShown, didWarnAboutStringRefs;
        {
            didWarnAboutStringRefs = {};
        }
        function hasValidRef(config) {
            {
                if (hasOwnProperty.call(config, 'ref')) {
                    var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;
                    if (getter && getter.isReactWarning) {
                        return false;
                    }
                }
            }
            return config.ref !== undefined;
        }
        function hasValidKey(config) {
            {
                if (hasOwnProperty.call(config, 'key')) {
                    var getter = Object.getOwnPropertyDescriptor(config, 'key').get;
                    if (getter && getter.isReactWarning) {
                        return false;
                    }
                }
            }
            return config.key !== undefined;
        }
        function defineKeyPropWarningGetter(props, displayName) {
            var warnAboutAccessingKey = function() {
                {
                    if (!specialPropKeyWarningShown) {
                        specialPropKeyWarningShown = true;
                        error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);
                    }
                }
            };
            warnAboutAccessingKey.isReactWarning = true;
            Object.defineProperty(props, 'key', {
                get: warnAboutAccessingKey,
                configurable: true
            });
        }
        function defineRefPropWarningGetter(props, displayName) {
            var warnAboutAccessingRef = function() {
                {
                    if (!specialPropRefWarningShown) {
                        specialPropRefWarningShown = true;
                        error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);
                    }
                }
            };
            warnAboutAccessingRef.isReactWarning = true;
            Object.defineProperty(props, 'ref', {
                get: warnAboutAccessingRef,
                configurable: true
            });
        }
        function warnIfStringRefCannotBeAutoConverted(config) {
            {
                if (typeof config.ref === 'string' && ReactCurrentOwner.current && config.__self && ReactCurrentOwner.current.stateNode !== config.__self) {
                    var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);
                    if (!didWarnAboutStringRefs[componentName]) {
                        error('Component "%s" contains the string ref "%s". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', componentName, config.ref);
                        didWarnAboutStringRefs[componentName] = true;
                    }
                }
            }
        }
        var ReactElement = function(type, key, ref, self, source, owner, props) {
            var element = {
                $$typeof: REACT_ELEMENT_TYPE,
                type: type,
                key: key,
                ref: ref,
                props: props,
                _owner: owner
            };
            {
                element._store = {};
                Object.defineProperty(element._store, 'validated', {
                    configurable: false,
                    enumerable: false,
                    writable: true,
                    value: false
                });
                Object.defineProperty(element, '_self', {
                    configurable: false,
                    enumerable: false,
                    writable: false,
                    value: self
                });
                Object.defineProperty(element, '_source', {
                    configurable: false,
                    enumerable: false,
                    writable: false,
                    value: source
                });
                if (Object.freeze) {
                    Object.freeze(element.props);
                    Object.freeze(element);
                }
            }
            return element;
        };
        function createElement(type, config, children) {
            var propName;
            var props = {};
            var key = null;
            var ref = null;
            var self = null;
            var source = null;
            if (config != null) {
                if (hasValidRef(config)) {
                    ref = config.ref;
                    {
                        warnIfStringRefCannotBeAutoConverted(config);
                    }
                }
                if (hasValidKey(config)) {
                    {
                        checkKeyStringCoercion(config.key);
                    }
                    key = '' + config.key;
                }
                self = config.__self === undefined ? null : config.__self;
                source = config.__source === undefined ? null : config.__source;
                for(propName in config){
                    if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
                        props[propName] = config[propName];
                    }
                }
            }
            var childrenLength = arguments.length - 2;
            if (childrenLength === 1) {
                props.children = children;
            } else if (childrenLength > 1) {
                var childArray = Array(childrenLength);
                for(var i = 0; i < childrenLength; i++){
                    childArray[i] = arguments[i + 2];
                }
                {
                    if (Object.freeze) {
                        Object.freeze(childArray);
                    }
                }
                props.children = childArray;
            }
            if (type && type.defaultProps) {
                var defaultProps = type.defaultProps;
                for(propName in defaultProps){
                    if (props[propName] === undefined) {
                        props[propName] = defaultProps[propName];
                    }
                }
            }
            {
                if (key || ref) {
                    var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;
                    if (key) {
                        defineKeyPropWarningGetter(props, displayName);
                    }
                    if (ref) {
                        defineRefPropWarningGetter(props, displayName);
                    }
                }
            }
            return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
        }
        function cloneAndReplaceKey(oldElement, newKey) {
            var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);
            return newElement;
        }
        function cloneElement(element, config, children) {
            if (element === null || element === undefined) {
                throw new Error("React.cloneElement(...): The argument must be a React element, but you passed " + element + ".");
            }
            var propName;
            var props = assign({}, element.props);
            var key = element.key;
            var ref = element.ref;
            var self = element._self;
            var source = element._source;
            var owner = element._owner;
            if (config != null) {
                if (hasValidRef(config)) {
                    ref = config.ref;
                    owner = ReactCurrentOwner.current;
                }
                if (hasValidKey(config)) {
                    {
                        checkKeyStringCoercion(config.key);
                    }
                    key = '' + config.key;
                }
                var defaultProps;
                if (element.type && element.type.defaultProps) {
                    defaultProps = element.type.defaultProps;
                }
                for(propName in config){
                    if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
                        if (config[propName] === undefined && defaultProps !== undefined) {
                            props[propName] = defaultProps[propName];
                        } else {
                            props[propName] = config[propName];
                        }
                    }
                }
            }
            var childrenLength = arguments.length - 2;
            if (childrenLength === 1) {
                props.children = children;
            } else if (childrenLength > 1) {
                var childArray = Array(childrenLength);
                for(var i = 0; i < childrenLength; i++){
                    childArray[i] = arguments[i + 2];
                }
                props.children = childArray;
            }
            return ReactElement(element.type, key, ref, self, source, owner, props);
        }
        function isValidElement(object) {
            return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
        }
        var SEPARATOR = '.';
        var SUBSEPARATOR = ':';
        function escape(key) {
            var escapeRegex = /[=:]/g;
            var escaperLookup = {
                '=': '=0',
                ':': '=2'
            };
            var escapedString = key.replace(escapeRegex, function(match) {
                return escaperLookup[match];
            });
            return '$' + escapedString;
        }
        var didWarnAboutMaps = false;
        var userProvidedKeyEscapeRegex = /\/+/g;
        function escapeUserProvidedKey(text) {
            return text.replace(userProvidedKeyEscapeRegex, '$&/');
        }
        function getElementKey(element, index) {
            if (typeof element === 'object' && element !== null && element.key != null) {
                {
                    checkKeyStringCoercion(element.key);
                }
                return escape('' + element.key);
            }
            return index.toString(36);
        }
        function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
            var type = typeof children;
            if (type === 'undefined' || type === 'boolean') {
                children = null;
            }
            var invokeCallback = false;
            if (children === null) {
                invokeCallback = true;
            } else {
                switch(type){
                    case 'string':
                    case 'number':
                        invokeCallback = true;
                        break;
                    case 'object':
                        switch(children.$$typeof){
                            case REACT_ELEMENT_TYPE:
                            case REACT_PORTAL_TYPE:
                                invokeCallback = true;
                        }
                }
            }
            if (invokeCallback) {
                var _child = children;
                var mappedChild = callback(_child);
                var childKey = nameSoFar === '' ? SEPARATOR + getElementKey(_child, 0) : nameSoFar;
                if (isArray(mappedChild)) {
                    var escapedChildKey = '';
                    if (childKey != null) {
                        escapedChildKey = escapeUserProvidedKey(childKey) + '/';
                    }
                    mapIntoArray(mappedChild, array, escapedChildKey, '', function(c) {
                        return c;
                    });
                } else if (mappedChild != null) {
                    if (isValidElement(mappedChild)) {
                        {
                            if (mappedChild.key && (!_child || _child.key !== mappedChild.key)) {
                                checkKeyStringCoercion(mappedChild.key);
                            }
                        }
                        mappedChild = cloneAndReplaceKey(mappedChild, escapedPrefix + (mappedChild.key && (!_child || _child.key !== mappedChild.key) ? escapeUserProvidedKey('' + mappedChild.key) + '/' : '') + childKey);
                    }
                    array.push(mappedChild);
                }
                return 1;
            }
            var child;
            var nextName;
            var subtreeCount = 0;
            var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;
            if (isArray(children)) {
                for(var i = 0; i < children.length; i++){
                    child = children[i];
                    nextName = nextNamePrefix + getElementKey(child, i);
                    subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);
                }
            } else {
                var iteratorFn = getIteratorFn(children);
                if (typeof iteratorFn === 'function') {
                    var iterableChildren = children;
                    {
                        if (iteratorFn === iterableChildren.entries) {
                            if (!didWarnAboutMaps) {
                                warn('Using Maps as children is not supported. ' + 'Use an array of keyed ReactElements instead.');
                            }
                            didWarnAboutMaps = true;
                        }
                    }
                    var iterator = iteratorFn.call(iterableChildren);
                    var step;
                    var ii = 0;
                    while(!(step = iterator.next()).done){
                        child = step.value;
                        nextName = nextNamePrefix + getElementKey(child, ii++);
                        subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);
                    }
                } else if (type === 'object') {
                    var childrenString = String(children);
                    throw new Error("Objects are not valid as a React child (found: " + (childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString) + "). " + 'If you meant to render a collection of children, use an array ' + 'instead.');
                }
            }
            return subtreeCount;
        }
        function mapChildren(children, func, context) {
            if (children == null) {
                return children;
            }
            var result = [];
            var count = 0;
            mapIntoArray(children, result, '', '', function(child) {
                return func.call(context, child, count++);
            });
            return result;
        }
        function countChildren(children) {
            var n = 0;
            mapChildren(children, function() {
                n++;
            });
            return n;
        }
        function forEachChildren(children, forEachFunc, forEachContext) {
            mapChildren(children, function() {
                forEachFunc.apply(this, arguments);
            }, forEachContext);
        }
        function toArray(children) {
            return mapChildren(children, function(child) {
                return child;
            }) || [];
        }
        function onlyChild(children) {
            if (!isValidElement(children)) {
                throw new Error('React.Children.only expected to receive a single React element child.');
            }
            return children;
        }
        function createContext(defaultValue) {
            var context = {
                $$typeof: REACT_CONTEXT_TYPE,
                _currentValue: defaultValue,
                _currentValue2: defaultValue,
                _threadCount: 0,
                Provider: null,
                Consumer: null,
                _defaultValue: null,
                _globalName: null
            };
            context.Provider = {
                $$typeof: REACT_PROVIDER_TYPE,
                _context: context
            };
            var hasWarnedAboutUsingNestedContextConsumers = false;
            var hasWarnedAboutUsingConsumerProvider = false;
            var hasWarnedAboutDisplayNameOnConsumer = false;
            {
                var Consumer = {
                    $$typeof: REACT_CONTEXT_TYPE,
                    _context: context
                };
                Object.defineProperties(Consumer, {
                    Provider: {
                        get: function() {
                            if (!hasWarnedAboutUsingConsumerProvider) {
                                hasWarnedAboutUsingConsumerProvider = true;
                                error('Rendering <Context.Consumer.Provider> is not supported and will be removed in ' + 'a future major release. Did you mean to render <Context.Provider> instead?');
                            }
                            return context.Provider;
                        },
                        set: function(_Provider) {
                            context.Provider = _Provider;
                        }
                    },
                    _currentValue: {
                        get: function() {
                            return context._currentValue;
                        },
                        set: function(_currentValue) {
                            context._currentValue = _currentValue;
                        }
                    },
                    _currentValue2: {
                        get: function() {
                            return context._currentValue2;
                        },
                        set: function(_currentValue2) {
                            context._currentValue2 = _currentValue2;
                        }
                    },
                    _threadCount: {
                        get: function() {
                            return context._threadCount;
                        },
                        set: function(_threadCount) {
                            context._threadCount = _threadCount;
                        }
                    },
                    Consumer: {
                        get: function() {
                            if (!hasWarnedAboutUsingNestedContextConsumers) {
                                hasWarnedAboutUsingNestedContextConsumers = true;
                                error('Rendering <Context.Consumer.Consumer> is not supported and will be removed in ' + 'a future major release. Did you mean to render <Context.Consumer> instead?');
                            }
                            return context.Consumer;
                        }
                    },
                    displayName: {
                        get: function() {
                            return context.displayName;
                        },
                        set: function(displayName) {
                            if (!hasWarnedAboutDisplayNameOnConsumer) {
                                warn('Setting `displayName` on Context.Consumer has no effect. ' + "You should set it directly on the context with Context.displayName = '%s'.", displayName);
                                hasWarnedAboutDisplayNameOnConsumer = true;
                            }
                        }
                    }
                });
                context.Consumer = Consumer;
            }
            {
                context._currentRenderer = null;
                context._currentRenderer2 = null;
            }
            return context;
        }
        var Uninitialized = -1;
        var Pending = 0;
        var Resolved = 1;
        var Rejected = 2;
        function lazyInitializer(payload) {
            if (payload._status === Uninitialized) {
                var ctor = payload._result;
                var thenable = ctor();
                thenable.then(function(moduleObject) {
                    if (payload._status === Pending || payload._status === Uninitialized) {
                        var resolved = payload;
                        resolved._status = Resolved;
                        resolved._result = moduleObject;
                    }
                }, function(error) {
                    if (payload._status === Pending || payload._status === Uninitialized) {
                        var rejected = payload;
                        rejected._status = Rejected;
                        rejected._result = error;
                    }
                });
                if (payload._status === Uninitialized) {
                    var pending = payload;
                    pending._status = Pending;
                    pending._result = thenable;
                }
            }
            if (payload._status === Resolved) {
                var moduleObject = payload._result;
                {
                    if (moduleObject === undefined) {
                        error('lazy: Expected the result of a dynamic imp' + 'ort() call. ' + 'Instead received: %s\n\nYour code should look like: \n  ' + 'const MyComponent = lazy(() => imp' + "ort('./MyComponent'))\n\n" + 'Did you accidentally put curly braces around the import?', moduleObject);
                    }
                }
                {
                    if (!('default' in moduleObject)) {
                        error('lazy: Expected the result of a dynamic imp' + 'ort() call. ' + 'Instead received: %s\n\nYour code should look like: \n  ' + 'const MyComponent = lazy(() => imp' + "ort('./MyComponent'))", moduleObject);
                    }
                }
                return moduleObject.default;
            } else {
                throw payload._result;
            }
        }
        function lazy(ctor) {
            var payload = {
                _status: Uninitialized,
                _result: ctor
            };
            var lazyType = {
                $$typeof: REACT_LAZY_TYPE,
                _payload: payload,
                _init: lazyInitializer
            };
            {
                var defaultProps;
                var propTypes;
                Object.defineProperties(lazyType, {
                    defaultProps: {
                        configurable: true,
                        get: function() {
                            return defaultProps;
                        },
                        set: function(newDefaultProps) {
                            error('React.lazy(...): It is not supported to assign `defaultProps` to ' + 'a lazy component import. Either specify them where the component ' + 'is defined, or create a wrapping component around it.');
                            defaultProps = newDefaultProps;
                            Object.defineProperty(lazyType, 'defaultProps', {
                                enumerable: true
                            });
                        }
                    },
                    propTypes: {
                        configurable: true,
                        get: function() {
                            return propTypes;
                        },
                        set: function(newPropTypes) {
                            error('React.lazy(...): It is not supported to assign `propTypes` to ' + 'a lazy component import. Either specify them where the component ' + 'is defined, or create a wrapping component around it.');
                            propTypes = newPropTypes;
                            Object.defineProperty(lazyType, 'propTypes', {
                                enumerable: true
                            });
                        }
                    }
                });
            }
            return lazyType;
        }
        function forwardRef(render) {
            {
                if (render != null && render.$$typeof === REACT_MEMO_TYPE) {
                    error('forwardRef requires a render function but received a `memo` ' + 'component. Instead of forwardRef(memo(...)), use ' + 'memo(forwardRef(...)).');
                } else if (typeof render !== 'function') {
                    error('forwardRef requires a render function but was given %s.', render === null ? 'null' : typeof render);
                } else {
                    if (render.length !== 0 && render.length !== 2) {
                        error('forwardRef render functions accept exactly two parameters: props and ref. %s', render.length === 1 ? 'Did you forget to use the ref parameter?' : 'Any additional parameter will be undefined.');
                    }
                }
                if (render != null) {
                    if (render.defaultProps != null || render.propTypes != null) {
                        error('forwardRef render functions do not support propTypes or defaultProps. ' + 'Did you accidentally pass a React component?');
                    }
                }
            }
            var elementType = {
                $$typeof: REACT_FORWARD_REF_TYPE,
                render: render
            };
            {
                var ownName;
                Object.defineProperty(elementType, 'displayName', {
                    enumerable: false,
                    configurable: true,
                    get: function() {
                        return ownName;
                    },
                    set: function(name) {
                        ownName = name;
                        if (!render.name && !render.displayName) {
                            render.displayName = name;
                        }
                    }
                });
            }
            return elementType;
        }
        var REACT_MODULE_REFERENCE = Symbol.for('react.module.reference');
        function isValidElementType(type) {
            if (typeof type === 'string' || typeof type === 'function') {
                return true;
            }
            if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {
                return true;
            }
            if (typeof type === 'object' && type !== null) {
                if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== undefined) {
                    return true;
                }
            }
            return false;
        }
        function memo(type, compare) {
            {
                if (!isValidElementType(type)) {
                    error('memo: The first argument must be a component. Instead ' + 'received: %s', type === null ? 'null' : typeof type);
                }
            }
            var elementType = {
                $$typeof: REACT_MEMO_TYPE,
                type: type,
                compare: compare === undefined ? null : compare
            };
            {
                var ownName;
                Object.defineProperty(elementType, 'displayName', {
                    enumerable: false,
                    configurable: true,
                    get: function() {
                        return ownName;
                    },
                    set: function(name) {
                        ownName = name;
                        if (!type.name && !type.displayName) {
                            type.displayName = name;
                        }
                    }
                });
            }
            return elementType;
        }
        var UNTERMINATED = 0;
        var TERMINATED = 1;
        var ERRORED = 2;
        function createCacheRoot() {
            return new WeakMap();
        }
        function createCacheNode() {
            return {
                s: UNTERMINATED,
                v: undefined,
                o: null,
                p: null
            };
        }
        function cache(fn) {
            return function() {
                var dispatcher = ReactCurrentCache.current;
                if (!dispatcher) {
                    return fn.apply(null, arguments);
                }
                var fnMap = dispatcher.getCacheForType(createCacheRoot);
                var fnNode = fnMap.get(fn);
                var cacheNode;
                if (fnNode === undefined) {
                    cacheNode = createCacheNode();
                    fnMap.set(fn, cacheNode);
                } else {
                    cacheNode = fnNode;
                }
                for(var i = 0, l = arguments.length; i < l; i++){
                    var arg = arguments[i];
                    if (typeof arg === 'function' || typeof arg === 'object' && arg !== null) {
                        var objectCache = cacheNode.o;
                        if (objectCache === null) {
                            cacheNode.o = objectCache = new WeakMap();
                        }
                        var objectNode = objectCache.get(arg);
                        if (objectNode === undefined) {
                            cacheNode = createCacheNode();
                            objectCache.set(arg, cacheNode);
                        } else {
                            cacheNode = objectNode;
                        }
                    } else {
                        var primitiveCache = cacheNode.p;
                        if (primitiveCache === null) {
                            cacheNode.p = primitiveCache = new Map();
                        }
                        var primitiveNode = primitiveCache.get(arg);
                        if (primitiveNode === undefined) {
                            cacheNode = createCacheNode();
                            primitiveCache.set(arg, cacheNode);
                        } else {
                            cacheNode = primitiveNode;
                        }
                    }
                }
                if (cacheNode.s === TERMINATED) {
                    return cacheNode.v;
                }
                if (cacheNode.s === ERRORED) {
                    throw cacheNode.v;
                }
                try {
                    var result = fn.apply(null, arguments);
                    var terminatedNode = cacheNode;
                    terminatedNode.s = TERMINATED;
                    terminatedNode.v = result;
                    return result;
                } catch (error) {
                    var erroredNode = cacheNode;
                    erroredNode.s = ERRORED;
                    erroredNode.v = error;
                    throw error;
                }
            };
        }
        function resolveDispatcher() {
            var dispatcher = ReactCurrentDispatcher.current;
            {
                if (dispatcher === null) {
                    error('Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for' + ' one of the following reasons:\n' + '1. You might have mismatching versions of React and the renderer (such as React DOM)\n' + '2. You might be breaking the Rules of Hooks\n' + '3. You might have more than one copy of React in the same app\n' + 'See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.');
                }
            }
            return dispatcher;
        }
        function useContext(Context) {
            var dispatcher = resolveDispatcher();
            {
                if (Context._context !== undefined) {
                    var realContext = Context._context;
                    if (realContext.Consumer === Context) {
                        error('Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be ' + 'removed in a future major release. Did you mean to call useContext(Context) instead?');
                    } else if (realContext.Provider === Context) {
                        error('Calling useContext(Context.Provider) is not supported. ' + 'Did you mean to call useContext(Context) instead?');
                    }
                }
            }
            return dispatcher.useContext(Context);
        }
        function useState(initialState) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useState(initialState);
        }
        function useReducer(reducer, initialArg, init) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useReducer(reducer, initialArg, init);
        }
        function useRef(initialValue) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useRef(initialValue);
        }
        function useEffect(create, deps) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useEffect(create, deps);
        }
        function useInsertionEffect(create, deps) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useInsertionEffect(create, deps);
        }
        function useLayoutEffect(create, deps) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useLayoutEffect(create, deps);
        }
        function useCallback(callback, deps) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useCallback(callback, deps);
        }
        function useMemo(create, deps) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useMemo(create, deps);
        }
        function useImperativeHandle(ref, create, deps) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useImperativeHandle(ref, create, deps);
        }
        function useDebugValue(value, formatterFn) {
            {
                var dispatcher = resolveDispatcher();
                return dispatcher.useDebugValue(value, formatterFn);
            }
        }
        function useTransition() {
            var dispatcher = resolveDispatcher();
            return dispatcher.useTransition();
        }
        function useDeferredValue(value) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useDeferredValue(value);
        }
        function useId() {
            var dispatcher = resolveDispatcher();
            return dispatcher.useId();
        }
        function useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
        }
        function useCacheRefresh() {
            var dispatcher = resolveDispatcher();
            return dispatcher.useCacheRefresh();
        }
        function use(usable) {
            var dispatcher = resolveDispatcher();
            return dispatcher.use(usable);
        }
        var disabledDepth = 0;
        var prevLog;
        var prevInfo;
        var prevWarn;
        var prevError;
        var prevGroup;
        var prevGroupCollapsed;
        var prevGroupEnd;
        function disabledLog() {}
        disabledLog.__reactDisabledLog = true;
        function disableLogs() {
            {
                if (disabledDepth === 0) {
                    prevLog = console.log;
                    prevInfo = console.info;
                    prevWarn = console.warn;
                    prevError = console.error;
                    prevGroup = console.group;
                    prevGroupCollapsed = console.groupCollapsed;
                    prevGroupEnd = console.groupEnd;
                    var props = {
                        configurable: true,
                        enumerable: true,
                        value: disabledLog,
                        writable: true
                    };
                    Object.defineProperties(console, {
                        info: props,
                        log: props,
                        warn: props,
                        error: props,
                        group: props,
                        groupCollapsed: props,
                        groupEnd: props
                    });
                }
                disabledDepth++;
            }
        }
        function reenableLogs() {
            {
                disabledDepth--;
                if (disabledDepth === 0) {
                    var props = {
                        configurable: true,
                        enumerable: true,
                        writable: true
                    };
                    Object.defineProperties(console, {
                        log: assign({}, props, {
                            value: prevLog
                        }),
                        info: assign({}, props, {
                            value: prevInfo
                        }),
                        warn: assign({}, props, {
                            value: prevWarn
                        }),
                        error: assign({}, props, {
                            value: prevError
                        }),
                        group: assign({}, props, {
                            value: prevGroup
                        }),
                        groupCollapsed: assign({}, props, {
                            value: prevGroupCollapsed
                        }),
                        groupEnd: assign({}, props, {
                            value: prevGroupEnd
                        })
                    });
                }
                if (disabledDepth < 0) {
                    error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');
                }
            }
        }
        var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher;
        var prefix;
        function describeBuiltInComponentFrame(name, source, ownerFn) {
            {
                if (prefix === undefined) {
                    try {
                        throw Error();
                    } catch (x) {
                        var match = x.stack.trim().match(/\n( *(at )?)/);
                        prefix = match && match[1] || '';
                    }
                }
                return '\n' + prefix + name;
            }
        }
        var reentry = false;
        var componentFrameCache;
        {
            var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;
            componentFrameCache = new PossiblyWeakMap();
        }
        function describeNativeComponentFrame(fn, construct) {
            if (!fn || reentry) {
                return '';
            }
            {
                var frame = componentFrameCache.get(fn);
                if (frame !== undefined) {
                    return frame;
                }
            }
            var control;
            reentry = true;
            var previousPrepareStackTrace = Error.prepareStackTrace;
            Error.prepareStackTrace = undefined;
            var previousDispatcher;
            {
                previousDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = null;
                disableLogs();
            }
            try {
                if (construct) {
                    var Fake = function() {
                        throw Error();
                    };
                    Object.defineProperty(Fake.prototype, 'props', {
                        set: function() {
                            throw Error();
                        }
                    });
                    if (typeof Reflect === 'object' && Reflect.construct) {
                        try {
                            Reflect.construct(Fake, []);
                        } catch (x) {
                            control = x;
                        }
                        Reflect.construct(fn, [], Fake);
                    } else {
                        try {
                            Fake.call();
                        } catch (x) {
                            control = x;
                        }
                        fn.call(Fake.prototype);
                    }
                } else {
                    try {
                        throw Error();
                    } catch (x) {
                        control = x;
                    }
                    fn();
                }
            } catch (sample) {
                if (sample && control && typeof sample.stack === 'string') {
                    var sampleLines = sample.stack.split('\n');
                    var controlLines = control.stack.split('\n');
                    var s = sampleLines.length - 1;
                    var c = controlLines.length - 1;
                    while(s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]){
                        c--;
                    }
                    for(; s >= 1 && c >= 0; s--, c--){
                        if (sampleLines[s] !== controlLines[c]) {
                            if (s !== 1 || c !== 1) {
                                do {
                                    s--;
                                    c--;
                                    if (c < 0 || sampleLines[s] !== controlLines[c]) {
                                        var _frame = '\n' + sampleLines[s].replace(' at new ', ' at ');
                                        if (fn.displayName && _frame.includes('<anonymous>')) {
                                            _frame = _frame.replace('<anonymous>', fn.displayName);
                                        }
                                        {
                                            if (typeof fn === 'function') {
                                                componentFrameCache.set(fn, _frame);
                                            }
                                        }
                                        return _frame;
                                    }
                                }while (s >= 1 && c >= 0)
                            }
                            break;
                        }
                    }
                }
            } finally{
                reentry = false;
                {
                    ReactCurrentDispatcher$1.current = previousDispatcher;
                    reenableLogs();
                }
                Error.prepareStackTrace = previousPrepareStackTrace;
            }
            var name = fn ? fn.displayName || fn.name : '';
            var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';
            {
                if (typeof fn === 'function') {
                    componentFrameCache.set(fn, syntheticFrame);
                }
            }
            return syntheticFrame;
        }
        function describeFunctionComponentFrame(fn, source, ownerFn) {
            {
                return describeNativeComponentFrame(fn, false);
            }
        }
        function shouldConstruct(Component) {
            var prototype = Component.prototype;
            return !!(prototype && prototype.isReactComponent);
        }
        function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
            if (type == null) {
                return '';
            }
            if (typeof type === 'function') {
                {
                    return describeNativeComponentFrame(type, shouldConstruct(type));
                }
            }
            if (typeof type === 'string') {
                return describeBuiltInComponentFrame(type);
            }
            switch(type){
                case REACT_SUSPENSE_TYPE:
                    return describeBuiltInComponentFrame('Suspense');
                case REACT_SUSPENSE_LIST_TYPE:
                    return describeBuiltInComponentFrame('SuspenseList');
            }
            if (typeof type === 'object') {
                switch(type.$$typeof){
                    case REACT_FORWARD_REF_TYPE:
                        return describeFunctionComponentFrame(type.render);
                    case REACT_MEMO_TYPE:
                        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
                    case REACT_LAZY_TYPE:
                        {
                            var lazyComponent = type;
                            var payload = lazyComponent._payload;
                            var init = lazyComponent._init;
                            try {
                                return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
                            } catch (x) {}
                        }
                }
            }
            return '';
        }
        var loggedTypeFailures = {};
        var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
        function setCurrentlyValidatingElement(element) {
            {
                if (element) {
                    var owner = element._owner;
                    var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
                    ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
                } else {
                    ReactDebugCurrentFrame$1.setExtraStackFrame(null);
                }
            }
        }
        function checkPropTypes(typeSpecs, values, location, componentName, element) {
            {
                var has = Function.call.bind(hasOwnProperty);
                for(var typeSpecName in typeSpecs){
                    if (has(typeSpecs, typeSpecName)) {
                        var error$1 = void 0;
                        try {
                            if (typeof typeSpecs[typeSpecName] !== 'function') {
                                var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');
                                err.name = 'Invariant Violation';
                                throw err;
                            }
                            error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');
                        } catch (ex) {
                            error$1 = ex;
                        }
                        if (error$1 && !(error$1 instanceof Error)) {
                            setCurrentlyValidatingElement(element);
                            error('%s: type specification of %s' + ' `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error$1);
                            setCurrentlyValidatingElement(null);
                        }
                        if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                            loggedTypeFailures[error$1.message] = true;
                            setCurrentlyValidatingElement(element);
                            error('Failed %s type: %s', location, error$1.message);
                            setCurrentlyValidatingElement(null);
                        }
                    }
                }
            }
        }
        function setCurrentlyValidatingElement$1(element) {
            {
                if (element) {
                    var owner = element._owner;
                    var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
                    setExtraStackFrame(stack);
                } else {
                    setExtraStackFrame(null);
                }
            }
        }
        var propTypesMisspellWarningShown;
        {
            propTypesMisspellWarningShown = false;
        }
        function getDeclarationErrorAddendum() {
            if (ReactCurrentOwner.current) {
                var name = getComponentNameFromType(ReactCurrentOwner.current.type);
                if (name) {
                    return '\n\nCheck the render method of `' + name + '`.';
                }
            }
            return '';
        }
        function getSourceInfoErrorAddendum(source) {
            if (source !== undefined) {
                var fileName = source.fileName.replace(/^.*[\\\/]/, '');
                var lineNumber = source.lineNumber;
                return '\n\nCheck your code at ' + fileName + ':' + lineNumber + '.';
            }
            return '';
        }
        function getSourceInfoErrorAddendumForProps(elementProps) {
            if (elementProps !== null && elementProps !== undefined) {
                return getSourceInfoErrorAddendum(elementProps.__source);
            }
            return '';
        }
        var ownerHasKeyUseWarning = {};
        function getCurrentComponentErrorInfo(parentType) {
            var info = getDeclarationErrorAddendum();
            if (!info) {
                var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;
                if (parentName) {
                    info = "\n\nCheck the top-level render call using <" + parentName + ">.";
                }
            }
            return info;
        }
        function validateExplicitKey(element, parentType) {
            if (!element._store || element._store.validated || element.key != null) {
                return;
            }
            element._store.validated = true;
            var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
            if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
                return;
            }
            ownerHasKeyUseWarning[currentComponentErrorInfo] = true;
            var childOwner = '';
            if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
                childOwner = " It was passed a child from " + getComponentNameFromType(element._owner.type) + ".";
            }
            {
                setCurrentlyValidatingElement$1(element);
                error('Each child in a list should have a unique "key" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);
                setCurrentlyValidatingElement$1(null);
            }
        }
        function validateChildKeys(node, parentType) {
            if (typeof node !== 'object') {
                return;
            }
            if (isArray(node)) {
                for(var i = 0; i < node.length; i++){
                    var child = node[i];
                    if (isValidElement(child)) {
                        validateExplicitKey(child, parentType);
                    }
                }
            } else if (isValidElement(node)) {
                if (node._store) {
                    node._store.validated = true;
                }
            } else if (node) {
                var iteratorFn = getIteratorFn(node);
                if (typeof iteratorFn === 'function') {
                    if (iteratorFn !== node.entries) {
                        var iterator = iteratorFn.call(node);
                        var step;
                        while(!(step = iterator.next()).done){
                            if (isValidElement(step.value)) {
                                validateExplicitKey(step.value, parentType);
                            }
                        }
                    }
                }
            }
        }
        function validatePropTypes(element) {
            {
                var type = element.type;
                if (type === null || type === undefined || typeof type === 'string') {
                    return;
                }
                var propTypes;
                if (typeof type === 'function') {
                    propTypes = type.propTypes;
                } else if (typeof type === 'object' && (type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_MEMO_TYPE)) {
                    propTypes = type.propTypes;
                } else {
                    return;
                }
                if (propTypes) {
                    var name = getComponentNameFromType(type);
                    checkPropTypes(propTypes, element.props, 'prop', name, element);
                } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {
                    propTypesMisspellWarningShown = true;
                    var _name = getComponentNameFromType(type);
                    error('Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', _name || 'Unknown');
                }
                if (typeof type.getDefaultProps === 'function' && !type.getDefaultProps.isReactClassApproved) {
                    error('getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');
                }
            }
        }
        function validateFragmentProps(fragment) {
            {
                var keys = Object.keys(fragment.props);
                for(var i = 0; i < keys.length; i++){
                    var key = keys[i];
                    if (key !== 'children' && key !== 'key') {
                        setCurrentlyValidatingElement$1(fragment);
                        error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);
                        setCurrentlyValidatingElement$1(null);
                        break;
                    }
                }
                if (fragment.ref !== null) {
                    setCurrentlyValidatingElement$1(fragment);
                    error('Invalid attribute `ref` supplied to `React.Fragment`.');
                    setCurrentlyValidatingElement$1(null);
                }
            }
        }
        function createElementWithValidation(type, props, children) {
            var validType = isValidElementType(type);
            if (!validType) {
                var info = '';
                if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {
                    info += ' You likely forgot to export your component from the file ' + "it's defined in, or you might have mixed up default and named imports.";
                }
                var sourceInfo = getSourceInfoErrorAddendumForProps(props);
                if (sourceInfo) {
                    info += sourceInfo;
                } else {
                    info += getDeclarationErrorAddendum();
                }
                var typeString;
                if (type === null) {
                    typeString = 'null';
                } else if (isArray(type)) {
                    typeString = 'array';
                } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {
                    typeString = "<" + (getComponentNameFromType(type.type) || 'Unknown') + " />";
                    info = ' Did you accidentally export a JSX literal instead of a component?';
                } else {
                    typeString = typeof type;
                }
                {
                    error('React.createElement: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);
                }
            }
            var element = createElement.apply(this, arguments);
            if (element == null) {
                return element;
            }
            if (validType) {
                for(var i = 2; i < arguments.length; i++){
                    validateChildKeys(arguments[i], type);
                }
            }
            if (type === REACT_FRAGMENT_TYPE) {
                validateFragmentProps(element);
            } else {
                validatePropTypes(element);
            }
            return element;
        }
        var didWarnAboutDeprecatedCreateFactory = false;
        function createFactoryWithValidation(type) {
            var validatedFactory = createElementWithValidation.bind(null, type);
            validatedFactory.type = type;
            {
                if (!didWarnAboutDeprecatedCreateFactory) {
                    didWarnAboutDeprecatedCreateFactory = true;
                    warn('React.createFactory() is deprecated and will be removed in ' + 'a future major release. Consider using JSX ' + 'or use React.createElement() directly instead.');
                }
                Object.defineProperty(validatedFactory, 'type', {
                    enumerable: false,
                    get: function() {
                        warn('Factory.type is deprecated. Access the class directly ' + 'before passing it to createFactory.');
                        Object.defineProperty(this, 'type', {
                            value: type
                        });
                        return type;
                    }
                });
            }
            return validatedFactory;
        }
        function cloneElementWithValidation(element, props, children) {
            var newElement = cloneElement.apply(this, arguments);
            for(var i = 2; i < arguments.length; i++){
                validateChildKeys(arguments[i], newElement.type);
            }
            validatePropTypes(newElement);
            return newElement;
        }
        var ContextRegistry$1 = ReactSharedInternals.ContextRegistry;
        function createServerContext(globalName, defaultValue) {
            var wasDefined = true;
            if (!ContextRegistry$1[globalName]) {
                wasDefined = false;
                var _context = {
                    $$typeof: REACT_SERVER_CONTEXT_TYPE,
                    _currentValue: defaultValue,
                    _currentValue2: defaultValue,
                    _defaultValue: defaultValue,
                    _threadCount: 0,
                    Provider: null,
                    Consumer: null,
                    _globalName: globalName
                };
                _context.Provider = {
                    $$typeof: REACT_PROVIDER_TYPE,
                    _context: _context
                };
                {
                    var hasWarnedAboutUsingConsumer;
                    _context._currentRenderer = null;
                    _context._currentRenderer2 = null;
                    Object.defineProperties(_context, {
                        Consumer: {
                            get: function() {
                                if (!hasWarnedAboutUsingConsumer) {
                                    error('Consumer pattern is not supported by ReactServerContext');
                                    hasWarnedAboutUsingConsumer = true;
                                }
                                return null;
                            }
                        }
                    });
                }
                ContextRegistry$1[globalName] = _context;
            }
            var context = ContextRegistry$1[globalName];
            if (context._defaultValue === REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED) {
                context._defaultValue = defaultValue;
                if (context._currentValue === REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED) {
                    context._currentValue = defaultValue;
                }
                if (context._currentValue2 === REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED) {
                    context._currentValue2 = defaultValue;
                }
            } else if (wasDefined) {
                throw new Error("ServerContext: " + globalName + " already defined");
            }
            return context;
        }
        function startTransition(scope, options) {
            var prevTransition = ReactCurrentBatchConfig.transition;
            ReactCurrentBatchConfig.transition = {};
            var currentTransition = ReactCurrentBatchConfig.transition;
            {
                ReactCurrentBatchConfig.transition._updatedFibers = new Set();
            }
            try {
                scope();
            } finally{
                ReactCurrentBatchConfig.transition = prevTransition;
                {
                    if (prevTransition === null && currentTransition._updatedFibers) {
                        var updatedFibersCount = currentTransition._updatedFibers.size;
                        if (updatedFibersCount > 10) {
                            warn('Detected a large number of updates inside startTransition. ' + 'If this is due to a subscription please re-write it to use React provided hooks. ' + 'Otherwise concurrent mode guarantees are off the table.');
                        }
                        currentTransition._updatedFibers.clear();
                    }
                }
            }
        }
        var didWarnAboutMessageChannel = false;
        var enqueueTaskImpl = null;
        function enqueueTask(task) {
            if (enqueueTaskImpl === null) {
                try {
                    var requireString = ('require' + Math.random()).slice(0, 7);
                    var nodeRequire = module && module[requireString];
                    enqueueTaskImpl = nodeRequire.call(module, 'timers').setImmediate;
                } catch (_err) {
                    enqueueTaskImpl = function(callback) {
                        {
                            if (didWarnAboutMessageChannel === false) {
                                didWarnAboutMessageChannel = true;
                                if (typeof MessageChannel === 'undefined') {
                                    error('This browser does not have a MessageChannel implementation, ' + 'so enqueuing tasks via await act(async () => ...) will fail. ' + 'Please file an issue at https://github.com/facebook/react/issues ' + 'if you encounter this warning.');
                                }
                            }
                        }
                        var channel = new MessageChannel();
                        channel.port1.onmessage = callback;
                        channel.port2.postMessage(undefined);
                    };
                }
            }
            return enqueueTaskImpl(task);
        }
        var actScopeDepth = 0;
        var didWarnNoAwaitAct = false;
        function act(callback) {
            {
                var prevIsBatchingLegacy = ReactCurrentActQueue.isBatchingLegacy;
                var prevActQueue = ReactCurrentActQueue.current;
                var prevActScopeDepth = actScopeDepth;
                actScopeDepth++;
                var queue = ReactCurrentActQueue.current = prevActQueue !== null ? prevActQueue : [];
                ReactCurrentActQueue.isBatchingLegacy = true;
                var result;
                var didAwaitActCall = false;
                try {
                    ReactCurrentActQueue.didScheduleLegacyUpdate = false;
                    result = callback();
                    var didScheduleLegacyUpdate = ReactCurrentActQueue.didScheduleLegacyUpdate;
                    if (!prevIsBatchingLegacy && didScheduleLegacyUpdate) {
                        flushActQueue(queue);
                    }
                    ReactCurrentActQueue.isBatchingLegacy = prevIsBatchingLegacy;
                } catch (error) {
                    ReactCurrentActQueue.isBatchingLegacy = prevIsBatchingLegacy;
                    popActScope(prevActQueue, prevActScopeDepth);
                    throw error;
                }
                if (result !== null && typeof result === 'object' && typeof result.then === 'function') {
                    var thenable = result;
                    queueSeveralMicrotasks(function() {
                        if (!didAwaitActCall && !didWarnNoAwaitAct) {
                            didWarnNoAwaitAct = true;
                            error('You called act(async () => ...) without await. ' + 'This could lead to unexpected testing behaviour, ' + 'interleaving multiple act calls and mixing their ' + 'scopes. ' + 'You should - await act(async () => ...);');
                        }
                    });
                    return {
                        then: function(resolve, reject) {
                            didAwaitActCall = true;
                            thenable.then(function(returnValue) {
                                popActScope(prevActQueue, prevActScopeDepth);
                                if (prevActScopeDepth === 0) {
                                    try {
                                        flushActQueue(queue);
                                        enqueueTask(function() {
                                            return recursivelyFlushAsyncActWork(returnValue, resolve, reject);
                                        });
                                    } catch (error) {
                                        reject(error);
                                    }
                                } else {
                                    resolve(returnValue);
                                }
                            }, function(error) {
                                popActScope(prevActQueue, prevActScopeDepth);
                                reject(error);
                            });
                        }
                    };
                } else {
                    var returnValue = result;
                    popActScope(prevActQueue, prevActScopeDepth);
                    if (prevActScopeDepth === 0) {
                        flushActQueue(queue);
                        if (queue.length !== 0) {
                            queueSeveralMicrotasks(function() {
                                if (!didAwaitActCall && !didWarnNoAwaitAct) {
                                    didWarnNoAwaitAct = true;
                                    error('A component suspended inside an `act` scope, but the ' + '`act` call was not awaited. When testing React ' + 'components that depend on asynchronous data, you must ' + 'await the result:\n\n' + 'await act(() => ...)');
                                }
                            });
                        }
                        ReactCurrentActQueue.current = null;
                    }
                    return {
                        then: function(resolve, reject) {
                            didAwaitActCall = true;
                            if (prevActScopeDepth === 0) {
                                ReactCurrentActQueue.current = queue;
                                enqueueTask(function() {
                                    return recursivelyFlushAsyncActWork(returnValue, resolve, reject);
                                });
                            } else {
                                resolve(returnValue);
                            }
                        }
                    };
                }
            }
        }
        function popActScope(prevActQueue, prevActScopeDepth) {
            {
                if (prevActScopeDepth !== actScopeDepth - 1) {
                    error('You seem to have overlapping act() calls, this is not supported. ' + 'Be sure to await previous act() calls before making a new one. ');
                }
                actScopeDepth = prevActScopeDepth;
            }
        }
        function recursivelyFlushAsyncActWork(returnValue, resolve, reject) {
            {
                var queue = ReactCurrentActQueue.current;
                if (queue !== null) {
                    if (queue.length !== 0) {
                        try {
                            flushActQueue(queue);
                            enqueueTask(function() {
                                return recursivelyFlushAsyncActWork(returnValue, resolve, reject);
                            });
                        } catch (error) {
                            reject(error);
                        }
                    } else {
                        ReactCurrentActQueue.current = null;
                        resolve(returnValue);
                    }
                } else {
                    resolve(returnValue);
                }
            }
        }
        var isFlushing = false;
        function flushActQueue(queue) {
            {
                if (!isFlushing) {
                    isFlushing = true;
                    var i = 0;
                    try {
                        for(; i < queue.length; i++){
                            var callback = queue[i];
                            do {
                                ReactCurrentActQueue.didUsePromise = false;
                                var continuation = callback(false);
                                if (continuation !== null) {
                                    if (ReactCurrentActQueue.didUsePromise) {
                                        queue[i] = callback;
                                        queue.splice(0, i);
                                        return;
                                    }
                                    callback = continuation;
                                } else {
                                    break;
                                }
                            }while (true)
                        }
                        queue.length = 0;
                    } catch (error) {
                        queue.splice(0, i + 1);
                        throw error;
                    } finally{
                        isFlushing = false;
                    }
                }
            }
        }
        var queueSeveralMicrotasks = typeof queueMicrotask === 'function' ? function(callback) {
            queueMicrotask(function() {
                return queueMicrotask(callback);
            });
        } : enqueueTask;
        var createElement$1 = createElementWithValidation;
        var cloneElement$1 = cloneElementWithValidation;
        var createFactory = createFactoryWithValidation;
        var Children = {
            map: mapChildren,
            forEach: forEachChildren,
            count: countChildren,
            toArray: toArray,
            only: onlyChild
        };
        exports.Children = Children;
        exports.Component = Component;
        exports.Fragment = REACT_FRAGMENT_TYPE;
        exports.Profiler = REACT_PROFILER_TYPE;
        exports.PureComponent = PureComponent;
        exports.StrictMode = REACT_STRICT_MODE_TYPE;
        exports.Suspense = REACT_SUSPENSE_TYPE;
        exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactSharedInternals;
        exports.cache = cache;
        exports.cloneElement = cloneElement$1;
        exports.createContext = createContext;
        exports.createElement = createElement$1;
        exports.createFactory = createFactory;
        exports.createRef = createRef;
        exports.createServerContext = createServerContext;
        exports.forwardRef = forwardRef;
        exports.isValidElement = isValidElement;
        exports.lazy = lazy;
        exports.memo = memo;
        exports.startTransition = startTransition;
        exports.unstable_act = act;
        exports.unstable_useCacheRefresh = useCacheRefresh;
        exports.use = use;
        exports.useCallback = useCallback;
        exports.useContext = useContext;
        exports.useDebugValue = useDebugValue;
        exports.useDeferredValue = useDeferredValue;
        exports.useEffect = useEffect;
        exports.useId = useId;
        exports.useImperativeHandle = useImperativeHandle;
        exports.useInsertionEffect = useInsertionEffect;
        exports.useLayoutEffect = useLayoutEffect;
        exports.useMemo = useMemo;
        exports.useReducer = useReducer;
        exports.useRef = useRef;
        exports.useState = useState;
        exports.useSyncExternalStore = useSyncExternalStore;
        exports.useTransition = useTransition;
        exports.version = ReactVersion;
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === 'function') {
            __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
        }
    })();
}

}.call(this) }),
"[project-with-next]/node_modules/next/dist/compiled/string-hash/index.js (ecmascript, ssr)": (function({ r: __turbopack_require__, x: __turbopack_external_require__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, c: __turbopack_cache__, l: __turbopack_load__, p: process, __dirname, m: module, e: exports }) { !function() {

(()=>{
    "use strict";
    var e = {
        328: (e)=>{
            function hash(e) {
                var r = 5381, _ = e.length;
                while(_){
                    r = r * 33 ^ e.charCodeAt(--_);
                }
                return r >>> 0;
            }
            e.exports = hash;
        }
    };
    var r = {};
    function __nccwpck_require__(_) {
        var a = r[_];
        if (a !== undefined) {
            return a.exports;
        }
        var t = r[_] = {
            exports: {}
        };
        var i = true;
        try {
            e[_](t, t.exports, __nccwpck_require__);
            i = false;
        } finally{
            if (i) delete r[_];
        }
        return t.exports;
    }
    if (typeof __nccwpck_require__ !== "undefined") __nccwpck_require__.ab = __dirname + "/";
    var _ = __nccwpck_require__(328);
    module.exports = _;
})();

}.call(this) }),
}]);


//# sourceMappingURL=node_modules_next_dist_compiled_e91a99.js.c45c78a954f1c437.map